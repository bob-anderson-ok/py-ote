# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'pyote.ui'
#
# Created by: PyQt5 UI code generator 5.14.0
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1904, 1165)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setMinimumSize(QtCore.QSize(1900, 1000))
        MainWindow.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_8.setObjectName("gridLayout_8")
        self.splitterThree = QtWidgets.QSplitter(self.centralwidget)
        self.splitterThree.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.splitterThree.sizePolicy().hasHeightForWidth())
        self.splitterThree.setSizePolicy(sizePolicy)
        self.splitterThree.setOrientation(QtCore.Qt.Vertical)
        self.splitterThree.setHandleWidth(10)
        self.splitterThree.setObjectName("splitterThree")
        self.splitterTwo = QtWidgets.QSplitter(self.splitterThree)
        self.splitterTwo.setOrientation(QtCore.Qt.Horizontal)
        self.splitterTwo.setHandleWidth(10)
        self.splitterTwo.setObjectName("splitterTwo")
        self.layoutWidget = QtWidgets.QWidget(self.splitterTwo)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.plotHelpButton = QtWidgets.QPushButton(self.layoutWidget)
        self.plotHelpButton.setMaximumSize(QtCore.QSize(150, 16777215))
        self.plotHelpButton.setObjectName("plotHelpButton")
        self.gridLayout.addWidget(self.plotHelpButton, 0, 4, 1, 1)
        self.infoButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.infoButton.sizePolicy().hasHeightForWidth())
        self.infoButton.setSizePolicy(sizePolicy)
        self.infoButton.setAutoDefault(False)
        self.infoButton.setObjectName("infoButton")
        self.gridLayout.addWidget(self.infoButton, 0, 0, 1, 1)
        self.readData = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.readData.sizePolicy().hasHeightForWidth())
        self.readData.setSizePolicy(sizePolicy)
        self.readData.setToolTipDuration(-1)
        self.readData.setObjectName("readData")
        self.gridLayout.addWidget(self.readData, 0, 3, 1, 1)
        self.helpButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.helpButton.sizePolicy().hasHeightForWidth())
        self.helpButton.setSizePolicy(sizePolicy)
        self.helpButton.setObjectName("helpButton")
        self.gridLayout.addWidget(self.helpButton, 0, 1, 1, 1)
        self.tutorialButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tutorialButton.sizePolicy().hasHeightForWidth())
        self.tutorialButton.setSizePolicy(sizePolicy)
        self.tutorialButton.setObjectName("tutorialButton")
        self.gridLayout.addWidget(self.tutorialButton, 0, 2, 1, 1)
        self.verticalLayout_2.addLayout(self.gridLayout)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.tabWidget = QtWidgets.QTabWidget(self.layoutWidget)
        self.tabWidget.setMovable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.analysisTab = QtWidgets.QWidget()
        self.analysisTab.setObjectName("analysisTab")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.analysisTab)
        self.gridLayout_4.setObjectName("gridLayout_4")
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem, 18, 3, 1, 1)
        self.line_3 = QtWidgets.QFrame(self.analysisTab)
        self.line_3.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_3.setLineWidth(4)
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setObjectName("line_3")
        self.gridLayout_4.addWidget(self.line_3, 3, 1, 1, 1)
        self.line_4 = QtWidgets.QFrame(self.analysisTab)
        self.line_4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_4.setLineWidth(4)
        self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_4.setObjectName("line_4")
        self.gridLayout_4.addWidget(self.line_4, 5, 1, 1, 1)
        self.markRegionsLabel = QtWidgets.QLabel(self.analysisTab)
        self.markRegionsLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.markRegionsLabel.setObjectName("markRegionsLabel")
        self.gridLayout_4.addWidget(self.markRegionsLabel, 8, 1, 1, 1)
        self.minMaxLabel = QtWidgets.QLabel(self.analysisTab)
        self.minMaxLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.minMaxLabel.setObjectName("minMaxLabel")
        self.gridLayout_4.addWidget(self.minMaxLabel, 10, 1, 1, 1)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem1, 11, 0, 1, 1)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem2, 11, 4, 1, 1)
        spacerItem3 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem3, 0, 2, 1, 1)
        self.line_2 = QtWidgets.QFrame(self.analysisTab)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_2.setLineWidth(4)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setObjectName("line_2")
        self.gridLayout_4.addWidget(self.line_2, 12, 1, 1, 3)
        self.findEventLabel = QtWidgets.QLabel(self.analysisTab)
        self.findEventLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.findEventLabel.setObjectName("findEventLabel")
        self.gridLayout_4.addWidget(self.findEventLabel, 13, 1, 1, 1)
        self.line_6 = QtWidgets.QFrame(self.analysisTab)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_6.setLineWidth(4)
        self.line_6.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_6.setObjectName("line_6")
        self.gridLayout_4.addWidget(self.line_6, 16, 1, 1, 3)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.smoothSecondaryButton = QtWidgets.QPushButton(self.analysisTab)
        self.smoothSecondaryButton.setEnabled(False)
        self.smoothSecondaryButton.setObjectName("smoothSecondaryButton")
        self.horizontalLayout_8.addWidget(self.smoothSecondaryButton)
        self.numSmoothingPointsLabel = QtWidgets.QLabel(self.analysisTab)
        self.numSmoothingPointsLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.numSmoothingPointsLabel.setObjectName("numSmoothingPointsLabel")
        self.horizontalLayout_8.addWidget(self.numSmoothingPointsLabel)
        self.numSmoothPointsEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.numSmoothPointsEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.numSmoothPointsEdit.sizePolicy().hasHeightForWidth())
        self.numSmoothPointsEdit.setSizePolicy(sizePolicy)
        self.numSmoothPointsEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.numSmoothPointsEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.numSmoothPointsEdit.setFrame(True)
        self.numSmoothPointsEdit.setObjectName("numSmoothPointsEdit")
        self.horizontalLayout_8.addWidget(self.numSmoothPointsEdit)
        self.verticalLayout.addLayout(self.horizontalLayout_8)
        self.normalizeButton = QtWidgets.QPushButton(self.analysisTab)
        self.normalizeButton.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.normalizeButton.sizePolicy().hasHeightForWidth())
        self.normalizeButton.setSizePolicy(sizePolicy)
        self.normalizeButton.setObjectName("normalizeButton")
        self.verticalLayout.addWidget(self.normalizeButton)
        self.gridLayout_4.addLayout(self.verticalLayout, 6, 1, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lightCurveNumberLabel = QtWidgets.QLabel(self.analysisTab)
        self.lightCurveNumberLabel.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lightCurveNumberLabel.sizePolicy().hasHeightForWidth())
        self.lightCurveNumberLabel.setSizePolicy(sizePolicy)
        self.lightCurveNumberLabel.setObjectName("lightCurveNumberLabel")
        self.horizontalLayout.addWidget(self.lightCurveNumberLabel)
        self.curveToAnalyzeSpinBox = QtWidgets.QSpinBox(self.analysisTab)
        self.curveToAnalyzeSpinBox.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.curveToAnalyzeSpinBox.sizePolicy().hasHeightForWidth())
        self.curveToAnalyzeSpinBox.setSizePolicy(sizePolicy)
        self.curveToAnalyzeSpinBox.setMinimum(0)
        self.curveToAnalyzeSpinBox.setMaximum(12)
        self.curveToAnalyzeSpinBox.setObjectName("curveToAnalyzeSpinBox")
        self.horizontalLayout.addWidget(self.curveToAnalyzeSpinBox)
        self.lightCurveNameEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.lightCurveNameEdit.setReadOnly(True)
        self.lightCurveNameEdit.setObjectName("lightCurveNameEdit")
        self.horizontalLayout.addWidget(self.lightCurveNameEdit)
        self.gridLayout_4.addLayout(self.horizontalLayout, 1, 1, 1, 1)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.normLabel = QtWidgets.QLabel(self.analysisTab)
        self.normLabel.setEnabled(False)
        self.normLabel.setObjectName("normLabel")
        self.horizontalLayout_2.addWidget(self.normLabel)
        self.secondarySelector = QtWidgets.QSpinBox(self.analysisTab)
        self.secondarySelector.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.secondarySelector.sizePolicy().hasHeightForWidth())
        self.secondarySelector.setSizePolicy(sizePolicy)
        self.secondarySelector.setMinimum(0)
        self.secondarySelector.setMaximum(12)
        self.secondarySelector.setProperty("value", 0)
        self.secondarySelector.setObjectName("secondarySelector")
        self.horizontalLayout_2.addWidget(self.secondarySelector)
        self.normalizationLightCurveNameEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.normalizationLightCurveNameEdit.setReadOnly(True)
        self.normalizationLightCurveNameEdit.setObjectName("normalizationLightCurveNameEdit")
        self.horizontalLayout_2.addWidget(self.normalizationLightCurveNameEdit)
        self.gridLayout_4.addLayout(self.horizontalLayout_2, 2, 1, 1, 1)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.locateEvent = QtWidgets.QPushButton(self.analysisTab)
        self.locateEvent.setEnabled(False)
        self.locateEvent.setObjectName("locateEvent")
        self.horizontalLayout_4.addWidget(self.locateEvent)
        self.calcErrBars = QtWidgets.QPushButton(self.analysisTab)
        self.calcErrBars.setEnabled(False)
        self.calcErrBars.setObjectName("calcErrBars")
        self.horizontalLayout_4.addWidget(self.calcErrBars)
        self.helpLabelForFalsePositive = QtWidgets.QLabel(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.helpLabelForFalsePositive.sizePolicy().hasHeightForWidth())
        self.helpLabelForFalsePositive.setSizePolicy(sizePolicy)
        self.helpLabelForFalsePositive.setMinimumSize(QtCore.QSize(10, 0))
        self.helpLabelForFalsePositive.setText("")
        self.helpLabelForFalsePositive.setObjectName("helpLabelForFalsePositive")
        self.horizontalLayout_4.addWidget(self.helpLabelForFalsePositive)
        self.fillExcelReportButton = QtWidgets.QPushButton(self.analysisTab)
        self.fillExcelReportButton.setEnabled(False)
        self.fillExcelReportButton.setObjectName("fillExcelReportButton")
        self.horizontalLayout_4.addWidget(self.fillExcelReportButton)
        self.gridLayout_4.addLayout(self.horizontalLayout_4, 14, 1, 1, 2)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.progressBar = QtWidgets.QProgressBar(self.analysisTab)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        self.horizontalLayout_7.addWidget(self.progressBar)
        self.cancelButton = QtWidgets.QPushButton(self.analysisTab)
        self.cancelButton.setObjectName("cancelButton")
        self.horizontalLayout_7.addWidget(self.cancelButton)
        self.gridLayout_4.addLayout(self.horizontalLayout_7, 15, 1, 1, 1)
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.writePlot = QtWidgets.QPushButton(self.analysisTab)
        self.writePlot.setEnabled(False)
        self.writePlot.setObjectName("writePlot")
        self.horizontalLayout_5.addWidget(self.writePlot)
        self.writeBarPlots = QtWidgets.QPushButton(self.analysisTab)
        self.writeBarPlots.setEnabled(False)
        self.writeBarPlots.setObjectName("writeBarPlots")
        self.horizontalLayout_5.addWidget(self.writeBarPlots)
        self.writeCSVButton = QtWidgets.QPushButton(self.analysisTab)
        self.writeCSVButton.setEnabled(False)
        self.writeCSVButton.setObjectName("writeCSVButton")
        self.horizontalLayout_5.addWidget(self.writeCSVButton)
        self.verticalLayout_5.addLayout(self.horizontalLayout_5)
        self.startOver = QtWidgets.QPushButton(self.analysisTab)
        self.startOver.setEnabled(False)
        self.startOver.setObjectName("startOver")
        self.verticalLayout_5.addWidget(self.startOver)
        self.gridLayout_4.addLayout(self.verticalLayout_5, 17, 1, 1, 3)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        spacerItem4 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem4)
        self.minEventLabel = QtWidgets.QLabel(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventLabel.sizePolicy().hasHeightForWidth())
        self.minEventLabel.setSizePolicy(sizePolicy)
        self.minEventLabel.setMinimumSize(QtCore.QSize(50, 0))
        self.minEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.minEventLabel.setObjectName("minEventLabel")
        self.horizontalLayout_10.addWidget(self.minEventLabel)
        self.minEventEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.minEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventEdit.sizePolicy().hasHeightForWidth())
        self.minEventEdit.setSizePolicy(sizePolicy)
        self.minEventEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.minEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.minEventEdit.setObjectName("minEventEdit")
        self.horizontalLayout_10.addWidget(self.minEventEdit)
        self.horizontalLayout_12.addLayout(self.horizontalLayout_10)
        spacerItem5 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_12.addItem(spacerItem5)
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.maxEventLabel = QtWidgets.QLabel(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventLabel.sizePolicy().hasHeightForWidth())
        self.maxEventLabel.setSizePolicy(sizePolicy)
        self.maxEventLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.maxEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.maxEventLabel.setObjectName("maxEventLabel")
        self.horizontalLayout_11.addWidget(self.maxEventLabel)
        self.maxEventEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.maxEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventEdit.sizePolicy().hasHeightForWidth())
        self.maxEventEdit.setSizePolicy(sizePolicy)
        self.maxEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.maxEventEdit.setObjectName("maxEventEdit")
        self.horizontalLayout_11.addWidget(self.maxEventEdit)
        spacerItem6 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_11.addItem(spacerItem6)
        self.horizontalLayout_12.addLayout(self.horizontalLayout_11)
        self.gridLayout_4.addLayout(self.horizontalLayout_12, 11, 1, 1, 2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.markDzone = QtWidgets.QPushButton(self.analysisTab)
        self.markDzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markDzone.sizePolicy().hasHeightForWidth())
        self.markDzone.setSizePolicy(sizePolicy)
        self.markDzone.setObjectName("markDzone")
        self.horizontalLayout_3.addWidget(self.markDzone)
        self.markRzone = QtWidgets.QPushButton(self.analysisTab)
        self.markRzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markRzone.sizePolicy().hasHeightForWidth())
        self.markRzone.setSizePolicy(sizePolicy)
        self.markRzone.setObjectName("markRzone")
        self.horizontalLayout_3.addWidget(self.markRzone)
        self.markEzone = QtWidgets.QPushButton(self.analysisTab)
        self.markEzone.setEnabled(False)
        self.markEzone.setObjectName("markEzone")
        self.horizontalLayout_3.addWidget(self.markEzone)
        self.gridLayout_4.addLayout(self.horizontalLayout_3, 9, 1, 1, 1)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setContentsMargins(0, -1, -1, -1)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.doBlockIntegration = QtWidgets.QPushButton(self.analysisTab)
        self.doBlockIntegration.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.doBlockIntegration.sizePolicy().hasHeightForWidth())
        self.doBlockIntegration.setSizePolicy(sizePolicy)
        self.doBlockIntegration.setObjectName("doBlockIntegration")
        self.verticalLayout_6.addWidget(self.doBlockIntegration)
        self.acceptBlockIntegration = QtWidgets.QPushButton(self.analysisTab)
        self.acceptBlockIntegration.setEnabled(False)
        self.acceptBlockIntegration.setObjectName("acceptBlockIntegration")
        self.verticalLayout_6.addWidget(self.acceptBlockIntegration)
        self.setDataLimits = QtWidgets.QPushButton(self.analysisTab)
        self.setDataLimits.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.setDataLimits.sizePolicy().hasHeightForWidth())
        self.setDataLimits.setSizePolicy(sizePolicy)
        self.setDataLimits.setToolTipDuration(-1)
        self.setDataLimits.setObjectName("setDataLimits")
        self.verticalLayout_6.addWidget(self.setDataLimits)
        self.gridLayout_4.addLayout(self.verticalLayout_6, 4, 1, 1, 1)
        self.line = QtWidgets.QFrame(self.analysisTab)
        self.line.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line.setLineWidth(4)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setObjectName("line")
        self.gridLayout_4.addWidget(self.line, 7, 1, 1, 3)
        self.tabWidget.addTab(self.analysisTab, "")
        self.diffractionTab = QtWidgets.QWidget()
        self.diffractionTab.setObjectName("diffractionTab")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.diffractionTab)
        self.gridLayout_7.setObjectName("gridLayout_7")
        spacerItem7 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_7.addItem(spacerItem7, 0, 1, 1, 1)
        self.underlyingLightcurveLabel = QtWidgets.QLabel(self.diffractionTab)
        self.underlyingLightcurveLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.underlyingLightcurveLabel.setObjectName("underlyingLightcurveLabel")
        self.gridLayout_7.addWidget(self.underlyingLightcurveLabel, 1, 1, 1, 2)
        self.line_7 = QtWidgets.QFrame(self.diffractionTab)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_7.setLineWidth(4)
        self.line_7.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_7.setObjectName("line_7")
        self.gridLayout_7.addWidget(self.line_7, 2, 1, 1, 2)
        spacerItem8 = QtWidgets.QSpacerItem(51, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem8, 3, 0, 1, 1)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_13.setObjectName("horizontalLayout_13")
        self.exposureTimeLabel = QtWidgets.QLabel(self.diffractionTab)
        self.exposureTimeLabel.setObjectName("exposureTimeLabel")
        self.horizontalLayout_13.addWidget(self.exposureTimeLabel)
        self.expDurEdit = QtWidgets.QLineEdit(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.expDurEdit.sizePolicy().hasHeightForWidth())
        self.expDurEdit.setSizePolicy(sizePolicy)
        self.expDurEdit.setMaximumSize(QtCore.QSize(90, 16777215))
        self.expDurEdit.setObjectName("expDurEdit")
        self.horizontalLayout_13.addWidget(self.expDurEdit)
        self.asteroidDistanceLabel = QtWidgets.QLabel(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.asteroidDistanceLabel.sizePolicy().hasHeightForWidth())
        self.asteroidDistanceLabel.setSizePolicy(sizePolicy)
        self.asteroidDistanceLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.asteroidDistanceLabel.setObjectName("asteroidDistanceLabel")
        self.horizontalLayout_13.addWidget(self.asteroidDistanceLabel)
        self.asteroidDistanceEdit = QtWidgets.QLineEdit(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.asteroidDistanceEdit.sizePolicy().hasHeightForWidth())
        self.asteroidDistanceEdit.setSizePolicy(sizePolicy)
        self.asteroidDistanceEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.asteroidDistanceEdit.setObjectName("asteroidDistanceEdit")
        self.horizontalLayout_13.addWidget(self.asteroidDistanceEdit)
        self.shadowSpeedLabel = QtWidgets.QLabel(self.diffractionTab)
        self.shadowSpeedLabel.setObjectName("shadowSpeedLabel")
        self.horizontalLayout_13.addWidget(self.shadowSpeedLabel)
        self.shadowSpeedEdit = QtWidgets.QLineEdit(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.shadowSpeedEdit.sizePolicy().hasHeightForWidth())
        self.shadowSpeedEdit.setSizePolicy(sizePolicy)
        self.shadowSpeedEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.shadowSpeedEdit.setObjectName("shadowSpeedEdit")
        self.horizontalLayout_13.addWidget(self.shadowSpeedEdit)
        spacerItem9 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_13.addItem(spacerItem9)
        self.gridLayout_7.addLayout(self.horizontalLayout_13, 3, 1, 1, 2)
        spacerItem10 = QtWidgets.QSpacerItem(51, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem10, 3, 3, 1, 1)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.asteroidSizeLabel = QtWidgets.QLabel(self.diffractionTab)
        self.asteroidSizeLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.asteroidSizeLabel.setObjectName("asteroidSizeLabel")
        self.horizontalLayout_15.addWidget(self.asteroidSizeLabel)
        self.astSizeEdit = QtWidgets.QLineEdit(self.diffractionTab)
        self.astSizeEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.astSizeEdit.setObjectName("astSizeEdit")
        self.horizontalLayout_15.addWidget(self.astSizeEdit)
        self.pathOffsetLabel = QtWidgets.QLabel(self.diffractionTab)
        self.pathOffsetLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.pathOffsetLabel.setObjectName("pathOffsetLabel")
        self.horizontalLayout_15.addWidget(self.pathOffsetLabel)
        self.pathOffsetEdit = QtWidgets.QLineEdit(self.diffractionTab)
        self.pathOffsetEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.pathOffsetEdit.setObjectName("pathOffsetEdit")
        self.horizontalLayout_15.addWidget(self.pathOffsetEdit)
        spacerItem11 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_15.addItem(spacerItem11)
        self.gridLayout_7.addLayout(self.horizontalLayout_15, 4, 1, 1, 2)
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setSpacing(0)
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.starDiameterLabel = QtWidgets.QLabel(self.diffractionTab)
        self.starDiameterLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.starDiameterLabel.setObjectName("starDiameterLabel")
        self.horizontalLayout_14.addWidget(self.starDiameterLabel)
        self.starDiameterEdit = QtWidgets.QLineEdit(self.diffractionTab)
        self.starDiameterEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.starDiameterEdit.setObjectName("starDiameterEdit")
        self.horizontalLayout_14.addWidget(self.starDiameterEdit)
        self.dLimbAngleLabel = QtWidgets.QLabel(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dLimbAngleLabel.sizePolicy().hasHeightForWidth())
        self.dLimbAngleLabel.setSizePolicy(sizePolicy)
        self.dLimbAngleLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.dLimbAngleLabel.setObjectName("dLimbAngleLabel")
        self.horizontalLayout_14.addWidget(self.dLimbAngleLabel)
        self.dLimbAngle = QtWidgets.QDoubleSpinBox(self.diffractionTab)
        self.dLimbAngle.setMaximumSize(QtCore.QSize(80, 16777215))
        self.dLimbAngle.setDecimals(1)
        self.dLimbAngle.setMaximum(90.0)
        self.dLimbAngle.setProperty("value", 90.0)
        self.dLimbAngle.setObjectName("dLimbAngle")
        self.horizontalLayout_14.addWidget(self.dLimbAngle)
        self.rLimbAngleLabel = QtWidgets.QLabel(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.rLimbAngleLabel.sizePolicy().hasHeightForWidth())
        self.rLimbAngleLabel.setSizePolicy(sizePolicy)
        self.rLimbAngleLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.rLimbAngleLabel.setObjectName("rLimbAngleLabel")
        self.horizontalLayout_14.addWidget(self.rLimbAngleLabel)
        self.rLimbAngle = QtWidgets.QDoubleSpinBox(self.diffractionTab)
        self.rLimbAngle.setMaximumSize(QtCore.QSize(80, 16777215))
        self.rLimbAngle.setDecimals(1)
        self.rLimbAngle.setMaximum(90.0)
        self.rLimbAngle.setProperty("value", 90.0)
        self.rLimbAngle.setObjectName("rLimbAngle")
        self.horizontalLayout_14.addWidget(self.rLimbAngle)
        spacerItem12 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_14.addItem(spacerItem12)
        self.gridLayout_7.addLayout(self.horizontalLayout_14, 5, 1, 1, 2)
        self.line_8 = QtWidgets.QFrame(self.diffractionTab)
        self.line_8.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_8.setLineWidth(4)
        self.line_8.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_8.setObjectName("line_8")
        self.gridLayout_7.addWidget(self.line_8, 6, 1, 1, 2)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.demoUnderlyingLighturvesButton = QtWidgets.QPushButton(self.diffractionTab)
        self.demoUnderlyingLighturvesButton.setObjectName("demoUnderlyingLighturvesButton")
        self.horizontalLayout_16.addWidget(self.demoUnderlyingLighturvesButton)
        self.enableDiffractionCalculationBox = QtWidgets.QCheckBox(self.diffractionTab)
        self.enableDiffractionCalculationBox.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.enableDiffractionCalculationBox.setChecked(True)
        self.enableDiffractionCalculationBox.setObjectName("enableDiffractionCalculationBox")
        self.horizontalLayout_16.addWidget(self.enableDiffractionCalculationBox)
        self.penumbralFitCheckBox = QtWidgets.QCheckBox(self.diffractionTab)
        self.penumbralFitCheckBox.setEnabled(False)
        self.penumbralFitCheckBox.setMaximumSize(QtCore.QSize(120, 16777215))
        self.penumbralFitCheckBox.setObjectName("penumbralFitCheckBox")
        self.horizontalLayout_16.addWidget(self.penumbralFitCheckBox)
        self.gridLayout_7.addLayout(self.horizontalLayout_16, 7, 1, 1, 2)
        spacerItem13 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_7.addItem(spacerItem13, 8, 2, 1, 1)
        self.tabWidget.addTab(self.diffractionTab, "")
        self.tab_9 = QtWidgets.QWidget()
        self.tab_9.setObjectName("tab_9")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.tab_9)
        self.gridLayout_3.setObjectName("gridLayout_3")
        spacerItem14 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_3.addItem(spacerItem14, 0, 1, 1, 1)
        spacerItem15 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem15, 1, 0, 1, 1)
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.calcFlashEdge = QtWidgets.QPushButton(self.tab_9)
        self.calcFlashEdge.setEnabled(False)
        self.calcFlashEdge.setObjectName("calcFlashEdge")
        self.verticalLayout_4.addWidget(self.calcFlashEdge)
        self.horizontalLayout_22 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_22.setObjectName("horizontalLayout_22")
        self.manualTimestampCheckBox = QtWidgets.QCheckBox(self.tab_9)
        self.manualTimestampCheckBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.manualTimestampCheckBox.setObjectName("manualTimestampCheckBox")
        self.horizontalLayout_22.addWidget(self.manualTimestampCheckBox)
        self.manualEntryPushButton = QtWidgets.QPushButton(self.tab_9)
        self.manualEntryPushButton.setEnabled(False)
        self.manualEntryPushButton.setObjectName("manualEntryPushButton")
        self.horizontalLayout_22.addWidget(self.manualEntryPushButton)
        self.verticalLayout_4.addLayout(self.horizontalLayout_22)
        self.gridLayout_3.addLayout(self.verticalLayout_4, 1, 1, 1, 1)
        spacerItem16 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem16, 1, 2, 1, 1)
        spacerItem17 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_3.addItem(spacerItem17, 2, 1, 1, 1)
        self.tabWidget.addTab(self.tab_9, "")
        self.settingsTab = QtWidgets.QWidget()
        self.settingsTab.setObjectName("settingsTab")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.settingsTab)
        self.gridLayout_5.setObjectName("gridLayout_5")
        self.line_11 = QtWidgets.QFrame(self.settingsTab)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_11.setLineWidth(4)
        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_11.setObjectName("line_11")
        self.gridLayout_5.addWidget(self.line_11, 6, 1, 1, 2)
        self.line_13 = QtWidgets.QFrame(self.settingsTab)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_13.setLineWidth(4)
        self.line_13.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_13.setObjectName("line_13")
        self.gridLayout_5.addWidget(self.line_13, 12, 1, 1, 2)
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.viewFrameButton = QtWidgets.QPushButton(self.settingsTab)
        self.viewFrameButton.setEnabled(False)
        self.viewFrameButton.setObjectName("viewFrameButton")
        self.horizontalLayout_18.addWidget(self.viewFrameButton)
        self.frameNumSpinBox = QtWidgets.QSpinBox(self.settingsTab)
        self.frameNumSpinBox.setEnabled(False)
        self.frameNumSpinBox.setMaximumSize(QtCore.QSize(100, 16777215))
        self.frameNumSpinBox.setSizeIncrement(QtCore.QSize(0, 0))
        self.frameNumSpinBox.setMaximum(99999)
        self.frameNumSpinBox.setObjectName("frameNumSpinBox")
        self.horizontalLayout_18.addWidget(self.frameNumSpinBox)
        self.gridLayout_5.addLayout(self.horizontalLayout_18, 5, 1, 1, 2)
        spacerItem18 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem18, 17, 1, 1, 1)
        self.label = QtWidgets.QLabel(self.settingsTab)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")
        self.gridLayout_5.addWidget(self.label, 1, 1, 1, 2)
        self.line_5 = QtWidgets.QFrame(self.settingsTab)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_5.setLineWidth(4)
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setObjectName("line_5")
        self.gridLayout_5.addWidget(self.line_5, 3, 1, 1, 2)
        spacerItem19 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem19, 3, 3, 2, 1)
        spacerItem20 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem20, 0, 2, 1, 1)
        self.label_2 = QtWidgets.QLabel(self.settingsTab)
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.gridLayout_5.addWidget(self.label_2, 4, 1, 1, 2)
        self.horizontalLayout_19 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_19.setObjectName("horizontalLayout_19")
        self.fieldViewCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.fieldViewCheckBox.setEnabled(False)
        self.fieldViewCheckBox.setObjectName("fieldViewCheckBox")
        self.horizontalLayout_19.addWidget(self.fieldViewCheckBox)
        self.flipYaxisCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.flipYaxisCheckBox.setEnabled(False)
        self.flipYaxisCheckBox.setObjectName("flipYaxisCheckBox")
        self.horizontalLayout_19.addWidget(self.flipYaxisCheckBox)
        self.flipXaxisCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.flipXaxisCheckBox.setEnabled(False)
        self.flipXaxisCheckBox.setObjectName("flipXaxisCheckBox")
        self.horizontalLayout_19.addWidget(self.flipXaxisCheckBox)
        self.gridLayout_5.addLayout(self.horizontalLayout_19, 8, 1, 1, 2)
        self.label_3 = QtWidgets.QLabel(self.settingsTab)
        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.gridLayout_5.addWidget(self.label_3, 7, 1, 1, 2)
        spacerItem21 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem21, 3, 0, 2, 1)
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        self.showTimestampErrors = QtWidgets.QCheckBox(self.settingsTab)
        self.showTimestampErrors.setEnabled(False)
        self.showTimestampErrors.setObjectName("showTimestampErrors")
        self.horizontalLayout_17.addWidget(self.showTimestampErrors)
        self.showUnderlyingLightcurveCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showUnderlyingLightcurveCheckBox.setObjectName("showUnderlyingLightcurveCheckBox")
        self.horizontalLayout_17.addWidget(self.showUnderlyingLightcurveCheckBox)
        self.showErrBarsCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showErrBarsCheckBox.setChecked(True)
        self.showErrBarsCheckBox.setObjectName("showErrBarsCheckBox")
        self.horizontalLayout_17.addWidget(self.showErrBarsCheckBox)
        self.showEdgesCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showEdgesCheckBox.setChecked(True)
        self.showEdgesCheckBox.setObjectName("showEdgesCheckBox")
        self.horizontalLayout_17.addWidget(self.showEdgesCheckBox)
        self.showOCRcheckFramesCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showOCRcheckFramesCheckBox.setChecked(True)
        self.showOCRcheckFramesCheckBox.setObjectName("showOCRcheckFramesCheckBox")
        self.horizontalLayout_17.addWidget(self.showOCRcheckFramesCheckBox)
        self.showTimestampsCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showTimestampsCheckBox.setObjectName("showTimestampsCheckBox")
        self.horizontalLayout_17.addWidget(self.showTimestampsCheckBox)
        self.gridLayout_5.addLayout(self.horizontalLayout_17, 2, 1, 1, 2)
        self.line_9 = QtWidgets.QFrame(self.settingsTab)
        self.line_9.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_9.setLineWidth(4)
        self.line_9.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_9.setObjectName("line_9")
        self.gridLayout_5.addWidget(self.line_9, 9, 1, 1, 2)
        self.label_4 = QtWidgets.QLabel(self.settingsTab)
        self.label_4.setObjectName("label_4")
        self.gridLayout_5.addWidget(self.label_4, 10, 1, 1, 2)
        self.horizontalLayout_20 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_20.setObjectName("horizontalLayout_20")
        self.lineWidthLabel = QtWidgets.QLabel(self.settingsTab)
        self.lineWidthLabel.setObjectName("lineWidthLabel")
        self.horizontalLayout_20.addWidget(self.lineWidthLabel)
        self.lineWidthSpinner = QtWidgets.QSpinBox(self.settingsTab)
        self.lineWidthSpinner.setMinimum(1)
        self.lineWidthSpinner.setMaximum(9)
        self.lineWidthSpinner.setProperty("value", 2)
        self.lineWidthSpinner.setObjectName("lineWidthSpinner")
        self.horizontalLayout_20.addWidget(self.lineWidthSpinner)
        spacerItem22 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_20.addItem(spacerItem22)
        self.gridLayout_5.addLayout(self.horizontalLayout_20, 11, 1, 1, 1)
        self.label_7 = QtWidgets.QLabel(self.settingsTab)
        self.label_7.setObjectName("label_7")
        self.gridLayout_5.addWidget(self.label_7, 14, 1, 1, 1)
        self.label_6 = QtWidgets.QLabel(self.settingsTab)
        self.label_6.setObjectName("label_6")
        self.gridLayout_5.addWidget(self.label_6, 13, 1, 1, 1)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.pymovieDataColumnPrefixComboBox = QtWidgets.QComboBox(self.settingsTab)
        self.pymovieDataColumnPrefixComboBox.setCurrentText("")
        self.pymovieDataColumnPrefixComboBox.setObjectName("pymovieDataColumnPrefixComboBox")
        self.horizontalLayout_9.addWidget(self.pymovieDataColumnPrefixComboBox)
        self.label_5 = QtWidgets.QLabel(self.settingsTab)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_9.addWidget(self.label_5)
        spacerItem23 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_9.addItem(spacerItem23)
        self.gridLayout_5.addLayout(self.horizontalLayout_9, 16, 1, 1, 1)
        self.label_8 = QtWidgets.QLabel(self.settingsTab)
        self.label_8.setObjectName("label_8")
        self.gridLayout_5.addWidget(self.label_8, 15, 1, 1, 1)
        self.tabWidget.addTab(self.settingsTab, "")
        self.tab_8 = QtWidgets.QWidget()
        self.tab_8.setObjectName("tab_8")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.tab_8)
        self.gridLayout_6.setObjectName("gridLayout_6")
        spacerItem24 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_6.addItem(spacerItem24, 0, 1, 1, 1)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.detectabilityHelpButton = QtWidgets.QPushButton(self.tab_8)
        self.detectabilityHelpButton.setObjectName("detectabilityHelpButton")
        self.verticalLayout_3.addWidget(self.detectabilityHelpButton)
        self.line_12 = QtWidgets.QFrame(self.tab_8)
        self.line_12.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_12.setLineWidth(4)
        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_12.setObjectName("line_12")
        self.verticalLayout_3.addWidget(self.line_12)
        self.markBaselineRegionButton = QtWidgets.QPushButton(self.tab_8)
        self.markBaselineRegionButton.setObjectName("markBaselineRegionButton")
        self.verticalLayout_3.addWidget(self.markBaselineRegionButton)
        self.clearBaselineRegionsButton = QtWidgets.QPushButton(self.tab_8)
        self.clearBaselineRegionsButton.setObjectName("clearBaselineRegionsButton")
        self.verticalLayout_3.addWidget(self.clearBaselineRegionsButton)
        self.calcStatsFromBaselineRegionsButton = QtWidgets.QPushButton(self.tab_8)
        self.calcStatsFromBaselineRegionsButton.setObjectName("calcStatsFromBaselineRegionsButton")
        self.verticalLayout_3.addWidget(self.calcStatsFromBaselineRegionsButton)
        self.line_10 = QtWidgets.QFrame(self.tab_8)
        self.line_10.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_10.setLineWidth(4)
        self.line_10.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_10.setObjectName("line_10")
        self.verticalLayout_3.addWidget(self.line_10)
        self.gridLayout_6.addLayout(self.verticalLayout_3, 1, 1, 1, 1)
        spacerItem25 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem25, 2, 0, 1, 1)
        self.horizontalLayout_21 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_21.setObjectName("horizontalLayout_21")
        self.obsDurLabel = QtWidgets.QLabel(self.tab_8)
        self.obsDurLabel.setObjectName("obsDurLabel")
        self.horizontalLayout_21.addWidget(self.obsDurLabel)
        self.observationDurEdit = QtWidgets.QLineEdit(self.tab_8)
        self.observationDurEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.observationDurEdit.setMaximumSize(QtCore.QSize(80, 16777215))
        self.observationDurEdit.setObjectName("observationDurEdit")
        self.horizontalLayout_21.addWidget(self.observationDurEdit)
        self.eventDurLabel = QtWidgets.QLabel(self.tab_8)
        self.eventDurLabel.setObjectName("eventDurLabel")
        self.horizontalLayout_21.addWidget(self.eventDurLabel)
        self.eventDurationEdit = QtWidgets.QLineEdit(self.tab_8)
        self.eventDurationEdit.setMaximumSize(QtCore.QSize(80, 16777215))
        self.eventDurationEdit.setObjectName("eventDurationEdit")
        self.horizontalLayout_21.addWidget(self.eventDurationEdit)
        self.durStepLabel = QtWidgets.QLabel(self.tab_8)
        self.durStepLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.durStepLabel.setObjectName("durStepLabel")
        self.horizontalLayout_21.addWidget(self.durStepLabel)
        self.durStepEdit = QtWidgets.QLineEdit(self.tab_8)
        self.durStepEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.durStepEdit.setObjectName("durStepEdit")
        self.horizontalLayout_21.addWidget(self.durStepEdit)
        self.detectMagDropLabel = QtWidgets.QLabel(self.tab_8)
        self.detectMagDropLabel.setObjectName("detectMagDropLabel")
        self.horizontalLayout_21.addWidget(self.detectMagDropLabel)
        self.detectabilityMagDropEdit = QtWidgets.QLineEdit(self.tab_8)
        self.detectabilityMagDropEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.detectabilityMagDropEdit.setObjectName("detectabilityMagDropEdit")
        self.horizontalLayout_21.addWidget(self.detectabilityMagDropEdit)
        self.gridLayout_6.addLayout(self.horizontalLayout_21, 2, 1, 1, 1)
        spacerItem26 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem26, 2, 2, 1, 1)
        self.horizontalLayout_27 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_27.setObjectName("horizontalLayout_27")
        self.calcDetectabilityButton = QtWidgets.QPushButton(self.tab_8)
        self.calcDetectabilityButton.setMinimumSize(QtCore.QSize(500, 0))
        self.calcDetectabilityButton.setObjectName("calcDetectabilityButton")
        self.horizontalLayout_27.addWidget(self.calcDetectabilityButton)
        spacerItem27 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_27.addItem(spacerItem27)
        self.writeExampleLightcurveCheckBox = QtWidgets.QCheckBox(self.tab_8)
        self.writeExampleLightcurveCheckBox.setObjectName("writeExampleLightcurveCheckBox")
        self.horizontalLayout_27.addWidget(self.writeExampleLightcurveCheckBox)
        self.gridLayout_6.addLayout(self.horizontalLayout_27, 3, 1, 1, 1)
        spacerItem28 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_6.addItem(spacerItem28, 4, 1, 1, 1)
        self.tabWidget.addTab(self.tab_8, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab)
        self.gridLayout_2.setObjectName("gridLayout_2")
        spacerItem29 = QtWidgets.QSpacerItem(20, 247, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem29, 0, 1, 1, 1)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.ne3ExplanationButton = QtWidgets.QPushButton(self.tab)
        self.ne3ExplanationButton.setObjectName("ne3ExplanationButton")
        self.verticalLayout_7.addWidget(self.ne3ExplanationButton)
        self.ne3NotInUseRadioButton = QtWidgets.QRadioButton(self.tab)
        self.ne3NotInUseRadioButton.setChecked(True)
        self.ne3NotInUseRadioButton.setObjectName("ne3NotInUseRadioButton")
        self.verticalLayout_7.addWidget(self.ne3NotInUseRadioButton)
        self.line_14 = QtWidgets.QFrame(self.tab)
        self.line_14.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_14.setLineWidth(5)
        self.line_14.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_14.setObjectName("line_14")
        self.verticalLayout_7.addWidget(self.line_14)
        self.dnrOffRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrOffRadioButton.setChecked(False)
        self.dnrOffRadioButton.setObjectName("dnrOffRadioButton")
        self.verticalLayout_7.addWidget(self.dnrOffRadioButton)
        self.gridLayout_2.addLayout(self.verticalLayout_7, 1, 1, 1, 1)
        self.horizontalLayout_23 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_23.setObjectName("horizontalLayout_23")
        self.dnrLowRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrLowRadioButton.setObjectName("dnrLowRadioButton")
        self.horizontalLayout_23.addWidget(self.dnrLowRadioButton)
        spacerItem30 = QtWidgets.QSpacerItem(113, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_23.addItem(spacerItem30)
        self.dnrLowDtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrLowDtcLabel.setObjectName("dnrLowDtcLabel")
        self.horizontalLayout_23.addWidget(self.dnrLowDtcLabel)
        self.dnrLowDspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrLowDspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrLowDspinBox.setMinimum(0.1)
        self.dnrLowDspinBox.setMaximum(1.0)
        self.dnrLowDspinBox.setSingleStep(0.1)
        self.dnrLowDspinBox.setProperty("value", 0.5)
        self.dnrLowDspinBox.setObjectName("dnrLowDspinBox")
        self.horizontalLayout_23.addWidget(self.dnrLowDspinBox)
        self.dnrLowRtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrLowRtcLabel.setObjectName("dnrLowRtcLabel")
        self.horizontalLayout_23.addWidget(self.dnrLowRtcLabel)
        self.dnrLowRspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrLowRspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrLowRspinBox.setMaximum(1.0)
        self.dnrLowRspinBox.setSingleStep(0.1)
        self.dnrLowRspinBox.setProperty("value", 0.5)
        self.dnrLowRspinBox.setObjectName("dnrLowRspinBox")
        self.horizontalLayout_23.addWidget(self.dnrLowRspinBox)
        self.gridLayout_2.addLayout(self.horizontalLayout_23, 2, 1, 1, 1)
        spacerItem31 = QtWidgets.QSpacerItem(190, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem31, 3, 0, 1, 1)
        self.horizontalLayout_24 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_24.setObjectName("horizontalLayout_24")
        self.dnrMiddleRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrMiddleRadioButton.setObjectName("dnrMiddleRadioButton")
        self.horizontalLayout_24.addWidget(self.dnrMiddleRadioButton)
        spacerItem32 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_24.addItem(spacerItem32)
        self.dnrMiddleDtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrMiddleDtcLabel.setObjectName("dnrMiddleDtcLabel")
        self.horizontalLayout_24.addWidget(self.dnrMiddleDtcLabel)
        self.dnrMiddleDspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrMiddleDspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrMiddleDspinBox.setMinimum(0.5)
        self.dnrMiddleDspinBox.setMaximum(5.0)
        self.dnrMiddleDspinBox.setSingleStep(0.1)
        self.dnrMiddleDspinBox.setProperty("value", 1.0)
        self.dnrMiddleDspinBox.setObjectName("dnrMiddleDspinBox")
        self.horizontalLayout_24.addWidget(self.dnrMiddleDspinBox)
        self.dnrMiddleRtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrMiddleRtcLabel.setObjectName("dnrMiddleRtcLabel")
        self.horizontalLayout_24.addWidget(self.dnrMiddleRtcLabel)
        self.dnrMiddleRspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrMiddleRspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrMiddleRspinBox.setMinimum(0.5)
        self.dnrMiddleRspinBox.setMaximum(5.0)
        self.dnrMiddleRspinBox.setSingleStep(0.1)
        self.dnrMiddleRspinBox.setProperty("value", 1.0)
        self.dnrMiddleRspinBox.setObjectName("dnrMiddleRspinBox")
        self.horizontalLayout_24.addWidget(self.dnrMiddleRspinBox)
        self.gridLayout_2.addLayout(self.horizontalLayout_24, 3, 1, 1, 1)
        spacerItem33 = QtWidgets.QSpacerItem(113, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem33, 3, 2, 1, 1)
        self.horizontalLayout_25 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_25.setObjectName("horizontalLayout_25")
        self.dnrHighRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrHighRadioButton.setObjectName("dnrHighRadioButton")
        self.horizontalLayout_25.addWidget(self.dnrHighRadioButton)
        spacerItem34 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_25.addItem(spacerItem34)
        self.dnrHighDtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrHighDtcLabel.setObjectName("dnrHighDtcLabel")
        self.horizontalLayout_25.addWidget(self.dnrHighDtcLabel)
        self.dnrHighDspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrHighDspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrHighDspinBox.setMinimum(1.0)
        self.dnrHighDspinBox.setMaximum(10.0)
        self.dnrHighDspinBox.setSingleStep(0.1)
        self.dnrHighDspinBox.setProperty("value", 4.5)
        self.dnrHighDspinBox.setObjectName("dnrHighDspinBox")
        self.horizontalLayout_25.addWidget(self.dnrHighDspinBox)
        self.dnrHighRtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrHighRtcLabel.setObjectName("dnrHighRtcLabel")
        self.horizontalLayout_25.addWidget(self.dnrHighRtcLabel)
        self.dnrHighRspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrHighRspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrHighRspinBox.setMinimum(1.0)
        self.dnrHighRspinBox.setMaximum(10.0)
        self.dnrHighRspinBox.setSingleStep(0.1)
        self.dnrHighRspinBox.setProperty("value", 2.0)
        self.dnrHighRspinBox.setObjectName("dnrHighRspinBox")
        self.horizontalLayout_25.addWidget(self.dnrHighRspinBox)
        self.gridLayout_2.addLayout(self.horizontalLayout_25, 4, 1, 1, 1)
        self.line_15 = QtWidgets.QFrame(self.tab)
        self.line_15.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_15.setLineWidth(5)
        self.line_15.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_15.setObjectName("line_15")
        self.gridLayout_2.addWidget(self.line_15, 5, 1, 1, 1)
        self.horizontalLayout_26 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_26.setObjectName("horizontalLayout_26")
        spacerItem35 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_26.addItem(spacerItem35)
        self.yPositionLabel = QtWidgets.QLabel(self.tab)
        self.yPositionLabel.setObjectName("yPositionLabel")
        self.horizontalLayout_26.addWidget(self.yPositionLabel)
        self.targetStarYpositionSpinBox = QtWidgets.QSpinBox(self.tab)
        self.targetStarYpositionSpinBox.setMinimumSize(QtCore.QSize(80, 0))
        self.targetStarYpositionSpinBox.setMaximum(479)
        self.targetStarYpositionSpinBox.setObjectName("targetStarYpositionSpinBox")
        self.horizontalLayout_26.addWidget(self.targetStarYpositionSpinBox)
        spacerItem36 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_26.addItem(spacerItem36)
        self.gridLayout_2.addLayout(self.horizontalLayout_26, 6, 1, 1, 1)
        spacerItem37 = QtWidgets.QSpacerItem(20, 259, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem37, 7, 1, 1, 1)
        self.tabWidget.addTab(self.tab, "")
        self.horizontalLayout_6.addWidget(self.tabWidget)
        self.verticalLayout_2.addLayout(self.horizontalLayout_6)
        self.helpLabelForDataGrid = QtWidgets.QLabel(self.layoutWidget)
        self.helpLabelForDataGrid.setObjectName("helpLabelForDataGrid")
        self.verticalLayout_2.addWidget(self.helpLabelForDataGrid)
        self.mainPlot = PlotWidget(self.splitterTwo)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.mainPlot.sizePolicy().hasHeightForWidth())
        self.mainPlot.setSizePolicy(sizePolicy)
        self.mainPlot.setMinimumSize(QtCore.QSize(0, 0))
        self.mainPlot.viewport().setProperty("cursor", QtGui.QCursor(QtCore.Qt.IBeamCursor))
        self.mainPlot.setObjectName("mainPlot")
        self.splitterOne = QtWidgets.QSplitter(self.splitterThree)
        self.splitterOne.setOrientation(QtCore.Qt.Horizontal)
        self.splitterOne.setHandleWidth(10)
        self.splitterOne.setObjectName("splitterOne")
        self.table = QtWidgets.QTableWidget(self.splitterOne)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.table.sizePolicy().hasHeightForWidth())
        self.table.setSizePolicy(sizePolicy)
        self.table.setMinimumSize(QtCore.QSize(0, 0))
        self.table.setToolTipDuration(4000)
        self.table.setRowCount(11)
        self.table.setColumnCount(4)
        self.table.setObjectName("table")
        self.textOut = QtWidgets.QTextEdit(self.splitterOne)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.textOut.sizePolicy().hasHeightForWidth())
        self.textOut.setSizePolicy(sizePolicy)
        self.textOut.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.textOut.setUndoRedoEnabled(False)
        self.textOut.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        self.textOut.setReadOnly(True)
        self.textOut.setObjectName("textOut")
        self.gridLayout_8.addWidget(self.splitterThree, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(0)
        self.pymovieDataColumnPrefixComboBox.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "PY-OTE"))
        self.plotHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#0000ff;\">Once data from an observation is being displayed in the panel to the right, the following functions are available:</span></p><p>&gt;&gt;&gt; moving the mouse cursor into the plot area causes a thin vertical line to appear to show the x position</p><p>&gt;&gt;&gt; a left-click will toggle the selection of the data point at the x position of the mouse (watch the thin vertical line)</p><p>&gt;&gt;&gt; the plot can be zoomed horizontally using the scroll wheel (or equivalent) on the mouse</p><p>&gt;&gt;&gt; holding down the shift key will cause the mouse cursor to appear, useful for the following operation...</p><p>&gt;&gt;&gt; a left-click/hold/drag will create a selection box --- on left-button release, a zoomed image will appear</p><p>&gt;&gt;&gt; a right-click undoes any scroll/zoom modifications that have been performed</p><p><span style=\" font-weight:600; color:#0000ff;\">Timestamp errors:</span></p><p>If the csv file included timestamps, there may be a few (or many) thin vertical red lines, each appearing between adjacent data points.  These indicate that the time step computed from the adjacent data points was not within 10% of the \'expected\' time step.  The expected value is computed from the median of all time steps.  There is a checkbox to the left that can be used to suppress this display if it is too intrusive.</p><p><span style=\" font-weight:600; color:#0000ff;\">When a \'solution\' has been found, there will be displayed:</span></p><p>+++ in brown: the underlying lightcurve (theoretical lightcurve with diffraction and finite star disk effects included)</p><p>+++ in blue: the camera response --- this is the underlying lightcurve integrated by the exposure time of the camera</p><p>+++ vertical dashed lines: these show the position of the occultation\'s geometrical edges (red: D green: R)</p><p><span style=\" font-weight:600; color:#0000ff;\">After a \'... write report\' has been performed:</span></p><p>=== the 95% containment interval for the D and/or R edges are shown with shortened vertical dotted enclosing the central value</p></body></html>"))
        self.plotHelpButton.setText(_translate("MainWindow", "Help for plot -->"))
        self.infoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to to open the <span style=\" color:#ff0000;\">help.pdf</span> file that is included in the installation. The file will open in whatever PDF viewer you have assigned as the default viewer for pdf files.</p><p>The first part of this file is version info that should be examined every time a new version of PyOTE is installed.</p><p>At the bottom of this version info is a brief introduction to PyOTE that should be read by new users.</p></body></html>"))
        self.infoButton.setWhatsThis(_translate("MainWindow", "How does this show up?"))
        self.infoButton.setText(_translate("MainWindow", "Info"))
        self.readData.setToolTip(_translate("MainWindow", "<html><head/><body><p>PYOTE reads Limovie, R-OTE, and Tangra files and includes up to four light curves from those file types.  For PyMovie files, PYOTE will read an unlimited number of light curves.</p><p>Normally (but not required) object1 is the occulted star; other (optional) objects are reference stars to be used for normalizing the occulted star light curve or flash curves from an LED timer.</p><p><span style=\" font-weight:600; text-decoration: underline; color:#0000ff;\">Mouse button functions within the light curve plot:</span></p><p><span style=\" font-weight:600; color:#ff0000;\">Left click</span>: selects/deselects points on the primary (dark blue) light curve that intersect with the vertical hairline (the mouse cursor is disabled).</p><p><span style=\" font-weight:600; color:#ff0000;\">Left click and drag</span>: rectangular zoom is available to more clearly see points for selection (but point selection can also be accomplished through clicks in the tabular data display at the lower left)</p><p><span style=\" font-weight:600;\">Note! The shift key will toggle the mouse cursor on/off in the light curve plot.</span> This enables the starting corner for the zoom to be seen. (But points cannot be selected/deselected while the mouse cursor is visible. A right click will always \'blank\' the mouse cursor.) </p><p><span style=\" font-weight:600; color:#ff0000;\">Right click</span>: undo zoom</p><p><span style=\" color:#996633;\">Timestamp errors are shown with vertical red hairlines when a file is first read. These will disappear after the first point is selected so that the working view is as clear as possible. The red hairlines will re-appear permanently after the error bars have been calculated and the final report written to the log.</span></p></body></html>"))
        self.readData.setText(_translate("MainWindow", "Read light curve"))
        self.helpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>\'Help\' is available for most GUI items by right-clicking on the item.</p><p>If an item already has a different action assigned to a right-click, there will be a nearby text line or button that can be clicked on instead.</p><p>There is no need to close the help panel before right-clicking on another GUI item. One can use this feature to get a quick survey of the \'help\' that is available by sequentially clicking on all GUI items.</p></body></html>"))
        self.helpButton.setText(_translate("MainWindow", "Help"))
        self.tutorialButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Tip:&nbsp;right-click on buttons and labels.&nbsp;An explanation (help screen) will usually appear.&nbsp;Use that technique to learn about features that are not covered in this basic tutorial/recipe.</p><p>1. Start by clicking the<span style=\" font-weight:600; color:#0000ff;\"> Read light curve</span> button.&nbsp;(Usually,&nbsp;the camera exposure value will be read from the csv file and automatically inserted in the <span style=\" font-weight:600; color:#0000ff;\">exp:</span> edit box in the <span style=\" font-weight:600; color:#0000ff;\">parameters</span> panel.&nbsp;If that did not happen,&nbsp;you will need to manually fill in that value in before trying to find an event fit.)</p><p>2. If timestamp errors have been detected during the loading of the csv file,&nbsp;the affected points will be bracketed by vertical redlines and the <span style=\" font-weight:600; color:#0000ff;\">Show time err</span> checkbox will have been set by the program.&nbsp;Those red lines will likely have served their purpose and can/should be turned off so that a clear view of the light-curve is presented.</p><p>3. If the csv file contained multiple light-curves (it usually will),&nbsp;you may need to click the <span style=\" font-weight:600; color:#0000ff;\">Light curve to analyze</span> spinner to advance to the light-curve that contains the event.</p><p>4. The next step is to give the \'event finder\' information that can speed up the search. </p><p>4a. If the event has a wide enough bottom,&nbsp;the quickest way to provide speed-up information is mark the D and R regions.&nbsp;Right-click on those buttons for a how-to.</p><p>4b. If the event is so small that it is hard or impossible to mark D and R regions,&nbsp;the speed-up information is then best supplied by placing the smallest event duration in the <span style=\" font-weight:600; color:#0000ff;\">min event duration</span> edit box and the maximum event duration in the <span style=\" font-weight:600; color:#0000ff;\">max event duration</span> edit box.&nbsp;The \'finder\' will then search for all events in the range of durations given,&nbsp;located anywhere in the light-curve.</p><p>5. Next,&nbsp;click the <span style=\" font-weight:600; color:#0000ff;\">Find event, then ...</span> button to initiate the search.</p><p>6. Assuming the search was successful,&nbsp;the final step is to click the <span style=\" font-weight:600; color:#0000ff;\">... write report</span> button.</p><p>Every step you took is recorded in a log file in the directory where the light-curve was read from.&nbsp;This is important information to provide to anyone that you might go to for assistance.&nbsp;Give them the csv file and the log file and they will be able to reproduce your session.</p></body></html>"))
        self.tutorialButton.setText(_translate("MainWindow", "Tutorial"))
        self.markRegionsLabel.setText(_translate("MainWindow", "<html><head/><body><p>When edges are clearly visible, mark points to specify region and click ...</p></body></html>"))
        self.minMaxLabel.setText(_translate("MainWindow", "... otherwise use the entries below to place bounds on the event size."))
        self.findEventLabel.setText(_translate("MainWindow", "Finally, click on \'Find event\' and, if event found, click \'... write report\'"))
        self.smoothSecondaryButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Smooth the selected secondary (reference) star light curve using a Savitsky-Golay filter with a default window of 101 points (the edit box to the right allows for this value to be changed) and a degree 3 interpolating polynomial, applied twice.</p><p>The secondary star does not have to be visible for this smoothing to take place.</p><p>Smoothing of the secondary curve is a prerequisite to normalizing the occulted star light curve.</p></body></html>"))
        self.smoothSecondaryButton.setText(_translate("MainWindow", "Smooth secondary"))
        self.numSmoothingPointsLabel.setText(_translate("MainWindow", "num points in smoothing: "))
        self.numSmoothPointsEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>This edit box allows you to change the number of points used in Savitsky-Golay filter during smoothing of the secondary star. The window size should be an odd number in the range of 5 up to the number of data points in the secondary curve.</p><p>If an even number is specified, the window size used will be one less than that number.</p><p>Pressing <span style=\" font-weight:600; color:#ff0000;\">tab</span> or <span style=\" font-weight:600; color:#ff0000;\">return</span> at completion of data entry will trigger the smoothing, or you can click on the Smooth secondary button</p></body></html>"))
        self.numSmoothPointsEdit.setText(_translate("MainWindow", "101"))
        self.normalizeButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>If a smoothed secondary (reference) curve is available, and a single point has been selected on the curve to be normalized, the selected light curve will be \'normalized\' against the reference star. This can be useful in removing light curve distortions caused by clouds or similat light changes.</p><p>This done by creating a \'gain curve\' from the smoothed reference curve. The \'gain\' is unity at the selected point and proportionally larger/smaller at all the other points.</p><p>This \'gain curve\' is then multiplied point by point against the curve being analyzed to produce the \'normalized\' version of that light curve.</p><p>Normalization is a one-time-only procedure in that its effects can <span style=\" font-weight:600;\">not</span> be removed by use of the <span style=\" font-weight:600; color:#fc0107;\">Start over</span> button.</p></body></html>"))
        self.normalizeButton.setText(_translate("MainWindow", "Normalize around selected point"))
        self.lightCurveNumberLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spinner to select which light curve to analyze for an occultation event or as a source for \'flash timing\' edges.</p></body></html>"))
        self.lightCurveNumberLabel.setText(_translate("MainWindow", "Light curve number to analyze (blue):"))
        self.curveToAnalyzeSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spinner to select which light curve to analyze for an occultation event or as a source for \'flash timing\' edges.</p></body></html>"))
        self.normLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there are multiple reference stars in the file, this spinner will activate to allow the choice of which one to display/use.</p></body></html>"))
        self.normLabel.setText(_translate("MainWindow", "Light curve for normalization (green):"))
        self.secondarySelector.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there are multiple reference stars in the file, this spinner will activate to allow the choice of which one to display/use.</p></body></html>"))
        self.locateEvent.setText(_translate("MainWindow", "Find event, then ..."))
        self.calcErrBars.setToolTip(_translate("MainWindow", "<html><head/><body><p>To get a \'Final Report\', error bars are required. Clicking this button will start the computation of those error bars and, when complete, trigger the preparation of a \'Final Report\'</p></body></html>"))
        self.calcErrBars.setText(_translate("MainWindow", "... write report"))
        self.helpLabelForFalsePositive.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Advisory =============================================</span></p><p>Assuming that you have been diligent in removing common lightcurve artifacts (dips caused by something other than an occultation, &nbsp;like clouds,&nbsp;or a contrail,&nbsp;or ...) using the normalization function,&nbsp;please be aware that ...</p><p>... a non-zero False Positive probability (red bar to the left of the black bar) is usually sufficient reason to report a \'miss\' (but see note below).<span style=\" font-weight:600; color:#fc0107;\"> But</span>,&nbsp;before reporting a \'miss\',&nbsp;you should use the Event Detectability calculator to determine if the event was \'detectable\'.&nbsp;If the event was \'detectable\' and yet a \'miss\',&nbsp;the observation has value in constraining one edge of the asteroid.&nbsp;If the \'miss\' was of an \'undetectable\' event,&nbsp;its value as a constraint on the asteroid edge is greatly diminished.</p><p><span style=\" font-weight:600; color:#fc0107;\">However</span>,&nbsp; a False Positive probability of zero (red bar to the right of the black bar) should <span style=\" font-weight:600; color:#fc0107;\">NEVER</span> be the sole reason to report a \'positive\'.</p><p>If you get a zero False Positive probability <span style=\" font-weight:600; text-decoration: underline;\">and this is the only available chord</span>,&nbsp;look at the False Positive distribution plot and only consider reporting a \'positive\' if the measured drop is well to the right of the black bar (which shows the biggest drop found during the simulation run). \'Well to the right\' is rather vague,&nbsp;so consult with your area coordinator whenever you are uncertain.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if your observed \'drop\' (red bar) is near the black bar (on either side!) AND there are nearby chords reporting \'positives\',&nbsp;there may be value in your observation in spite of the False Positive probability calculation result;&nbsp;your observation may increase confidence in the event recorded by the nearby chords.<br/></p></body></html>"))
        self.fillExcelReportButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to copy your results to the Asteroid Occultation Report Form (.xlsx spreadsheet - note file type is .xlsx, not .xls). This button will be inactive (grayed out) until a succesful <span style=\" font-weight:600; color:#0000ff;\">... write report</span> has been accomplished.</p><p>The expected workflow is:</p><p>1) Given that PyOTE now has a solution that you wish to report (an occultation), leave PyOTE open ...</p><p>2) Run OccultWatcher to enter your event result report. Be sure to ask for a \'prefill\' of the .xls version of the report ...</p><p><span style=\" font-weight:600; color:#fc0107;\">3) Convert that .xls file to .xlsx using either Excel (Windows) or LibreOffice (Mac or Linux)</span></p><p>4) Go back to PyOTE and click this button ...</p><p>5) A file dialog will open; locate and select the prefilled and converted .xlsx report from steps 2 and 3.</p><p>6) If the file selected in step 5 was a valid Asteroid Occultation Report Form .xlsx file, the PyOTE results will be inserted.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: the excel format change from .xls to .xlsx will not affect the downstream processing adversely as the tool in use accepts either format equally well.</span></p><p><br/>The values that are inserted are:</p><p>--- all error bars</p><p>--- uncorrected D and/or R times</p><p>--- SNR</p><p>--- OTA used (PYOTE)</p><p>---A sentence summarizing magDrop information will be added in the Comments box</p></body></html>"))
        self.fillExcelReportButton.setText(_translate("MainWindow", "... fill Excel report"))
        self.cancelButton.setText(_translate("MainWindow", "Cancel"))
        self.writePlot.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: At the conclusion of error bar calculations, PYOTE automatically writes the main plot to a png file using the name and directory of the just-processed csv file. </p><p>If you want/need to record other versions of that plot, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.<br/></p></body></html>"))
        self.writePlot.setText(_translate("MainWindow", "Write current plot"))
        self.writeBarPlots.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: At the conclusion of error bar calculations, PYOTE automatically writes the error bar plots to appropriately named png files using the name and directory of the just-processed csv file. </p><p>If you want/need to record other versions of those plots, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.</p></body></html>"))
        self.writeBarPlots.setText(_translate("MainWindow", "Write error bar plot"))
        self.writeCSVButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to write the contents of the data table below to a csv file.</p><p>The comment lines from the original input file are preserved.</p><p>The most common use for this function is to capture the result of a successful Manual Timestamp Entry for later use (without the need to again go through the manual timestamp entry procedure). It will also reflect any Block Integration that was applied.</p></body></html>"))
        self.writeCSVButton.setText(_translate("MainWindow", "Save current light curve to .csv"))
        self.startOver.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button removes any trim that is in effect, clears a solution that may have been found, removes a smoothed reference curve, and removes any D or R region that is showing.</p><p>It does <span style=\" font-weight:600; font-style:italic; color:#fc0107;\">not</span> undo block integration or light curve normalization -- you must reload the light curve file to recover from those procedures.</p></body></html>"))
        self.startOver.setText(_translate("MainWindow", "Start over"))
        self.minEventLabel.setText(_translate("MainWindow", "min event:"))
        self.minEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter smallest event size (in number of readings) to search for.</p></body></html>"))
        self.maxEventLabel.setText(_translate("MainWindow", "max event:"))
        self.maxEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter largest event size (in number of readings) to search for.</p></body></html>"))
        self.markDzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star ‘disappears’, then click this button to create a D search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If no points are selected, a search for a D transition will not be performed --- this becomes an \'R only\' event.</span></p></body></html>"))
        self.markDzone.setText(_translate("MainWindow", "Mark D region"))
        self.markRzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star ‘reappears’, then click this button to create an R search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If no points are selected, a search for an R transition will not be performed --- this becomes a \'D only\' event.</span></p></body></html>"))
        self.markRzone.setText(_translate("MainWindow", "Mark R region"))
        self.markEzone.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is only active when a Night Eagle 3 analysis is being performed.</p><p>The Night Eagle 3 has an effective noise reduction system that has the side effect of producing an exponential decay of intensity toward the ultimate event intensity level during a D transition. As a result, only a portion of the points in the event bottom are reliable indicators of the correct event intensity. This effect is visually obvious for the DNR:HIGH setting, much less so for the DNR:MIDDLE setting, and hard to detect at the DNR:LOW setting.</p><p>Usage is simple: click on two points that enclose the desired points to use for event parameter estimation (mean and noise), then click this button.</p><p>Clicking this button with no points selected will clear any previous selections.</p></body></html>"))
        self.markEzone.setText(_translate("MainWindow", "mark Event points to use"))
        self.doBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Light curves from integrated videos must be block integrated before further processing is carried out.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">An automatic determination of the correct block size and starting point (offset) will be performed if no points have been selected.&nbsp;You will have the opportunity to accept or reject the result of this automatic process using the button to the right (</span><span style=\" font-family:\'arial,sans-serif\'; font-weight:600; color:#fc0107;\">Accept auto integration</span><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">).</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If a manual selection is necessary,&nbsp;then the procedure stated below can be performed:</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Zoom into a small portion of the light curve and locate a clearly identifiable group of data points that belong to an integration block,&nbsp;click on the first and last point of that data point group,&nbsp;then press this button to integrate all such groups in the light curve into a single data points.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">&nbsp;A block integration,&nbsp;either manual or automatic,&nbsp;can be performed only once per data file;&nbsp;it cannnot be undone by use of the </span><span style=\" font-family:\'arial,sans-serif\'; font-weight:600; color:#fc0107;\">Start over</span><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\"> button.&nbsp;Instead,&nbsp;you will need to re-read the file.</span></p></body></html>"))
        self.doBlockIntegration.setText(_translate("MainWindow", "Manual/automatic block integrate"))
        self.acceptBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button will be enabled only after pyote has proposed a block integration. If, after examining the proposed block size and offset shown on the light curve, you wish to apply the integration, press this button.</p></body></html>"))
        self.acceptBlockIntegration.setText(_translate("MainWindow", "Accept auto block integration"))
        self.setDataLimits.setToolTip(_translate("MainWindow", "<html><head/><body><p>If exactly two data points have been selected, this button will <span style=\" font-weight:600; text-decoration: underline;\">trim</span> off (exclude) data points to the left and right of the selected points. The excluded points will shown in light gray.</p><p>If no points have been selected, then all data points will be selected as the default.</p><p>Once a trim has been performed, its effects can be removed by clicking on the <span style=\" font-weight:600; color:#fc0107;\">Start over</span> button.</p></body></html>"))
        self.setDataLimits.setText(_translate("MainWindow", "Trim left/right"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.analysisTab), _translate("MainWindow", "Analysis"))
        self.underlyingLightcurveLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This group of edit boxes allows the parameters for an observation-appropriate \'underlying lightcurve\' to be entered.</p><p>We define the \'underlying lightcurve\' thusly: it is the theoretical intensity of the light diffracted at the occulting edge (assumed straight) as a function of time, i.e. as the shadow of the occulting body passes the observation position, and includes the effect of a possibly finite star disk.  Click the <span style=\" font-weight:600; color:#fc0107;\">Demo</span> button to get a preview of this underlying lightcurve to make sure that the parameters are reasonable and, <span style=\" color:#fc0107;\">most importantly, have been entered without error</span> because these values will be used once a \'solution\' has been found.</p><p>Diffraction intensity has a wavelength dependence. In PyOTE, we compute a generic diffraction curve composed of light wavelengths in the 400nm to 600nm range (using 5 nm steps) with equal intensities at each included wavelength. The region of the diffraction curve that is of most interest to us is only about +/- 1 Fresnel unit on either side of the geometrical shadow point. Fortunately, in that region, there is very little difference between a narrow band of light wavelengths and a wide band of light wavelengths, so there is no practical need to specify a more realistic bandpass in terms of either shape (amplitudes) or extent (bandpass). The primary effect of a wide bandpass is to greatly reduce the oscillations seen in a single wavelength diffraction curve (i.e., the one that is most frequently used to show diffraction effects).</p><p>If the star has a finite disk, the effect on the underlying lightcurve is usually very significant and apparent, \'integrating\' away most of the characteristic diffraction curve shape and moving toward what is often referred to as a penumbral shape. It also moves the value of the intensity at the geometrical shadow point from 25% of full scale up to something close to 50% of full scale.</p><p>If you leave the exposure duration (exp dur: edit box) empty, the result of clicking the <span style=\" font-weight:600; color:#fc0107;\">Demo</span> button will be a display of the underlying light curve shape. To see the effect of the camera exposure time, which integrates the underlying light curve to produce what we refer to as the camera response, fill in the effective exposure time, taking into account the observation frame rate and number of frames being integrated. Note: this field will be updated/filled in automatically when an observation with timing data is loaded and, if necessary, integrated.</p><p>If a <span style=\" font-weight:600; color:#fc0107;\">Demo</span> is run before \'solution\' baseline and event intensities have been determined, generic values of 100.0 (baseline intensity) and 0.0 (event intensity) are used. If \'real\' baseline and event intensities are available, they are used instead.</p></body></html>"))
        self.underlyingLightcurveLabel.setText(_translate("MainWindow", "Set these parameters to calculate diffraction, star disk, and centerline offset effects for the observation."))
        self.exposureTimeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the effective camera exposure time (shutter time) in seconds, taking into account camera integration of frames if that was employed in this observation.</p><p>This box will normally be filled automatically when a file is read that has timing information included.</p><p>The value in this box will also be updated whenever and integration operation changes the frame duration.</p></body></html>"))
        self.exposureTimeLabel.setText(_translate("MainWindow", "  exposure:"))
        self.asteroidDistanceLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the distance to the asteroid/occulting body.</p><p>For distance units, use AU (Astronomical units)</p><p>Note: If parallax (in arc seconds) to the asteroid is available instead of distance in AU, the distance to the asteroid can be calculated with the equation:</p><p align=\"center\"><span style=\" font-size:18pt; font-weight:600;\">distance(AU) = 8.7882 / parallax(arc seconds)</span></p></body></html>"))
        self.asteroidDistanceLabel.setText(_translate("MainWindow", "  asteroid dist(AU):"))
        self.shadowSpeedLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the speed of the occulting body in kilometers per second.</p><p>This is used as the speed of the occultation shadow projected on the earth.</p><p>This value is used to convert the diffraction pattern, which is calculated as a function of Fresnel units, to a function of time.</p><p>If the asteroid speed is not given but its diameter and the maximum expected event duration is known, the asteroid speed can be calculated with this equation:</p><p align=\"center\"><span style=\" font-size:18pt; font-weight:600;\">asteroid speed (km/sec) = asteroid diameter(km) / max duration(seconds)</span></p></body></html>"))
        self.shadowSpeedLabel.setText(_translate("MainWindow", "  asteroid speed(km/sec):"))
        self.asteroidSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>In order to calculate the effect on the underlying diffraction lightcurve of an observation that is not on the centerline of the asteroid track (a \'graze\'), two pieces of information are required:</p><p>1) The asteroid diameter (expressed in km) (enter in this edit box)</p><p>2) The distance (in km) left or right of the asteroid track centerline of the observation position</p></body></html>"))
        self.asteroidSizeLabel.setText(_translate("MainWindow", " asteroid diameter(km):"))
        self.pathOffsetLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>In order to calculate the effect on the underlying diffraction lightcurve of an observation that is not on the centerline of the asteroid track (a \'graze\'), two pieces of information are required:</p><p>1) The asteroid diameter (expressed in km)</p><p>2) The distance (in km) left or right of the asteroid track centerline of the observation position (enter in this edit box)</p></body></html>"))
        self.pathOffsetLabel.setText(_translate("MainWindow", " observation centerline offset(km):"))
        self.starDiameterLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the star being occulted is not point-like but rather has a finite disk, enter its diameter in milli-arcseconds (mas) in this box.</p><p>This value is used, in conjunction with the values entered in the <span style=\" font-weight:600; color:#fc0107;\">dist(AU)</span> box and the <span style=\" font-weight:600; color:#fc0107;\">speed(km/sec)</span> box, to calculate the apparent size of the star at the asteroid distance as a function of time. This is convolved with the diffraction light curve to get the underlying light curve (instantaneous values).</p><p>The underlying lightcurve is what is seen and integrated during the camera exposure time to get the camera response.</p></body></html>"))
        self.starDiameterLabel.setText(_translate("MainWindow", "Star diam(mas):"))
        self.dLimbAngleLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>When the star has a perceptible disk, the angle of the asteroid limb with respect to the direction of motion changes the time duration during which the projected star image passes your observation position and therefore modifies the underlying light curve at that limb edge.</p><p>Angles are entered in degrees with 90 degrees used to reflect a head-on no-graze configuration.</p></body></html>"))
        self.dLimbAngleLabel.setText(_translate("MainWindow", "      D limb angle:"))
        self.rLimbAngleLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>When the star has a perceptible disk, the angle of the asteroid limb with respect to the direction of motion changes the time duration during which the projected star image passes your observation position and therefore modifies the underlying light curve at that limb edge.</p><p>Angles are entered in degrees with 90 degrees used to reflect a head-on no-graze configuration.</p></body></html>"))
        self.rLimbAngleLabel.setText(_translate("MainWindow", "      R limb angle:"))
        self.demoUnderlyingLighturvesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button demonstrates the computation of the lightcurve used in determining the time of the geometric shadow edge, given the observation parameters set in the edit boxes in this edit box group. It can be a useful tool in gaining an understanding of diffraction (and other) effects.</p><p>If values have been entered in the two boxes to the right (asteroid distance, and speed), the 400nm to 600nm bandpass integrated analytic diffraction lightcurve will be computed and displayed.</p><p>We refer to this as the \'underlying lightcurve\': it is the theoretical (instantaneous) intensity of the light diffracted at the occulting edge as a function of time, i.e. as the shadow of the occulting body passes an observation position that is <span style=\" text-decoration: underline;\">on the path centerline</span>.</p><p>The \'underlying lightcurve\' will be further modified by:</p><p>1. the camera exposure function (which acts as an integrator)</p><p>2. the position of observation with respect to the asteroid path centerline (because of the 2D nature of the diffracted asteroid image)</p><p>3. a target star that has a discernible disk</p><p>The instantaneous underlying lightcurve (with correction for an off-centerline observation) is modified by the camera exposure function and, if the star has a discernible disk, the star intensity function. The resulting composite lightcurve is mathematically the convolution of the underlying lightcurve with the camera exposure function and possibly the star intensity function.</p><p>(Technically a convolution is defined as the integral of the product of two functions after one is reversed and shifted - the integral is evaluated for all values of shift to produce the modified function.)</p><p><span style=\" font-family:\'Helvetica\';\">The camera exposure function is defined as equal to 1.0 while the ‘shutter’ is open, and 0.0 at all other times. (A \'boxcar\' integration)</span></p><p><span style=\" font-family:\'Helvetica\';\">The star intensity function is the chord length across the diameter of the star.</span></p><p>These two functions are plotted on the demonstration graph (at half intensity to avoid overlap with the baseline) so that one can see the functions that are being convolved and to make it easy to see how much of an effect should be expected.</p><p>Diffraction intensity has a wavelength dependence. In PyOTE, we compute a generic diffraction curve composed of light wavelengths in the 400nm to 600nm range (using 5 nm steps) with equal intensities at each included wavelength. The region of the diffraction curve that is of most interest to us is only about +/- 1 Fresnel unit on either side of the geometrical shadow point. Fortunately, in that region, there is very little difference between a narrow band of light wavelengths and a wide band of light wavelengths, so there is no practical need to specify a more realistic bandpass in terms of either shape (amplitudes) or extent (bandpass). The primary effect of a wide bandpass is to greatly reduce the oscillations seen in a single wavelength diffraction curve (i.e., the one that is most frequently used to show diffraction effects).</p><p>If the star has a finite disk, the effect on the underlying lightcurve is usually very significant and apparent, \'integrating\' away most of the characteristic diffraction curve shape and moving toward what is often referred to as a penumbral shape. It also moves the value of the intensity at the geometrical shadow point from up to something close to 50% of full scale.</p><p>If you leave the exposure duration (exp dur: edit box) empty, the result of clicking this button will be a display of the underlying light curve shape. To see the effect of the camera exposure time, which integrates the underlying light curve to produce what we refer to as the camera response, fill in the effective exposure time, taking into account the observation frame rate and number of frames being integrated. Note: this field will be updated/filled in automatically when an observation with timing data is loaded and, if necessary, integrated.</p><p>If this demo is run before \'solution\' baseline and event intensities have been determined, generic values of 100.0 (baseline intensity) and 0.0 (event intensity) are used. If \'real\' baseline and event intensities are available, they are used instead.</p></body></html>"))
        self.demoUnderlyingLighturvesButton.setText(_translate("MainWindow", "Demo (show theoretical light curve)"))
        self.enableDiffractionCalculationBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This checkbox enables the application of diffraction effects to the underlying lightcurve. Usually, you will want to use diffraction effects for the underlying lightcurve, so this box is checked by default.</p><p>But sometimes you may want to use a pure penumbral curve when the star has a finite disk. In that case, uncheck this box.</p><p>This is also useful as learning/demonstration tool when exploring what effects the underlying lightcurve.</p></body></html>"))
        self.enableDiffractionCalculationBox.setText(_translate("MainWindow", "use diffraction in solution "))
        self.penumbralFitCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If an occultation involves a star that is not point-like (has a detectable disk), the observation lightcurve will often have a gradual transition and take more than one or two readings for the disappearance and/or reappearance to occur. To extract timing data from such an observation, an underlying lightcurve model that incorporates star diameter (mas) and limb angles must be used.</p><p><span style=\" font-weight:600;\">This checkbox will be enabled whenever a star diameter is entered below AND the </span><span style=\" font-weight:600; color:#fc0107;\">Demo</span><span style=\" font-weight:600;\"> button has been clicked. You WILL forget this; it happens to me. No worries; nothing breaks. Just right-click and refresh your memory!</span></p><p><span style=\" font-weight:600; color:#0000ff;\">Please use the example-penumbra.csv file that is provided in the download for practice.</span> (This file may be hard to find as it is placed wherever your system stores the PyOTE application files. Best advice is to do a search of the entire drive for the exact file name, then copy it to a more convenient place.) The header lines in that file give you good values to use for asteroid distance, asteroid speed, and star diameter to start with. Find the supplied file with a file-search --- <span style=\" font-weight:600; color:#fc0107;\">move it somewhere else to play with - don\'t clutter up your software installation directory with the PyOTE files that are generated during normal processing - nothing bad will happen if you fail to heed this advice, but it\'s good practice to follow this advice.</span></p><p>Once this checkbox is checked (and you will forget to do this sometimes too!), the <span style=\" font-weight:600; color:#fc0107;\">Find event, then ...</span> button will invoke the \'penumbral fit\' methodology. When the \'penumbral fit\' methodology is active, the user is expected to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1.</span> Carefully locate the D and or R regions so that the penumbral transition regions are precisely enclosed. Use the <span style=\" font-weight:600; color:#fc0107;\">Mark D region</span> button and the <span style=\" font-weight:600; color:#fc0107;\">Mark R region</span> button in the usual way.</p><p>This allows PyOTE to identify/assume the points to the left and right of the D and/or R regions are baseline points so as to compute a correct baseline intensity and its associated noise. This also allows the points between the D and/or R regions to be used for the computation of the correct event intensity and its associated noise.</p><p><span style=\" font-weight:600; color:#fc0107;\">2.</span> Repeatedly click the <span style=\" font-weight:600; color:#fc0107;\">Find event, then ...</span> button, evalute the \'fit\' visually, and change the limb angles until satisfied (watch the \'metric\' to see how you are doing), then</p><p><span style=\" font-weight:600; color:#fc0107;\">3.</span> Click the <span style=\" font-weight:600; color:#fc0107;\">... write report</span> button, as usual.</p><p>The D and/or R edge times will not change significantly during the step 2 iterations; they are only performed to get an estimate of the D and/or R limb angles, so a good visual fit should be adequate.</p><p>It is a characteristic of penumbral curves that they are \'under-constrained\' in that there is NOT a unique set of values for star diameter and the two limb angles. It is <span style=\" text-decoration: underline;\">always</span> the case that, given a star diameter and limb angles of 90 degrees (head-on), there is a smaller star diameter with smaller limb angles that will result in exactly the same lightcurve. Usually, the star diameter will be reasonably well known, so that value is held fixed while one adjusts the D and R limb angles until a satisfactory fit is found.</p></body></html>"))
        self.penumbralFitCheckBox.setText(_translate("MainWindow", "Penumbral fit   "))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.diffractionTab), _translate("MainWindow", "Diffraction"))
        self.calcFlashEdge.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button calculates the fractional frame number at which the start of a timing flash occurred.</p><p>Click a point on either side of the R event (leading edge) of a timing flash, then click the <span style=\" font-weight:600; color:#fc0107;\">Calc flash edge</span> button (this one). Start with the earliest edge, then repeat the procedure on the second edge (if present --- it is highly recommended to use goal-post flashes that bracket the event).</p><p>Next, click the <span style=\" color:#fc0107;\">M</span><span style=\" font-weight:600; color:#fc0107;\">anual timestamp entry</span> button to bring up a dialog for entering manual timestamp data. The calculated frame values for the edges will be automatically pre-filled in the form. You only need enter the corresponding flash time values from the flash app log and click <span style=\" font-weight:600; color:#fc0107;\">Ok </span><span style=\" color:#000000;\">to trigger timestamp calculations for all points</span>.</p><p><br/></p></body></html>"))
        self.calcFlashEdge.setText(_translate("MainWindow", "Calc flash edge"))
        self.manualTimestampCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This checkbox makes the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Manual timestamp entry</span><span style=\" font-size:18pt;\"> button active. You will need/use that button when processing a light curve that employs \'flash timing\' instead of a VTI.</span></p><p><span style=\" font-size:18pt;\">Manual entry of timestamp information is also useful if there </span><span style=\" font-size:18pt; font-weight:600; text-decoration: underline;\">are</span><span style=\" font-size:18pt;\"> timestamps, but manual entry of timing information is required because of major errors in those timestamps.</span></p><p><span style=\" font-size:18pt;\">NOTE: timestamps are ALWAYS treated as start-of-exposure times.</span></p></body></html>"))
        self.manualTimestampCheckBox.setText(_translate("MainWindow", "Enable manual timestamp entry"))
        self.manualEntryPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button causes a dialog to appear in which timestamp information may be entered. This is needed if \'flash timing\' is being utilized.</p><p>It is also useful when OCR of a VTI overlay has a high error rate, but enough entries have been properly read that \'goal post\' timing (use of two times that bracket the event to provide the timing information by interpolation) can be used.</p><p>NOTE: timestamps are ALWAYS treated as start-of-exposure times.</p></body></html>"))
        self.manualEntryPushButton.setText(_translate("MainWindow", "Manual timestamp entry"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_9), _translate("MainWindow", "Manual timestamps"))
        self.viewFrameButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to view a frame from the video that was used by PyMovie or Limovie to prepare the csv file that is currently being analyzed. Currently .avi and .ser files are viewable in this manner as well as .fits files inside a FITS folder.</p><p>If this button is disabled, it is because the csv file did not come from PyMovie or Limovie or simply cannot be found/opened.</p><p>This feature can/should be used as a final quality control check for a video that contains timestamps extracted using OCR. It is possible for OCR to fail in manner that is <span style=\" font-weight:600; color:#fc0107;\">not detected</span> by PyOTE because the program only verifies that there is a consistent step (delata time) between frames. If a high order digit has been consistently misread, like reading an 8 as a 9 in the minutes field, the steps can be consistent but the reported time of the event will be wrong.</p><p>ALL time reporting is derived from the single timestamp(s) associated with D and/or R (the integer values, not the sub-frame values). If those timestamps are correct, the reported times will be correct even when there may be a few missing or duplicated frames and all other timestamps are wrong. So, best practice is to enter the D frame value in the spin box and visually confirm that the timestamp that you can see is the same as that extracted by the OCR procedure. Repeat for R.</p><p>Another use for this feature is to handle the case where there is a visual timestamp that can be seen in the video, but either OCR was not activated during the .csv preparation, or the timestamp overlay came from an unsupported VTI type. The workflow in this case is to let PyOTE find the D and R values, but before doing <span style=\" font-weight:600; color:#fc0107;\">... write report</span>, do a <span style=\" font-weight:600; color:#fc0107;\">Manual timestamp entry</span> for the D and R values found by viewing the relevant frames and entering the correct times in the Manual timestamp dialog.</p><p>Note that timestamps can be entered manually even if timestamps are already present in the file. The manual timestamps will be calculated and used to replace those already there.</p></body></html>"))
        self.viewFrameButton.setText(_translate("MainWindow", "View frame from associated video"))
        self.frameNumSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spin box (which may be directly edited) to select the number of the frame/image you want to see.</p><p>The upper limit and lower limits for allowed numbers in this spin box are set when the csv is read, which sometimes only contains a subset of the frames available in the video.  If your \'edit\' is refused, it is because you are trying to enter a number outside the range allowed, which is always restricted to frame numbers that actually appear in the csv file.</p></body></html>"))
        self.label.setText(_translate("MainWindow", "Check any of the following boxes you wish to be active during the analysis."))
        self.label_2.setText(_translate("MainWindow", "Use View Frame to import a video image of a specific frame number."))
        self.fieldViewCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>For videos from a composite video camera, check this box to view the frame as two fields.</p></body></html>"))
        self.fieldViewCheckBox.setText(_translate("MainWindow", "field view"))
        self.flipYaxisCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Checking this box will rotate/flip the image around the horizontal axis. (Flips top to bottom.)</p></body></html>"))
        self.flipYaxisCheckBox.setText(_translate("MainWindow", "flip top/bottom"))
        self.flipXaxisCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Check this box if you need to rotate/flip the image around the vertical axis. (Flip left to right.)</p></body></html>"))
        self.flipXaxisCheckBox.setText(_translate("MainWindow", "flip left/right"))
        self.label_3.setText(_translate("MainWindow", "Use the check boxes to change the view of the imported video image."))
        self.showTimestampErrors.setToolTip(_translate("MainWindow", "<html><head/><body><p>Timestamp errors are indicated by red lines that show where a time step is not within +/- 10% of the expected value.</p><p>Sometimes there are so many red lines that is becomes hard to see the plot. In that case, uncheck this box to suppress the red line display.</p></body></html>"))
        self.showTimestampErrors.setText(_translate("MainWindow", "time err "))
        self.showUnderlyingLightcurveCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you want to see the underlying lightcurve (the instantaneous theoretical lightcurve that the camera \'sees\'), set this box to \'checked\'.</p><p>The solution plot gets a bit cluttered when the camera response curve, the \'solution\', and the underlying lightcurve are all being displayed at once.</p></body></html>"))
        self.showUnderlyingLightcurveCheckBox.setText(_translate("MainWindow", "raw light"))
        self.showErrBarsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you do not want to see the vertical dashed lines that show the 95% containment interval error bars for D and/or R, uncheck this box.</p></body></html>"))
        self.showErrBarsCheckBox.setText(_translate("MainWindow", "err bars"))
        self.showEdgesCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you do not want to see the D and/or R edges marked with a vertical dashed line on the \'solution\', uncheck this box.</p></body></html>"))
        self.showEdgesCheckBox.setText(_translate("MainWindow", "edges"))
        self.showOCRcheckFramesCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Uncheck this box if you do not need to see the D and/or R frames from the video automatically displayed to verify that timestamp OCR was correct.</p><p><span style=\" font-weight:600; color:#0000ff;\">Background:</span> if the video that produced the csv being analyzed is still in its original location, PyOTE will access that video whenever an event has been found and the critical frames that determine the reported times will be displayed. The timing data used for the report is displayed in the title of each displayed frame, allowing a user to visually confirm that the OCR timestamp extraction was correct.</p><p>NOTE: timestamps are ALWAY treated as start-of-exposure times.</p></body></html>"))
        self.showOCRcheckFramesCheckBox.setText(_translate("MainWindow", "Do OCR check"))
        self.showTimestampsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you want frame numbers used on the x-xaxis,&nbsp;uncheck this box.&nbsp;Otherwise,&nbsp;if timestamps are available,&nbsp;they will be used to annotate the x-axis.</p></body></html>"))
        self.showTimestampsCheckBox.setText(_translate("MainWindow", "timestamps"))
        self.label_4.setText(_translate("MainWindow", "Set the width of the error bars and light curve lines in the light curve plot."))
        self.lineWidthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spinner sets the line width (in pixels) of the error bar lines, the geometric edge lines, and the lightcurve lines.  Adjust this to show these lines according to your taste and the resolution of your screen.</p></body></html>"))
        self.lineWidthLabel.setText(_translate("MainWindow", "line width"))
        self.label_7.setText(_translate("MainWindow", "... signal (background subtracted)  appsum (no background subtraction) ..."))
        self.label_6.setText(_translate("MainWindow", "If the file is from PyMovie, you can select the kind of data to analyze ..."))
        self.label_5.setText(_translate("MainWindow", "PyMovie data column prefix"))
        self.label_8.setText(_translate("MainWindow", "... avgbkg (background value)  stdbkg (noise in background)  nmaskpx (pixel count in mask)"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.settingsTab), _translate("MainWindow", "Settings/Misc."))
        self.detectabilityHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The primary use of this tool is to perform a \'detectability\' estimate. That estimate can be used to decide whether to attempt a future occultation observation or, alternatively, to analyze an actual occultation observation to decide whether to report a <span style=\" color:#fc0107;\">\'miss\'</span> or a <span style=\" color:#fc0107;\">\'no observation\'</span>.</p><p>Assuming PyOTE could not find an event in an actual occultation observation and this tool says the event was undetectable, report a <span style=\" color:#fc0107;\">\'no observation\'</span> but if this tool says that the expected event was detectable, then report a <span style=\" color:#fc0107;\">\'miss\'</span>.</p><p>This tool is also useful with observations that have employed a \'GPS Flasher\' to provide timing for the video observation. A side effect of having an LED light up at the entrance of your telescope is that it will affect the baseline values of the target star (and others) and so make it more difficult to extract the best possible baseline statistics (mean and noise-sigma and noise-correlation-coefficients) which benefit from having more points involved in the calculation. This tool allows the user to tell PyOTE where the baseline values are reliable enough(unaffected by flashes, or wind gusts, or telescope jostling, etc) to be used during baseline statistics calculation.</p><p>By repeatedly selecting pairs of points on the light curve being analyzed and clicking the <span style=\" font-weight:600; color:#0000ff;\">Mark baseline region</span> button, the regions of \'reliable baseline/event data\' can be designated. They will be shown as orangish points instead of the normal blue color.</p><p><span style=\" font-weight:600; color:#0000ff;\">NOTE:</span> Regions marked on one curve are automatically applied to all curves. </p><p>In general, normalization against a reference star should be performed first, then this operation. That will remove any \'trends\' that would affect the mean and noise-sigma.</p><p><span style=\" font-weight:600; color:#0000ff;\">FYI:</span> One can also use this feature to calculate statistics on some set of points of interest (like a statistics in the event bottom) or for reference stars or ...</p></body></html>"))
        self.detectabilityHelpButton.setText(_translate("MainWindow", "Help"))
        self.markBaselineRegionButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click on pairs of points that enclose points that are valid to use for noise (and mean value) calculations. This can be repeated to select disjoint sets of valid points.</p></body></html>"))
        self.markBaselineRegionButton.setText(_translate("MainWindow", "Mark baseline region"))
        self.clearBaselineRegionsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clear all marked regions and any statistics that may have been extracted by clicking on this button: <span style=\" font-weight:600; color:#0000ff;\">Calc baseline mean/sigma/corr coeffs</span></p></body></html>"))
        self.clearBaselineRegionsButton.setText(_translate("MainWindow", "Clear baseline regions"))
        self.calcStatsFromBaselineRegionsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this button is clicked, all the points included in the marked regions will be collected and used to calculate the baseline/event mean, noise-sigma, and the noise-correlation coefficients. Unless a \'trim\' is performed, these values will be used during error bar estimations and \'false-positive\' estimation.</p><p><span style=\" font-weight:600; color:#0000ff;\">NOTE:</span> If a \'trim\' is performed, <span style=\" font-weight:600;\">the baseline mean will be determined from the \'fit\' to the trimmed data,</span> but the noise-sigma and noise-correlation coefficients extracted from the marked \'background\' regions will continue to override those obtained from the trimmed light-curve.</p><p>This is done so that if the mean baseline level on either side of the event appears to be a little different than the overall baseline, one can get improved baseline noise stats by using points from the entire light-curve, yet trim the light-curve around the event and allow the \'finder/fitter\' to calculate a baseline mean from the immediately adjacent points.</p></body></html>"))
        self.calcStatsFromBaselineRegionsButton.setText(_translate("MainWindow", "Calc baseline mean/sigma/corr coeffs"))
        self.obsDurLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the length of the observation (in seconds).</p></body></html>"))
        self.obsDurLabel.setText(_translate("MainWindow", "ObservationDur(secs):"))
        self.eventDurLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the expected duration of the event in seconds (a duration of 1.5 times the predicted duration is recommended). </p></body></html>"))
        self.eventDurLabel.setText(_translate("MainWindow", "EventDur(secs):"))
        self.durStepLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If this box contains 0 or is empty, a single detectability calculation and plot will be made.</p><p>If a non-zero entry is made in this edit box, a series of detectability calculations and plots will be made at ever shorter durations until the false-positive probability of the event becomes non-zero.</p><p>The units here are seconds.</p></body></html>"))
        self.durStepLabel.setText(_translate("MainWindow", "  duration step"))
        self.detectMagDropLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the expected magDrop as a positive number.</p></body></html>"))
        self.detectMagDropLabel.setText(_translate("MainWindow", "  magDrop:"))
        self.calcDetectabilityButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button activates a special version of the False-Positive calculator to help determine whether an occultation observation planned for the near future is detectable given the star signal available from the observation location, the expected duration of the event, and the expected magDrop of the event. </p><p>Or, if you are analyzing an actual occultation observation, this tool will help you in deciding whether to report a <span style=\" color:#fc0107;\">\'miss\'</span> or a <span style=\" color:#fc0107;\">\'no observation\'</span> if an event was not found. Assuming PyOTE could not find an event in the occultation observation being analyzed and this tool says the event was undetectable, report a <span style=\" color:#fc0107;\">\'no observation\'</span><span style=\" color:#000000;\">,</span> but if this tool says that the expected event was detectable, then report a <span style=\" color:#fc0107;\">\'miss\'</span>.</p><p><span style=\" color:#fc0107;\">Please keep in mind that this is a simulation using random numbers, so repeated calculations with the same duration and magDrop will naturally give slightly different answers.</span></p><p>The workflow is as follows:</p><p>1. Make a video of the target star with at least a few hundred frames. The video needs to be long enough and under the anticipated observation conditions and camera settings to be used during the actual event so that a valid estimate of the expected intensity of the target star, the noise level, and the correlation coefficients of that noise during the actual event can be obtained.</p><p>2. Use PyMovie (or Tangra or LiMovie) to extract a light-curve from the video.</p><p>3. Read the light-curve into PyOTE, then click on pairs of points in the light-curve plot to designate those points that should be used for the needed intensity and noise calculations. Click the <span style=\" font-weight:600; color:#0000ff;\">Mark Baseline Region</span> button to record your selection. This step can be repeated multiple times to select disjoint sets of points.</p><p>4. Now click the <span style=\" font-weight:600; color:#0000ff;\">Calc baseline mean/sigma/corr coefs</span> button - this is what triggers the extraction of the needed intensity and noise data, a pre-requisite to performing the next step:<span style=\" font-weight:600; color:#0000ff;\"> Calc detectability</span>.</p><p>5. Before clicking the <span style=\" font-weight:600; color:#0000ff;\">Calc detectability</span> button, you must fill in the observation duration (<span style=\" font-weight:600; color:#0000ff;\">ObservationDur</span>) in seconds and the expected duration of the event (<span style=\" font-weight:600; color:#0000ff;\">EventDur</span>) in seconds.</p><p>6. If you want the calculator to iteratively find the smallest duration of a detectable event for you, set <span style=\" font-weight:600; color:#0000ff;\">duration step</span> to a non-zero value (in seconds).</p><p>6. Next, fill in the expected <span style=\" font-weight:600; color:#0000ff;\">magDrop</span> (a positive number).</p><p>7. Click the<span style=\" font-weight:600; color:#0000ff;\"> Calc detectability</span> button and, after a pause while 50,000 trial observations are computed, a False-Positive plot will appear. The position of the red vertical line relative to the black line tells the detectability story: if the red line is to right of the black line, the event has a high probabilty of being detected - if the red line is to the left of the black line it has a lower probability of detection, with that probablity decreasing as the red line moves more and more to the left of the black line. </p><p>If the event (possibly a minimum event duration discovered during a search) was found to be detectable, a sample light-curve is displayed that shows an example observation with such an event included.</p><p>If the result was no detectable event, a False-Positive plot will be shown instead of the first duration that failed (red bar to left of black bar).</p><p><br/></p></body></html>"))
        self.calcDetectabilityButton.setText(_translate("MainWindow", "Calc detectability"))
        self.writeExampleLightcurveCheckBox.setText(_translate("MainWindow", "Write example lightcurve to csv file"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_8), _translate("MainWindow", "Noise analysis/Detectability"))
        self.ne3ExplanationButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The Night Eagle 3 is a <span style=\" color:#fc0107;\">rolling shutter CMOS camera</span>. As a result, with this camera, the timing of an occultation depends on which row the occulted star is at when the occultation occurs. PyOTE will automatically calculate the needed time correction from the y (row) position that you enter in the spin/entry box at the bottom of this tab.</p><p>For the Night Eagle 3, times extracted by PyOTE require only a VTI correction (if you use an IOTA VTI, there is no correction at all needed).</p><p>Note: if the recording was <span style=\" font-weight:600;\">not</span> made with a tracking telescope (so the target star is moving across the image), you will need to watch the video and record the row of the occultation for use in this program. Normally, with a tracking telescope, you will be able to use the y position of the \'target\' aperture directly. PyMovie includes this information in the comment lines of the csv file.</p><p>The Night Eagle 3 has a very effective noise reduction system called DNR (Dynamic Noise Reduction). There are 4 levels of noise reduction and you will need to indicate on this tab page what DNR setting your recording was made with.</p><p>The noise reduction is not without a small cost, however - the edges of an occultation light-curve will no longer be a step change. Instead, the edges will follow an exponential curve, approaching maximum and minimum intensities asymptotically. PyOTE has the ability to fit such an exponential curve to the D and R transitions, so the time resolution will be restored during the least squares fit of a \'theoretical\' exponential transition curve and you should feel free to use whatever level of noise reduction you may need. It is recommended that you run your NE3 at a gamma of 0.75 (1.0 gamma is not available) AND that you use PyMovie to linearize the recording (i.e., invert the 0.75 gamma curve of the camera).</p><p>The D and R exponential curves each have their own time constant, measured in frames, that control the frame rate of exponential curve growth. The default values provided are usually enough to allow a good fit to be found. <span style=\" color:#fc0107;\">PyOTE uses those values as the starting point for a least-squares search for better values. This usually works well, but it is possible that a starting value is too far from the correct value and the least-squares refinement process will find a local minimum that is visually wrong. In that case, you should change the starting value to something closer to \'correct\' and let the \'solver\' try again.</span></p><p>When the exponential curve fit algorithm is in use, the light-curve plot PyOTE displays will be changed. Gone is the blue \'camera response\' curve, replaced by brown dotted \'theoretical\' exponential edge curves that you can use to judge for yourself the goodness of a \'fit\'.</p><p><span style=\" color:#0000ff;\">You will probably want to use the most aggressive noise reduction in most cases, but make sure that your expected event duration is long enough that the D transition exponential curve has time to settle to the bottom event plus some time to allow a good determination of the event bottom intensity. At DNR:HIGH, your expected event time should be greater than 30 frames (1 second) to use this setting. I suggest the following rules-of-thumb: </span><span style=\" color:#fc0107;\">can use DNR:HIGH for events 2 seconds and longer; can use DNR:MIDDLE for events 1 second and longer; can use DNR:LOW for events 0.5 seconds and longer</span><span style=\" color:#0000ff;\">.</span></p></body></html>"))
        self.ne3ExplanationButton.setText(_translate("MainWindow", "Night Eagle 3  (explanation and help)"))
        self.ne3NotInUseRadioButton.setText(_translate("MainWindow", "Night Eagle 3 not in use"))
        self.dnrOffRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3, operating with a DNR setting of OFF does no noise reduction and there is no exponential transition zone for step changes of light. So, unlike the other DNR settings, there is no need for \'edge\' time constant values.</p></body></html>"))
        self.dnrOffRadioButton.setText(_translate("MainWindow", "DNR: Off"))
        self.dnrLowRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3 operating with an active DNR setting (i.e., other than OFF) reduces noise but also creates a light-curve that has exponential transitions (i.e., an asymptotic approach to the ultimate event or baseline intensity) at D and R edges in response to a step change in light. PyOTE will fit a \'theoretical\' exponential curve to the light-curve using a least-squares fit of the \'theoretical\' edge. This procedure utilizes the timing information that has been \'smeared\' across the transition region in such a way that timing resolution is restored.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: TC stands for time constant. It is measured in frames.</span></p><p><span style=\" color:#000000;\">The shape of the \'theoretical\' transition is governed by the time constant used at each edge. The TC values in the spin/entry boxes to the right give PyOTE starting values to use in a least-squares driven search for better TC values that will produce transition curves that better fit the observed values.</span></p><p><span style=\" color:#000000;\">It is possible that the starting TC value is too far from the \'correct\' values and the least-squares search routine, as a consequence, finds a local minimum that produces a visibly incorrect fit. In this case, change the starting value to something closer to \'correct\' and try again.</span></p></body></html>"))
        self.dnrLowRadioButton.setText(_translate("MainWindow", "DNR: Low"))
        self.dnrLowDtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrLowDtcLabel.setText(_translate("MainWindow", "TC:D edge"))
        self.dnrLowDspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrLowRtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrLowRtcLabel.setText(_translate("MainWindow", "TC:R edge"))
        self.dnrLowRspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3 operating with an active DNR setting (i.e., other than OFF) reduces noise but also creates a light-curve that has exponential transitions (i.e., an asymptotic approach to the ultimate event or baseline intensity) at D and R edges in response to a step change in light. PyOTE will fit a \'theoretical\' exponential curve to the light-curve using a least-squares fit of the \'theoretical\' edge. This procedure utilizes the timing information that has been \'smeared\' across the transition region in such a way that timing resolution is restored.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: TC stands for time constant. It is measured in frames.</span></p><p><span style=\" color:#000000;\">The shape of the \'theoretical\' transition is governed by the time constant used at each edge. The TC values in the spin/entry boxes to the right give PyOTE starting values to use in a least-squares driven search for better TC values that will produce transition curves that better fit the observed values.</span></p><p><span style=\" color:#000000;\">It is possible that the starting TC value is too far from the \'correct\' values and the least-squares search routine, as a consequence, finds a local minimum that produces a visibly incorrect fit. In this case, change the starting value to something closer to \'correct\' and try again.</span></p></body></html>"))
        self.dnrMiddleRadioButton.setText(_translate("MainWindow", "DNR: Middle"))
        self.dnrMiddleDtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleDtcLabel.setText(_translate("MainWindow", "TC:D edge"))
        self.dnrMiddleDspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleRtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleRtcLabel.setText(_translate("MainWindow", "TC:R edge"))
        self.dnrMiddleRspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3 operating with an active DNR setting (i.e., other than OFF) reduces noise but also creates a light-curve that has exponential transitions (i.e., an asymptotic approach to the ultimate event or baseline intensity) at D and R edges in response to a step change in light. PyOTE will fit a \'theoretical\' exponential curve to the light-curve using a least-squares fit of the \'theoretical\' edge. This procedure utilizes the timing information that has been \'smeared\' across the transition region in such a way that timing resolution is restored.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: TC stands for time constant. It is measured in frames.</span></p><p><span style=\" color:#000000;\">The shape of the \'theoretical\' transition is governed by the time constant used at each edge. The TC values in the spin/entry boxes to the right give PyOTE starting values to use in a least-squares driven search for better TC values that will produce transition curves that better fit the observed values.</span></p><p><span style=\" color:#000000;\">It is possible that the starting TC value is too far from the \'correct\' values and the least-squares search routine, as a consequence, finds a local minimum that produces a visibly incorrect fit. In this case, change the starting value to something closer to \'correct\' and try again.</span></p></body></html>"))
        self.dnrHighRadioButton.setText(_translate("MainWindow", "DNR: High"))
        self.dnrHighDtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighDtcLabel.setText(_translate("MainWindow", "TC:D edge"))
        self.dnrHighDspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighRtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighRtcLabel.setText(_translate("MainWindow", "TC:R edge"))
        self.dnrHighRspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.yPositionLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spin/entry box to enter the image row the target star was on when the occultation occured.</p><p>The Night Eagle 3 is a rolling shutter CMOS camera. As a result, with this camera, the timing of an occultation depends on which row the occulted star is at when the occultation occurs. PyOTE will automatically calculate the needed time correction from the y (row) position that you enter in this box.</p><p>For the Night Eagle 3, times extracted by PyOTE require only a VTI correction (if you use an IOTA VTI, there is no correction at all needed).</p><p>Note: if the recording was <span style=\" font-weight:600;\">not</span> made with a tracking telescope (so the targer star is moving across the image), you will need to watch the video and record the row of the occultation for use in this program. Normally, with a tracking telescope, you will be able to use the y position of the \'target\' aperture directly. PyMovie includes this information in the comment lines of the csv file.</p></body></html>"))
        self.yPositionLabel.setText(_translate("MainWindow", "y position of target star"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Night Eagle 3"))
        self.helpLabelForDataGrid.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking at the left-edge of a data line will cause the corresponding data point in the main display to be highlighted. Only one such point can be high-lighted at a time.</p><p>Clicking a point in the main data plot will cause this data grid to be positioned at that data point with the row shown in red. Clicking anywhere in this row will \'toggle\' the selection of that point, useful when the main data plot is very dense.</p></body></html>"))
        self.helpLabelForDataGrid.setText(_translate("MainWindow", "Right-click this label to get explanation of data grid below:"))
        self.table.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">The data displayed in this table is read from the input file. The Timestamp column in this table will be filled in in response to a successful Manual Timestamp Entry procedure. The results of smoothing and normalization are NOT reflected in this table. The results of a Block Integration ARE reflected in this table.  This policy allows this table to be used as the source when a user requests that a csv file be written, presumably to capture timestamps filled in by Manual Timestamp Entry and a possible Block Integration, thus speeding future re-analysis efforts.</span></p><p><span style=\" font-size:18pt;\">Clicking on a data row (at the extreme left) in this panel will cause the corresponding point to be highlighted in the light curve plot. The highlighted point is shown as a largish yellow dot with a red rim --- it may be hard to see/find, but look for it.</span></p><p><span style=\" font-size:18pt; font-weight:600;\">Clicking on a data cell in a row will select/deselect that point in the primary (dark blue) light curve plot. This is provided as an alternative method to clicking on points in the main light curve plot to select/deslect them.</span></p><p><span style=\" font-size:18pt;\">Note: Clicking on a point in the primary (dark blue) light curve will cause the data row for that point to be selected/positioned.</span></p></body></html>"))
from pyqtgraph import PlotWidget

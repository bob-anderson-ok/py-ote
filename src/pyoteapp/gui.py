# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'simple_plot2.ui'
#
# Created by: PyQt5 UI code generator 5.9.2
#
# WARNING! All changes made in this file will be lost!

from PyQt5 import QtCore, QtGui, QtWidgets

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1392, 960)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.splitter_2 = QtWidgets.QSplitter(self.centralwidget)
        self.splitter_2.setOrientation(QtCore.Qt.Vertical)
        self.splitter_2.setObjectName("splitter_2")
        self.layoutWidget = QtWidgets.QWidget(self.splitter_2)
        self.layoutWidget.setObjectName("layoutWidget")
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout(self.layoutWidget)
        self.horizontalLayout_12.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_11.addItem(spacerItem)
        self.manualTimestampCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.manualTimestampCheckBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.manualTimestampCheckBox.setObjectName("manualTimestampCheckBox")
        self.horizontalLayout_11.addWidget(self.manualTimestampCheckBox)
        self.manualEntryPushButton = QtWidgets.QPushButton(self.layoutWidget)
        self.manualEntryPushButton.setEnabled(False)
        self.manualEntryPushButton.setObjectName("manualEntryPushButton")
        self.horizontalLayout_11.addWidget(self.manualEntryPushButton)
        self.verticalLayout.addLayout(self.horizontalLayout_11)
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.infoButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.infoButton.sizePolicy().hasHeightForWidth())
        self.infoButton.setSizePolicy(sizePolicy)
        self.infoButton.setAutoDefault(False)
        self.infoButton.setObjectName("infoButton")
        self.gridLayout.addWidget(self.infoButton, 0, 0, 1, 1)
        self.readData = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.readData.sizePolicy().hasHeightForWidth())
        self.readData.setSizePolicy(sizePolicy)
        self.readData.setToolTipDuration(-1)
        self.readData.setObjectName("readData")
        self.gridLayout.addWidget(self.readData, 0, 1, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.lightCurveNumberLabel = QtWidgets.QLabel(self.layoutWidget)
        self.lightCurveNumberLabel.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lightCurveNumberLabel.sizePolicy().hasHeightForWidth())
        self.lightCurveNumberLabel.setSizePolicy(sizePolicy)
        self.lightCurveNumberLabel.setObjectName("lightCurveNumberLabel")
        self.horizontalLayout_7.addWidget(self.lightCurveNumberLabel)
        self.curveToAnalyzeSpinBox = QtWidgets.QSpinBox(self.layoutWidget)
        self.curveToAnalyzeSpinBox.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.curveToAnalyzeSpinBox.sizePolicy().hasHeightForWidth())
        self.curveToAnalyzeSpinBox.setSizePolicy(sizePolicy)
        self.curveToAnalyzeSpinBox.setMinimum(1)
        self.curveToAnalyzeSpinBox.setMaximum(4)
        self.curveToAnalyzeSpinBox.setObjectName("curveToAnalyzeSpinBox")
        self.horizontalLayout_7.addWidget(self.curveToAnalyzeSpinBox)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_7.addItem(spacerItem1)
        self.verticalLayout.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.showSecondaryCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showSecondaryCheckBox.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.showSecondaryCheckBox.sizePolicy().hasHeightForWidth())
        self.showSecondaryCheckBox.setSizePolicy(sizePolicy)
        self.showSecondaryCheckBox.setMaximumSize(QtCore.QSize(307, 16777215))
        self.showSecondaryCheckBox.setObjectName("showSecondaryCheckBox")
        self.horizontalLayout_6.addWidget(self.showSecondaryCheckBox)
        self.secondarySelector = QtWidgets.QSpinBox(self.layoutWidget)
        self.secondarySelector.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.secondarySelector.sizePolicy().hasHeightForWidth())
        self.secondarySelector.setSizePolicy(sizePolicy)
        self.secondarySelector.setMinimum(1)
        self.secondarySelector.setMaximum(4)
        self.secondarySelector.setObjectName("secondarySelector")
        self.horizontalLayout_6.addWidget(self.secondarySelector)
        self.normLabel = QtWidgets.QLabel(self.layoutWidget)
        self.normLabel.setEnabled(False)
        self.normLabel.setObjectName("normLabel")
        self.horizontalLayout_6.addWidget(self.normLabel)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem2)
        self.verticalLayout.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.showTimestampErrors = QtWidgets.QCheckBox(self.layoutWidget)
        self.showTimestampErrors.setEnabled(False)
        self.showTimestampErrors.setObjectName("showTimestampErrors")
        self.horizontalLayout_10.addWidget(self.showTimestampErrors)
        self.enableTooltipsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.enableTooltipsCheckBox.setChecked(True)
        self.enableTooltipsCheckBox.setObjectName("enableTooltipsCheckBox")
        self.horizontalLayout_10.addWidget(self.enableTooltipsCheckBox)
        self.verticalLayout.addLayout(self.horizontalLayout_10)
        self.gridLayout_2 = QtWidgets.QGridLayout()
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.doBlockIntegration = QtWidgets.QPushButton(self.layoutWidget)
        self.doBlockIntegration.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.doBlockIntegration.sizePolicy().hasHeightForWidth())
        self.doBlockIntegration.setSizePolicy(sizePolicy)
        self.doBlockIntegration.setObjectName("doBlockIntegration")
        self.gridLayout_2.addWidget(self.doBlockIntegration, 0, 0, 1, 1)
        self.acceptBlockIntegration = QtWidgets.QPushButton(self.layoutWidget)
        self.acceptBlockIntegration.setEnabled(False)
        self.acceptBlockIntegration.setObjectName("acceptBlockIntegration")
        self.gridLayout_2.addWidget(self.acceptBlockIntegration, 0, 1, 1, 1)
        self.setDataLimits = QtWidgets.QPushButton(self.layoutWidget)
        self.setDataLimits.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.setDataLimits.sizePolicy().hasHeightForWidth())
        self.setDataLimits.setSizePolicy(sizePolicy)
        self.setDataLimits.setToolTipDuration(-1)
        self.setDataLimits.setObjectName("setDataLimits")
        self.gridLayout_2.addWidget(self.setDataLimits, 0, 2, 1, 1)
        self.verticalLayout.addLayout(self.gridLayout_2)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.smoothSecondaryButton = QtWidgets.QPushButton(self.layoutWidget)
        self.smoothSecondaryButton.setEnabled(False)
        self.smoothSecondaryButton.setObjectName("smoothSecondaryButton")
        self.horizontalLayout_5.addWidget(self.smoothSecondaryButton)
        self.numSmoothPointsEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.numSmoothPointsEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.numSmoothPointsEdit.sizePolicy().hasHeightForWidth())
        self.numSmoothPointsEdit.setSizePolicy(sizePolicy)
        self.numSmoothPointsEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.numSmoothPointsEdit.setFrame(True)
        self.numSmoothPointsEdit.setObjectName("numSmoothPointsEdit")
        self.horizontalLayout_5.addWidget(self.numSmoothPointsEdit)
        self.verticalLayout.addLayout(self.horizontalLayout_5)
        self.normalizeButton = QtWidgets.QPushButton(self.layoutWidget)
        self.normalizeButton.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.normalizeButton.sizePolicy().hasHeightForWidth())
        self.normalizeButton.setSizePolicy(sizePolicy)
        self.normalizeButton.setObjectName("normalizeButton")
        self.verticalLayout.addWidget(self.normalizeButton)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.markDzone = QtWidgets.QPushButton(self.layoutWidget)
        self.markDzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markDzone.sizePolicy().hasHeightForWidth())
        self.markDzone.setSizePolicy(sizePolicy)
        self.markDzone.setObjectName("markDzone")
        self.horizontalLayout_2.addWidget(self.markDzone)
        self.markRzone = QtWidgets.QPushButton(self.layoutWidget)
        self.markRzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markRzone.sizePolicy().hasHeightForWidth())
        self.markRzone.setSizePolicy(sizePolicy)
        self.markRzone.setObjectName("markRzone")
        self.horizontalLayout_2.addWidget(self.markRzone)
        self.calcFlashEdge = QtWidgets.QPushButton(self.layoutWidget)
        self.calcFlashEdge.setEnabled(False)
        self.calcFlashEdge.setObjectName("calcFlashEdge")
        self.horizontalLayout_2.addWidget(self.calcFlashEdge)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.minEventLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventLabel.sizePolicy().hasHeightForWidth())
        self.minEventLabel.setSizePolicy(sizePolicy)
        self.minEventLabel.setMinimumSize(QtCore.QSize(50, 0))
        self.minEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.minEventLabel.setObjectName("minEventLabel")
        self.horizontalLayout_3.addWidget(self.minEventLabel)
        self.minEventEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.minEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventEdit.sizePolicy().hasHeightForWidth())
        self.minEventEdit.setSizePolicy(sizePolicy)
        self.minEventEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.minEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.minEventEdit.setObjectName("minEventEdit")
        self.horizontalLayout_3.addWidget(self.minEventEdit)
        self.maxEventLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventLabel.sizePolicy().hasHeightForWidth())
        self.maxEventLabel.setSizePolicy(sizePolicy)
        self.maxEventLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.maxEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.maxEventLabel.setObjectName("maxEventLabel")
        self.horizontalLayout_3.addWidget(self.maxEventLabel)
        self.maxEventEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.maxEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventEdit.sizePolicy().hasHeightForWidth())
        self.maxEventEdit.setSizePolicy(sizePolicy)
        self.maxEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.maxEventEdit.setObjectName("maxEventEdit")
        self.horizontalLayout_3.addWidget(self.maxEventEdit)
        self.verticalLayout.addLayout(self.horizontalLayout_3)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setContentsMargins(12, -1, 0, -1)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.DandR = QtWidgets.QRadioButton(self.layoutWidget)
        self.DandR.setChecked(True)
        self.DandR.setObjectName("DandR")
        self.horizontalLayout.addWidget(self.DandR)
        self.Donly = QtWidgets.QRadioButton(self.layoutWidget)
        self.Donly.setObjectName("Donly")
        self.horizontalLayout.addWidget(self.Donly)
        self.Ronly = QtWidgets.QRadioButton(self.layoutWidget)
        self.Ronly.setObjectName("Ronly")
        self.horizontalLayout.addWidget(self.Ronly)
        self.verticalLayout.addLayout(self.horizontalLayout)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.locateEvent = QtWidgets.QPushButton(self.layoutWidget)
        self.locateEvent.setEnabled(False)
        self.locateEvent.setObjectName("locateEvent")
        self.horizontalLayout_4.addWidget(self.locateEvent)
        self.calcErrBars = QtWidgets.QPushButton(self.layoutWidget)
        self.calcErrBars.setEnabled(False)
        self.calcErrBars.setObjectName("calcErrBars")
        self.horizontalLayout_4.addWidget(self.calcErrBars)
        self.verticalLayout.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.progressBar = QtWidgets.QProgressBar(self.layoutWidget)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        self.horizontalLayout_8.addWidget(self.progressBar)
        self.cancelButton = QtWidgets.QPushButton(self.layoutWidget)
        self.cancelButton.setObjectName("cancelButton")
        self.horizontalLayout_8.addWidget(self.cancelButton)
        self.horizontalLayout_8.setStretch(0, 1)
        self.verticalLayout.addLayout(self.horizontalLayout_8)
        spacerItem3 = QtWidgets.QSpacerItem(452, 13, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout.addItem(spacerItem3)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.writePlot = QtWidgets.QPushButton(self.layoutWidget)
        self.writePlot.setEnabled(False)
        self.writePlot.setObjectName("writePlot")
        self.horizontalLayout_9.addWidget(self.writePlot)
        self.writeBarPlots = QtWidgets.QPushButton(self.layoutWidget)
        self.writeBarPlots.setEnabled(False)
        self.writeBarPlots.setObjectName("writeBarPlots")
        self.horizontalLayout_9.addWidget(self.writeBarPlots)
        self.writeCSVButton = QtWidgets.QPushButton(self.layoutWidget)
        self.writeCSVButton.setEnabled(False)
        self.writeCSVButton.setObjectName("writeCSVButton")
        self.horizontalLayout_9.addWidget(self.writeCSVButton)
        self.verticalLayout.addLayout(self.horizontalLayout_9)
        self.startOver = QtWidgets.QPushButton(self.layoutWidget)
        self.startOver.setEnabled(False)
        self.startOver.setObjectName("startOver")
        self.verticalLayout.addWidget(self.startOver)
        self.horizontalLayout_12.addLayout(self.verticalLayout)
        self.mainPlot = PlotWidget(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.mainPlot.sizePolicy().hasHeightForWidth())
        self.mainPlot.setSizePolicy(sizePolicy)
        self.mainPlot.setMinimumSize(QtCore.QSize(800, 0))
        self.mainPlot.viewport().setProperty("cursor", QtGui.QCursor(QtCore.Qt.IBeamCursor))
        self.mainPlot.setObjectName("mainPlot")
        self.horizontalLayout_12.addWidget(self.mainPlot)
        self.splitter = QtWidgets.QSplitter(self.splitter_2)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.table = QtWidgets.QTableWidget(self.splitter)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.table.sizePolicy().hasHeightForWidth())
        self.table.setSizePolicy(sizePolicy)
        self.table.setMinimumSize(QtCore.QSize(0, 0))
        self.table.setToolTipDuration(4000)
        self.table.setRowCount(11)
        self.table.setColumnCount(4)
        self.table.setObjectName("table")
        self.textOut = QtWidgets.QTextEdit(self.splitter)
        self.textOut.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.textOut.setUndoRedoEnabled(False)
        self.textOut.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        self.textOut.setReadOnly(True)
        self.textOut.setObjectName("textOut")
        self.gridLayout_3.addWidget(self.splitter_2, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "PY-OTE"))
        self.manualTimestampCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This checkbox makes the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Manual timestamp entry</span><span style=\" font-size:18pt;\"> button active. You will need/use that button when processing a light curve that employs \'flash timing\' instead of a VTI.</span></p><p><span style=\" font-size:18pt;\">Manual entry of timestamp information is also useful if there </span><span style=\" font-size:18pt; font-weight:600; text-decoration: underline;\">are</span><span style=\" font-size:18pt;\"> timestamps, but manual entry of timing information is required because of major errors in those timestamps.</span></p></body></html>"))
        self.manualTimestampCheckBox.setText(_translate("MainWindow", "Enable manual timestamp entry"))
        self.manualEntryPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This button causes a dialog to appear in which timestamp information may be entered. This is needed if \'flash timing\' is being utilized.</span></p><p><span style=\" font-size:18pt;\"/></p><p><span style=\" font-size:18pt;\">It is also useful when OCR of a VTI overlay has a high error rate, but enough entries have been properly read that \'goal post\' timing (use of two times that bracket the event to provide the timing information by interpolation) can be used.</span></p></body></html>"))
        self.manualEntryPushButton.setText(_translate("MainWindow", "Manual timestamp entry"))
        self.infoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Click this button to to open the </span><span style=\" font-size:18pt; color:#ff0000;\">help.pdf</span><span style=\" font-size:18pt;\"> file that is included in the installation.  The file will open in whatever PDF viewer you have assigned as the default viewer for pdf files.</span></p></body></html>"))
        self.infoButton.setWhatsThis(_translate("MainWindow", "How does this show up?"))
        self.infoButton.setText(_translate("MainWindow", "Info"))
        self.readData.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:14pt;\">PYOTE reads Limovie, R-OTE, and Tangra files and includes up to four light curves.</span></p><p><span style=\" font-size:14pt;\">Normally (but not required) object1 is the occulted star; other (optional) objects are reference stars to be used for normalizing the occulted star light curve or flash curves from an LED timer.</span></p><p><span style=\" font-size:14pt; font-weight:600; text-decoration: underline; color:#0000ff;\">Mouse button functions within the light curve plot:</span></p><p><span style=\" font-size:14pt; font-weight:600; color:#ff0000;\">Left click</span><span style=\" font-size:14pt;\">: selects/deselects points on the primary (dark blue) light curve that intersect with the vertical hairline (the mouse cursor is disabled).</span></p><p><span style=\" font-size:14pt; font-weight:600; color:#ff0000;\">Left click and drag</span><span style=\" font-size:14pt;\">: rectangular zoom is available to more clearly see points for selection (but point selection can also be accomplished through clicks in the tabular data display at the lower left)</span></p><p><span style=\" font-size:14pt; font-weight:600;\">Note! The shift key will toggle the mouse cursor on/off in the light curve plot.</span><span style=\" font-size:14pt;\"> This enables the starting corner for the zoom to be seen. (But points cannot be selected/deselected while the mouse cursor is visible. A right click will always \'blank\' the mouse cursor.) </span></p><p><span style=\" font-size:14pt; font-weight:600; color:#ff0000;\">Right click</span><span style=\" font-size:14pt;\">: undo zoom</span></p><p><span style=\" font-size:14pt; color:#996633;\">Timestamp errors are shown with vertical red hairlines when a file is first read. These will disappear after the first point is selected so that the working view is as clear as possible. The red hairlines will re-appear permanently after the error bars have been calculated and the final report written to the log.</span></p></body></html>"))
        self.readData.setText(_translate("MainWindow", "Read light curve"))
        self.lightCurveNumberLabel.setText(_translate("MainWindow", "Light curve number to analyze (blue):"))
        self.curveToAnalyzeSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Use this spinner to select which light curve to analyze for an occultation event or as a source for \'flash timing\' edges.</span></p></body></html>"))
        self.showSecondaryCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">The display of the secondary star can be turned on and off with this checkbox. This is useful if the secondary star trace overlaps the main star. The secondary star data remains available for smoothing and normalization, even if it is not being displayed.</span></p></body></html>"))
        self.showSecondaryCheckBox.setText(_translate("MainWindow", "Use curve"))
        self.secondarySelector.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">If there are multiple reference stars in the file, this spinner will activate to allow the choice of which one to display/use.</span></p></body></html>"))
        self.normLabel.setText(_translate("MainWindow", "for normalization (green)"))
        self.showTimestampErrors.setText(_translate("MainWindow", "Show timestamp errors"))
        self.enableTooltipsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Hovering the mouse pointer over a button/control will cause a \'help dialog\' to appear. These dialogs are instructive and are an important part of the documentation for this program.</span></p><p><span style=\" font-size:18pt;\">Once a user has become familiar with what the buttons and widgets do, these \'tips\' popping up will become a nuisance. This checkbox can be used to stop these dialogs from unwanted appearances.</span></p></body></html>"))
        self.enableTooltipsCheckBox.setText(_translate("MainWindow", "Enable Tooltips"))
        self.doBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">Light curves from integrated videos must be block integrated before further processing is carried out.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">An automatic determination of the correct block size and starting point (offset) will be performed if no points have been selected. You will have the opportunity to accept or reject the result of this automatic process using the button to the right (</span><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; font-weight:600; color:#fc0107;\">Accept integration</span><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">).</span></p><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">If a manual selection is necessary, then the procedure stated below can be performed:</span></p><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">Zoom into a small portion of the light curve and locate a clearly identifiable group of data points that belong to an integration block, click on the first and last point of that data point group, then press this button to integrate all such groups in the light curve into a single data points.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">A block integration, either manual or automatic, can be performed only once per data file; it cannnot be undone by use of the </span><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; font-weight:600; color:#fc0107;\">Start over</span><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\"> button. Instead, you will need to re-read the file.</span></p></body></html>"))
        self.doBlockIntegration.setText(_translate("MainWindow", "Block integrate"))
        self.acceptBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This button will be enabled only after pyote has proposed a block integration. If, after examining the proposed block size and offset shown on the light curve, you wish to apply the integration, press this button.</span></p></body></html>"))
        self.acceptBlockIntegration.setText(_translate("MainWindow", "Accept Integration"))
        self.setDataLimits.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">If exactly two data points have been selected, this button will </span><span style=\" font-size:18pt; font-weight:600; text-decoration: underline;\">trim</span><span style=\" font-size:18pt;\"> off (exclude) data points to the left and right of the selected points. The excluded points will shown in light gray.</span></p><p><span style=\" font-size:18pt;\">If no points have been selected, then all data points will be selected as the default.</span></p><p><span style=\" font-size:18pt;\">Once a trim has been performed, its effects can be removed by clicking on the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Start over</span><span style=\" font-size:18pt;\"> button.</span></p></body></html>"))
        self.setDataLimits.setText(_translate("MainWindow", "Trim left/right"))
        self.smoothSecondaryButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Smooth the selected secondary (reference) star light curve using a Savitsky-Golay filter with a default window of 101 points (the edit box to the right allows for this value to be changed) and a degree 3 interpolating polynomial, applied twice.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">The secondary star does not have to be visible for this smoothing to take place.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">Smoothing of the secondary curve is a prerequisite to normalizing the occulted star light curve.</span></p></body></html>"))
        self.smoothSecondaryButton.setText(_translate("MainWindow", "Smooth secondary"))
        self.numSmoothPointsEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This edit box allows you to change the number of points used in Savitsky-Golay filter during smoothing of the secondary star. The window size should be an odd number in the range of 5 up to the number of data points in the secondary curve.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">If an even number is specified, the window size used will be one less than that number.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">Pressing </span><span style=\" font-size:18pt; font-weight:600; color:#ff0000;\">tab</span><span style=\" font-size:18pt;\"> or </span><span style=\" font-size:18pt; font-weight:600; color:#ff0000;\">return</span><span style=\" font-size:18pt;\"> at completion of data entry will trigger the smoothing, or you can click on the Smooth secondary button</span></p></body></html>"))
        self.numSmoothPointsEdit.setText(_translate("MainWindow", "101"))
        self.normalizeButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">If a smoothed secondary (reference) curve is available, and a single point has been selected on the curve to be normalized, the selected light curve will be \'normalized\' against the reference star. This can be useful in removing light curve distortions caused by clouds or similat light changes.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">This done by creating a \'gain curve\' from the smoothed reference curve. The \'gain\' is unity at the selected point and proportionally larger/smaller at all the other points.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">This \'gain curve\' is then multiplied point by point against the curve being analyzed to produce the \'normalized\' version of that light curve.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">Normalization is a one-time-only procedure in that its effects can </span><span style=\" font-size:18pt; font-weight:600;\">not</span><span style=\" font-size:18pt;\"> be removed by use of the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Start over</span><span style=\" font-size:18pt;\"> button.</span></p></body></html>"))
        self.normalizeButton.setText(_translate("MainWindow", "Normalize around selected point"))
        self.markDzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star ‘disappears’, then click this button to create a D search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">If no points are selected, a search for a D transition will not be performed --- this becomes an \'R only\' event.</span></p></body></html>"))
        self.markDzone.setText(_translate("MainWindow", "Mark D region"))
        self.markRzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star ‘reappears’, then click this button to create an R search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; font-size:18pt; color:#222222;\">If no points are selected, a search for an R transition will not be performed --- this becomes a \'D only\' event.</span></p></body></html>"))
        self.markRzone.setText(_translate("MainWindow", "Mark R region"))
        self.calcFlashEdge.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This button calculates the fractional frame number at which the start of a timing flash occurred.</span></p><p><span style=\" font-size:18pt;\">Click a point on either side of the R event (leading edge) of a timing flash, then click the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Calc flash edge</span><span style=\" font-size:18pt;\"> button (this one). Start with the earliest edge, then repeat the procedure on the second edge (if present --- it is highly recommended to use goal-post flashes that bracket the event).</span></p><p><span style=\" font-size:18pt;\">Next, click the </span><span style=\" font-size:18pt; color:#fc0107;\">M</span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">anual timestamp entry</span><span style=\" font-size:18pt;\"> button to bring up a dialog for entering manual timestamp data. The calculated frame values for the edges will be automatically pre-filled in the form. You only need enter the corresponding flash time values from the flash app log and click </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Ok </span><span style=\" font-size:18pt; color:#000000;\">to trigger timestamp calculations for all points</span><span style=\" font-size:18pt;\">.</span></p><p><br/></p></body></html>"))
        self.calcFlashEdge.setText(_translate("MainWindow", "Calc flash edge"))
        self.minEventLabel.setText(_translate("MainWindow", "min event:"))
        self.minEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Enter smallest event size (in number of readings) to search for.</span></p></body></html>"))
        self.maxEventLabel.setText(_translate("MainWindow", "max event:"))
        self.maxEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Enter largest event size (in number of readings) to search for.</span></p></body></html>"))
        self.DandR.setText(_translate("MainWindow", "D:R"))
        self.Donly.setText(_translate("MainWindow", "D"))
        self.Ronly.setText(_translate("MainWindow", "R"))
        self.locateEvent.setText(_translate("MainWindow", "Find event, then ..."))
        self.calcErrBars.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">To get a \'Final Report\', error bars are required.  Clicking this button will start the computation of those error bars and, when complete, trigger the preparation of a \'Final Report\'</span></p></body></html>"))
        self.calcErrBars.setText(_translate("MainWindow", "... write report"))
        self.cancelButton.setText(_translate("MainWindow", "Cancel"))
        self.writePlot.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Note: At the conclusion of error bar calculations, PYOTE automatically writes the main plot to a png file using the name and directory of the just-processed csv file. </span></p><p><span style=\" font-size:18pt;\">If you want/need to record other versions of that plot, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.</span><br/></p></body></html>"))
        self.writePlot.setText(_translate("MainWindow", "Write main plot"))
        self.writeBarPlots.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Note: At the conclusion of error bar calculations, PYOTE automatically writes the error bar plots to appropriately named png files using the name and directory of the just-processed csv file. </span></p><p><span style=\" font-size:18pt;\">If you want/need to record other versions of those plots, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.</span></p></body></html>"))
        self.writeBarPlots.setText(_translate("MainWindow", "Write error bar plot"))
        self.writeCSVButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">Use this button to write the contents of the data table below to a csv file.</span></p><p><span style=\" font-size:18pt;\">The comment lines from the original input file are preserved.</span></p><p><span style=\" font-size:18pt;\">The most common use for this function is to capture the result of a successful Manual Timestamp Entry for later use (without the need to again go through the manual timestamp entry procedure). It will also reflect any Block Integration that was applied.</span></p></body></html>"))
        self.writeCSVButton.setText(_translate("MainWindow", "Write csv file"))
        self.startOver.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This button removes any trim that is in effect, clears a solution that may have been found, removes a smoothed reference curve, and removes any D or R region that is showing.</span></p><p><br/></p><p><span style=\" font-size:18pt;\">It does </span><span style=\" font-size:18pt; font-weight:600; font-style:italic; color:#fc0107;\">not</span><span style=\" font-size:18pt;\"> undo block integration or light curve normalization -- you must reload the light curve file to recover from those procedures.</span></p></body></html>"))
        self.startOver.setText(_translate("MainWindow", "Start over"))
        self.table.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">The data displayed in this table is read from the input file. The Timestamp column in this table will be filled in in response to a successful Manual Timestamp Entry procedure. The results of smoothing and normalization are NOT reflected in this table. The results of a Block Integration ARE reflected in this table.  This policy allows this table to be used as the source when a user requests that a csv file be written, presumably to capture timestamps filled in by Manual Timestamp Entry and a possible Block Integration, thus speeding future re-analysis efforts.</span></p><p><span style=\" font-size:18pt;\">Clicking on a data row (at the extreme left) in this panel will cause the corresponding point to be highlighted in the light curve plot. The highlighted point is shown as a largish yellow dot with a red rim --- it may be hard to see/find, but look for it.</span></p><p><span style=\" font-size:18pt; font-weight:600;\">Clicking on a data cell in a row will select/deselect that point in the primary (dark blue) light curve plot. This is provided as an alternative method to clicking on points in the main light curve plot to select/deslect them.</span></p><p><span style=\" font-size:18pt;\">Note: Clicking on a point in the primary (dark blue) light curve will cause the data row for that point to be selected/positioned.</span></p></body></html>"))

from pyqtgraph import PlotWidget

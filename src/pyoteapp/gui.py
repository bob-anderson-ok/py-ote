# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'simple_plot2.ui'
#
# Created by: PyQt5 UI code generator 5.14.0
#
# WARNING! All changes made in this file will be lost!


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(4095, 1156)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_3.setObjectName("gridLayout_3")
        self.splitter_3 = QtWidgets.QSplitter(self.centralwidget)
        self.splitter_3.setOrientation(QtCore.Qt.Vertical)
        self.splitter_3.setObjectName("splitter_3")
        self.splitter_2 = QtWidgets.QSplitter(self.splitter_3)
        self.splitter_2.setOrientation(QtCore.Qt.Horizontal)
        self.splitter_2.setObjectName("splitter_2")
        self.layoutWidget = QtWidgets.QWidget(self.splitter_2)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_11.addItem(spacerItem)
        self.manualTimestampCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.manualTimestampCheckBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.manualTimestampCheckBox.setObjectName("manualTimestampCheckBox")
        self.horizontalLayout_11.addWidget(self.manualTimestampCheckBox)
        self.manualEntryPushButton = QtWidgets.QPushButton(self.layoutWidget)
        self.manualEntryPushButton.setEnabled(False)
        self.manualEntryPushButton.setObjectName("manualEntryPushButton")
        self.horizontalLayout_11.addWidget(self.manualEntryPushButton)
        self.verticalLayout_2.addLayout(self.horizontalLayout_11)
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.infoButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.infoButton.sizePolicy().hasHeightForWidth())
        self.infoButton.setSizePolicy(sizePolicy)
        self.infoButton.setAutoDefault(False)
        self.infoButton.setObjectName("infoButton")
        self.gridLayout.addWidget(self.infoButton, 0, 0, 1, 1)
        self.readData = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.readData.sizePolicy().hasHeightForWidth())
        self.readData.setSizePolicy(sizePolicy)
        self.readData.setToolTipDuration(-1)
        self.readData.setObjectName("readData")
        self.gridLayout.addWidget(self.readData, 0, 3, 1, 1)
        self.helpButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.helpButton.sizePolicy().hasHeightForWidth())
        self.helpButton.setSizePolicy(sizePolicy)
        self.helpButton.setObjectName("helpButton")
        self.gridLayout.addWidget(self.helpButton, 0, 1, 1, 1)
        self.tutorialButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tutorialButton.sizePolicy().hasHeightForWidth())
        self.tutorialButton.setSizePolicy(sizePolicy)
        self.tutorialButton.setObjectName("tutorialButton")
        self.gridLayout.addWidget(self.tutorialButton, 0, 2, 1, 1)
        self.verticalLayout_2.addLayout(self.gridLayout)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.lightCurveNumberLabel = QtWidgets.QLabel(self.layoutWidget)
        self.lightCurveNumberLabel.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lightCurveNumberLabel.sizePolicy().hasHeightForWidth())
        self.lightCurveNumberLabel.setSizePolicy(sizePolicy)
        self.lightCurveNumberLabel.setObjectName("lightCurveNumberLabel")
        self.horizontalLayout_7.addWidget(self.lightCurveNumberLabel)
        self.curveToAnalyzeSpinBox = QtWidgets.QSpinBox(self.layoutWidget)
        self.curveToAnalyzeSpinBox.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.curveToAnalyzeSpinBox.sizePolicy().hasHeightForWidth())
        self.curveToAnalyzeSpinBox.setSizePolicy(sizePolicy)
        self.curveToAnalyzeSpinBox.setMinimum(1)
        self.curveToAnalyzeSpinBox.setMaximum(4)
        self.curveToAnalyzeSpinBox.setObjectName("curveToAnalyzeSpinBox")
        self.horizontalLayout_7.addWidget(self.curveToAnalyzeSpinBox)
        self.lightCurveNameEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.lightCurveNameEdit.setReadOnly(True)
        self.lightCurveNameEdit.setObjectName("lightCurveNameEdit")
        self.horizontalLayout_7.addWidget(self.lightCurveNameEdit)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_7.addItem(spacerItem1)
        self.lineWidthLabel = QtWidgets.QLabel(self.layoutWidget)
        self.lineWidthLabel.setObjectName("lineWidthLabel")
        self.horizontalLayout_7.addWidget(self.lineWidthLabel)
        self.lineWidthSpinner = QtWidgets.QSpinBox(self.layoutWidget)
        self.lineWidthSpinner.setMinimum(1)
        self.lineWidthSpinner.setMaximum(9)
        self.lineWidthSpinner.setProperty("value", 2)
        self.lineWidthSpinner.setObjectName("lineWidthSpinner")
        self.horizontalLayout_7.addWidget(self.lineWidthSpinner)
        self.verticalLayout_2.addLayout(self.horizontalLayout_7)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.showSecondaryCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showSecondaryCheckBox.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.showSecondaryCheckBox.sizePolicy().hasHeightForWidth())
        self.showSecondaryCheckBox.setSizePolicy(sizePolicy)
        self.showSecondaryCheckBox.setMaximumSize(QtCore.QSize(307, 16777215))
        self.showSecondaryCheckBox.setObjectName("showSecondaryCheckBox")
        self.horizontalLayout_6.addWidget(self.showSecondaryCheckBox)
        self.secondarySelector = QtWidgets.QSpinBox(self.layoutWidget)
        self.secondarySelector.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.secondarySelector.sizePolicy().hasHeightForWidth())
        self.secondarySelector.setSizePolicy(sizePolicy)
        self.secondarySelector.setMinimum(1)
        self.secondarySelector.setMaximum(4)
        self.secondarySelector.setObjectName("secondarySelector")
        self.horizontalLayout_6.addWidget(self.secondarySelector)
        self.normLabel = QtWidgets.QLabel(self.layoutWidget)
        self.normLabel.setEnabled(False)
        self.normLabel.setObjectName("normLabel")
        self.horizontalLayout_6.addWidget(self.normLabel)
        self.helpLabelForFalsePositive = QtWidgets.QLabel(self.layoutWidget)
        self.helpLabelForFalsePositive.setEnabled(False)
        self.helpLabelForFalsePositive.setText("")
        self.helpLabelForFalsePositive.setObjectName("helpLabelForFalsePositive")
        self.horizontalLayout_6.addWidget(self.helpLabelForFalsePositive)
        spacerItem2 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_6.addItem(spacerItem2)
        self.plotHelpButton = QtWidgets.QPushButton(self.layoutWidget)
        self.plotHelpButton.setObjectName("plotHelpButton")
        self.horizontalLayout_6.addWidget(self.plotHelpButton)
        self.verticalLayout_2.addLayout(self.horizontalLayout_6)
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        self.showTimestampErrors = QtWidgets.QCheckBox(self.layoutWidget)
        self.showTimestampErrors.setEnabled(False)
        self.showTimestampErrors.setObjectName("showTimestampErrors")
        self.horizontalLayout_10.addWidget(self.showTimestampErrors)
        self.showUnderlyingLightcurveCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showUnderlyingLightcurveCheckBox.setObjectName("showUnderlyingLightcurveCheckBox")
        self.horizontalLayout_10.addWidget(self.showUnderlyingLightcurveCheckBox)
        self.showErrBarsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showErrBarsCheckBox.setChecked(True)
        self.showErrBarsCheckBox.setObjectName("showErrBarsCheckBox")
        self.horizontalLayout_10.addWidget(self.showErrBarsCheckBox)
        self.showEdgesCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showEdgesCheckBox.setChecked(True)
        self.showEdgesCheckBox.setObjectName("showEdgesCheckBox")
        self.horizontalLayout_10.addWidget(self.showEdgesCheckBox)
        self.showOCRcheckFramesCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showOCRcheckFramesCheckBox.setChecked(True)
        self.showOCRcheckFramesCheckBox.setObjectName("showOCRcheckFramesCheckBox")
        self.horizontalLayout_10.addWidget(self.showOCRcheckFramesCheckBox)
        self.showTimestampsCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.showTimestampsCheckBox.setObjectName("showTimestampsCheckBox")
        self.horizontalLayout_10.addWidget(self.showTimestampsCheckBox)
        self.verticalLayout_2.addLayout(self.horizontalLayout_10)
        self.gridLayout_2 = QtWidgets.QGridLayout()
        self.gridLayout_2.setObjectName("gridLayout_2")
        self.doBlockIntegration = QtWidgets.QPushButton(self.layoutWidget)
        self.doBlockIntegration.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.doBlockIntegration.sizePolicy().hasHeightForWidth())
        self.doBlockIntegration.setSizePolicy(sizePolicy)
        self.doBlockIntegration.setObjectName("doBlockIntegration")
        self.gridLayout_2.addWidget(self.doBlockIntegration, 0, 0, 1, 1)
        self.acceptBlockIntegration = QtWidgets.QPushButton(self.layoutWidget)
        self.acceptBlockIntegration.setEnabled(False)
        self.acceptBlockIntegration.setObjectName("acceptBlockIntegration")
        self.gridLayout_2.addWidget(self.acceptBlockIntegration, 0, 1, 1, 1)
        self.setDataLimits = QtWidgets.QPushButton(self.layoutWidget)
        self.setDataLimits.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.setDataLimits.sizePolicy().hasHeightForWidth())
        self.setDataLimits.setSizePolicy(sizePolicy)
        self.setDataLimits.setToolTipDuration(-1)
        self.setDataLimits.setObjectName("setDataLimits")
        self.gridLayout_2.addWidget(self.setDataLimits, 0, 2, 1, 1)
        self.verticalLayout_2.addLayout(self.gridLayout_2)
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.smoothSecondaryButton = QtWidgets.QPushButton(self.layoutWidget)
        self.smoothSecondaryButton.setEnabled(False)
        self.smoothSecondaryButton.setObjectName("smoothSecondaryButton")
        self.horizontalLayout_5.addWidget(self.smoothSecondaryButton)
        self.numSmoothPointsEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.numSmoothPointsEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.numSmoothPointsEdit.sizePolicy().hasHeightForWidth())
        self.numSmoothPointsEdit.setSizePolicy(sizePolicy)
        self.numSmoothPointsEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.numSmoothPointsEdit.setFrame(True)
        self.numSmoothPointsEdit.setObjectName("numSmoothPointsEdit")
        self.horizontalLayout_5.addWidget(self.numSmoothPointsEdit)
        self.verticalLayout_2.addLayout(self.horizontalLayout_5)
        self.normalizeButton = QtWidgets.QPushButton(self.layoutWidget)
        self.normalizeButton.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.normalizeButton.sizePolicy().hasHeightForWidth())
        self.normalizeButton.setSizePolicy(sizePolicy)
        self.normalizeButton.setObjectName("normalizeButton")
        self.verticalLayout_2.addWidget(self.normalizeButton)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.markDzone = QtWidgets.QPushButton(self.layoutWidget)
        self.markDzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markDzone.sizePolicy().hasHeightForWidth())
        self.markDzone.setSizePolicy(sizePolicy)
        self.markDzone.setObjectName("markDzone")
        self.horizontalLayout_2.addWidget(self.markDzone)
        self.markRzone = QtWidgets.QPushButton(self.layoutWidget)
        self.markRzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markRzone.sizePolicy().hasHeightForWidth())
        self.markRzone.setSizePolicy(sizePolicy)
        self.markRzone.setObjectName("markRzone")
        self.horizontalLayout_2.addWidget(self.markRzone)
        self.calcFlashEdge = QtWidgets.QPushButton(self.layoutWidget)
        self.calcFlashEdge.setEnabled(False)
        self.calcFlashEdge.setObjectName("calcFlashEdge")
        self.horizontalLayout_2.addWidget(self.calcFlashEdge)
        self.verticalLayout_2.addLayout(self.horizontalLayout_2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.minEventLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventLabel.sizePolicy().hasHeightForWidth())
        self.minEventLabel.setSizePolicy(sizePolicy)
        self.minEventLabel.setMinimumSize(QtCore.QSize(50, 0))
        self.minEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.minEventLabel.setObjectName("minEventLabel")
        self.horizontalLayout_3.addWidget(self.minEventLabel)
        self.minEventEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.minEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventEdit.sizePolicy().hasHeightForWidth())
        self.minEventEdit.setSizePolicy(sizePolicy)
        self.minEventEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.minEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.minEventEdit.setObjectName("minEventEdit")
        self.horizontalLayout_3.addWidget(self.minEventEdit)
        self.maxEventLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventLabel.sizePolicy().hasHeightForWidth())
        self.maxEventLabel.setSizePolicy(sizePolicy)
        self.maxEventLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.maxEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.maxEventLabel.setObjectName("maxEventLabel")
        self.horizontalLayout_3.addWidget(self.maxEventLabel)
        self.maxEventEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.maxEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventEdit.sizePolicy().hasHeightForWidth())
        self.maxEventEdit.setSizePolicy(sizePolicy)
        self.maxEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.maxEventEdit.setObjectName("maxEventEdit")
        self.horizontalLayout_3.addWidget(self.maxEventEdit)
        self.verticalLayout_2.addLayout(self.horizontalLayout_3)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setContentsMargins(12, -1, 0, -1)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.DandR = QtWidgets.QRadioButton(self.layoutWidget)
        self.DandR.setChecked(True)
        self.DandR.setObjectName("DandR")
        self.horizontalLayout.addWidget(self.DandR)
        self.Donly = QtWidgets.QRadioButton(self.layoutWidget)
        self.Donly.setObjectName("Donly")
        self.horizontalLayout.addWidget(self.Donly)
        self.Ronly = QtWidgets.QRadioButton(self.layoutWidget)
        self.Ronly.setObjectName("Ronly")
        self.horizontalLayout.addWidget(self.Ronly)
        self.verticalLayout_2.addLayout(self.horizontalLayout)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.penumbralFitCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.penumbralFitCheckBox.setEnabled(False)
        self.penumbralFitCheckBox.setMaximumSize(QtCore.QSize(120, 16777215))
        self.penumbralFitCheckBox.setObjectName("penumbralFitCheckBox")
        self.horizontalLayout_4.addWidget(self.penumbralFitCheckBox)
        self.locateEvent = QtWidgets.QPushButton(self.layoutWidget)
        self.locateEvent.setEnabled(False)
        self.locateEvent.setObjectName("locateEvent")
        self.horizontalLayout_4.addWidget(self.locateEvent)
        self.calcErrBars = QtWidgets.QPushButton(self.layoutWidget)
        self.calcErrBars.setEnabled(False)
        self.calcErrBars.setObjectName("calcErrBars")
        self.horizontalLayout_4.addWidget(self.calcErrBars)
        self.fillExcelReportButton = QtWidgets.QPushButton(self.layoutWidget)
        self.fillExcelReportButton.setEnabled(False)
        self.fillExcelReportButton.setObjectName("fillExcelReportButton")
        self.horizontalLayout_4.addWidget(self.fillExcelReportButton)
        self.verticalLayout_2.addLayout(self.horizontalLayout_4)
        self.horizontalLayout_8 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_8.setObjectName("horizontalLayout_8")
        self.progressBar = QtWidgets.QProgressBar(self.layoutWidget)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        self.horizontalLayout_8.addWidget(self.progressBar)
        self.cancelButton = QtWidgets.QPushButton(self.layoutWidget)
        self.cancelButton.setObjectName("cancelButton")
        self.horizontalLayout_8.addWidget(self.cancelButton)
        self.horizontalLayout_8.setStretch(0, 1)
        self.verticalLayout_2.addLayout(self.horizontalLayout_8)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.viewFrameButton = QtWidgets.QPushButton(self.layoutWidget)
        self.viewFrameButton.setEnabled(False)
        self.viewFrameButton.setObjectName("viewFrameButton")
        self.horizontalLayout_12.addWidget(self.viewFrameButton)
        self.frameNumSpinBox = QtWidgets.QSpinBox(self.layoutWidget)
        self.frameNumSpinBox.setEnabled(False)
        self.frameNumSpinBox.setMaximum(99999)
        self.frameNumSpinBox.setObjectName("frameNumSpinBox")
        self.horizontalLayout_12.addWidget(self.frameNumSpinBox)
        self.fieldViewCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.fieldViewCheckBox.setEnabled(False)
        self.fieldViewCheckBox.setObjectName("fieldViewCheckBox")
        self.horizontalLayout_12.addWidget(self.fieldViewCheckBox)
        self.flipYaxisCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.flipYaxisCheckBox.setEnabled(False)
        self.flipYaxisCheckBox.setObjectName("flipYaxisCheckBox")
        self.horizontalLayout_12.addWidget(self.flipYaxisCheckBox)
        self.flipXaxisCheckBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.flipXaxisCheckBox.setEnabled(False)
        self.flipXaxisCheckBox.setObjectName("flipXaxisCheckBox")
        self.horizontalLayout_12.addWidget(self.flipXaxisCheckBox)
        self.verticalLayout_2.addLayout(self.horizontalLayout_12)
        self.line = QtWidgets.QFrame(self.layoutWidget)
        self.line.setFrameShadow(QtWidgets.QFrame.Raised)
        self.line.setLineWidth(4)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setObjectName("line")
        self.verticalLayout_2.addWidget(self.line)
        self.verticalLayout = QtWidgets.QVBoxLayout()
        self.verticalLayout.setObjectName("verticalLayout")
        self.underlyingLightcurveLabel = QtWidgets.QLabel(self.layoutWidget)
        self.underlyingLightcurveLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.underlyingLightcurveLabel.setObjectName("underlyingLightcurveLabel")
        self.verticalLayout.addWidget(self.underlyingLightcurveLabel)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_13.setObjectName("horizontalLayout_13")
        self.demoUnderlyingLighturvesButton = QtWidgets.QPushButton(self.layoutWidget)
        self.demoUnderlyingLighturvesButton.setObjectName("demoUnderlyingLighturvesButton")
        self.horizontalLayout_13.addWidget(self.demoUnderlyingLighturvesButton)
        self.enableDiffractionCalculationBox = QtWidgets.QCheckBox(self.layoutWidget)
        self.enableDiffractionCalculationBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.enableDiffractionCalculationBox.setChecked(True)
        self.enableDiffractionCalculationBox.setObjectName("enableDiffractionCalculationBox")
        self.horizontalLayout_13.addWidget(self.enableDiffractionCalculationBox)
        self.exposureTimeLabel = QtWidgets.QLabel(self.layoutWidget)
        self.exposureTimeLabel.setObjectName("exposureTimeLabel")
        self.horizontalLayout_13.addWidget(self.exposureTimeLabel)
        self.expDurEdit = QtWidgets.QLineEdit(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.expDurEdit.sizePolicy().hasHeightForWidth())
        self.expDurEdit.setSizePolicy(sizePolicy)
        self.expDurEdit.setMaximumSize(QtCore.QSize(90, 16777215))
        self.expDurEdit.setObjectName("expDurEdit")
        self.horizontalLayout_13.addWidget(self.expDurEdit)
        self.asteroidDistanceLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.asteroidDistanceLabel.sizePolicy().hasHeightForWidth())
        self.asteroidDistanceLabel.setSizePolicy(sizePolicy)
        self.asteroidDistanceLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.asteroidDistanceLabel.setObjectName("asteroidDistanceLabel")
        self.horizontalLayout_13.addWidget(self.asteroidDistanceLabel)
        self.asteroidDistanceEdit = QtWidgets.QLineEdit(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.asteroidDistanceEdit.sizePolicy().hasHeightForWidth())
        self.asteroidDistanceEdit.setSizePolicy(sizePolicy)
        self.asteroidDistanceEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.asteroidDistanceEdit.setObjectName("asteroidDistanceEdit")
        self.horizontalLayout_13.addWidget(self.asteroidDistanceEdit)
        self.shadowSpeedLabel = QtWidgets.QLabel(self.layoutWidget)
        self.shadowSpeedLabel.setObjectName("shadowSpeedLabel")
        self.horizontalLayout_13.addWidget(self.shadowSpeedLabel)
        self.shadowSpeedEdit = QtWidgets.QLineEdit(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.shadowSpeedEdit.sizePolicy().hasHeightForWidth())
        self.shadowSpeedEdit.setSizePolicy(sizePolicy)
        self.shadowSpeedEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.shadowSpeedEdit.setObjectName("shadowSpeedEdit")
        self.horizontalLayout_13.addWidget(self.shadowSpeedEdit)
        self.verticalLayout.addLayout(self.horizontalLayout_13)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.asteroidSizeLabel = QtWidgets.QLabel(self.layoutWidget)
        self.asteroidSizeLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.asteroidSizeLabel.setObjectName("asteroidSizeLabel")
        self.horizontalLayout_15.addWidget(self.asteroidSizeLabel)
        self.astSizeEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.astSizeEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.astSizeEdit.setObjectName("astSizeEdit")
        self.horizontalLayout_15.addWidget(self.astSizeEdit)
        self.pathOffsetLabel = QtWidgets.QLabel(self.layoutWidget)
        self.pathOffsetLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.pathOffsetLabel.setObjectName("pathOffsetLabel")
        self.horizontalLayout_15.addWidget(self.pathOffsetLabel)
        self.pathOffsetEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.pathOffsetEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.pathOffsetEdit.setObjectName("pathOffsetEdit")
        self.horizontalLayout_15.addWidget(self.pathOffsetEdit)
        self.verticalLayout.addLayout(self.horizontalLayout_15)
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setSpacing(0)
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.starDiameterLabel = QtWidgets.QLabel(self.layoutWidget)
        self.starDiameterLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.starDiameterLabel.setObjectName("starDiameterLabel")
        self.horizontalLayout_14.addWidget(self.starDiameterLabel)
        self.starDiameterEdit = QtWidgets.QLineEdit(self.layoutWidget)
        self.starDiameterEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.starDiameterEdit.setObjectName("starDiameterEdit")
        self.horizontalLayout_14.addWidget(self.starDiameterEdit)
        self.dLimbAngleLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dLimbAngleLabel.sizePolicy().hasHeightForWidth())
        self.dLimbAngleLabel.setSizePolicy(sizePolicy)
        self.dLimbAngleLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.dLimbAngleLabel.setObjectName("dLimbAngleLabel")
        self.horizontalLayout_14.addWidget(self.dLimbAngleLabel)
        self.dLimbAngle = QtWidgets.QDoubleSpinBox(self.layoutWidget)
        self.dLimbAngle.setMaximumSize(QtCore.QSize(80, 16777215))
        self.dLimbAngle.setDecimals(1)
        self.dLimbAngle.setMaximum(90.0)
        self.dLimbAngle.setProperty("value", 90.0)
        self.dLimbAngle.setObjectName("dLimbAngle")
        self.horizontalLayout_14.addWidget(self.dLimbAngle)
        self.rLimbAngleLabel = QtWidgets.QLabel(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.rLimbAngleLabel.sizePolicy().hasHeightForWidth())
        self.rLimbAngleLabel.setSizePolicy(sizePolicy)
        self.rLimbAngleLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.rLimbAngleLabel.setObjectName("rLimbAngleLabel")
        self.horizontalLayout_14.addWidget(self.rLimbAngleLabel)
        self.rLimbAngle = QtWidgets.QDoubleSpinBox(self.layoutWidget)
        self.rLimbAngle.setMaximumSize(QtCore.QSize(80, 16777215))
        self.rLimbAngle.setDecimals(1)
        self.rLimbAngle.setMaximum(90.0)
        self.rLimbAngle.setProperty("value", 90.0)
        self.rLimbAngle.setObjectName("rLimbAngle")
        self.horizontalLayout_14.addWidget(self.rLimbAngle)
        self.verticalLayout.addLayout(self.horizontalLayout_14)
        self.verticalLayout_2.addLayout(self.verticalLayout)
        self.line_2 = QtWidgets.QFrame(self.layoutWidget)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Raised)
        self.line_2.setLineWidth(4)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setObjectName("line_2")
        self.verticalLayout_2.addWidget(self.line_2)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.markBaselineRegionButton = QtWidgets.QPushButton(self.layoutWidget)
        self.markBaselineRegionButton.setObjectName("markBaselineRegionButton")
        self.horizontalLayout_16.addWidget(self.markBaselineRegionButton)
        self.clearBaselineRegionsButton = QtWidgets.QPushButton(self.layoutWidget)
        self.clearBaselineRegionsButton.setObjectName("clearBaselineRegionsButton")
        self.horizontalLayout_16.addWidget(self.clearBaselineRegionsButton)
        self.calcStatsFromBaselineRegionsButton = QtWidgets.QPushButton(self.layoutWidget)
        self.calcStatsFromBaselineRegionsButton.setObjectName("calcStatsFromBaselineRegionsButton")
        self.horizontalLayout_16.addWidget(self.calcStatsFromBaselineRegionsButton)
        self.verticalLayout_2.addLayout(self.horizontalLayout_16)
        spacerItem3 = QtWidgets.QSpacerItem(555, 13, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_2.addItem(spacerItem3)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.writePlot = QtWidgets.QPushButton(self.layoutWidget)
        self.writePlot.setEnabled(False)
        self.writePlot.setObjectName("writePlot")
        self.horizontalLayout_9.addWidget(self.writePlot)
        self.writeBarPlots = QtWidgets.QPushButton(self.layoutWidget)
        self.writeBarPlots.setEnabled(False)
        self.writeBarPlots.setObjectName("writeBarPlots")
        self.horizontalLayout_9.addWidget(self.writeBarPlots)
        self.writeCSVButton = QtWidgets.QPushButton(self.layoutWidget)
        self.writeCSVButton.setEnabled(False)
        self.writeCSVButton.setObjectName("writeCSVButton")
        self.horizontalLayout_9.addWidget(self.writeCSVButton)
        self.verticalLayout_2.addLayout(self.horizontalLayout_9)
        self.startOver = QtWidgets.QPushButton(self.layoutWidget)
        self.startOver.setEnabled(False)
        self.startOver.setObjectName("startOver")
        self.verticalLayout_2.addWidget(self.startOver)
        self.helpLabelForDataGrid = QtWidgets.QLabel(self.layoutWidget)
        self.helpLabelForDataGrid.setObjectName("helpLabelForDataGrid")
        self.verticalLayout_2.addWidget(self.helpLabelForDataGrid)
        self.mainPlot = PlotWidget(self.splitter_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.mainPlot.sizePolicy().hasHeightForWidth())
        self.mainPlot.setSizePolicy(sizePolicy)
        self.mainPlot.setMinimumSize(QtCore.QSize(4000, 0))
        self.mainPlot.viewport().setProperty("cursor", QtGui.QCursor(QtCore.Qt.IBeamCursor))
        self.mainPlot.setObjectName("mainPlot")
        self.splitter = QtWidgets.QSplitter(self.splitter_3)
        self.splitter.setOrientation(QtCore.Qt.Horizontal)
        self.splitter.setObjectName("splitter")
        self.table = QtWidgets.QTableWidget(self.splitter)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.table.sizePolicy().hasHeightForWidth())
        self.table.setSizePolicy(sizePolicy)
        self.table.setMinimumSize(QtCore.QSize(0, 0))
        self.table.setToolTipDuration(4000)
        self.table.setRowCount(11)
        self.table.setColumnCount(4)
        self.table.setObjectName("table")
        self.textOut = QtWidgets.QTextEdit(self.splitter)
        self.textOut.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.textOut.setUndoRedoEnabled(False)
        self.textOut.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        self.textOut.setReadOnly(True)
        self.textOut.setObjectName("textOut")
        self.gridLayout_3.addWidget(self.splitter_3, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "PY-OTE"))
        self.manualTimestampCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This checkbox makes the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Manual timestamp entry</span><span style=\" font-size:18pt;\"> button active. You will need/use that button when processing a light curve that employs \'flash timing\' instead of a VTI.</span></p><p><span style=\" font-size:18pt;\">Manual entry of timestamp information is also useful if there </span><span style=\" font-size:18pt; font-weight:600; text-decoration: underline;\">are</span><span style=\" font-size:18pt;\"> timestamps, but manual entry of timing information is required because of major errors in those timestamps.</span></p><p><span style=\" font-size:18pt;\">NOTE: timestamps are ALWAYS treated as start-of-exposure times.</span></p></body></html>"))
        self.manualTimestampCheckBox.setText(_translate("MainWindow", "Enable manual timestamp entry"))
        self.manualEntryPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button causes a dialog to appear in which timestamp information may be entered. This is needed if \'flash timing\' is being utilized.</p><p>It is also useful when OCR of a VTI overlay has a high error rate, but enough entries have been properly read that \'goal post\' timing (use of two times that bracket the event to provide the timing information by interpolation) can be used.</p><p>NOTE: timestamps are ALWAYS treated as start-of-exposure times.</p></body></html>"))
        self.manualEntryPushButton.setText(_translate("MainWindow", "Manual timestamp entry"))
        self.infoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to to open the <span style=\" color:#ff0000;\">help.pdf</span> file that is included in the installation. The file will open in whatever PDF viewer you have assigned as the default viewer for pdf files.</p><p>The first part of this file is version info that should be examined every time a new version of PyOTE is installed.</p><p>At the bottom of this version info is a brief introduction to PyOTE that should be read by new users.</p></body></html>"))
        self.infoButton.setWhatsThis(_translate("MainWindow", "How does this show up?"))
        self.infoButton.setText(_translate("MainWindow", "Info"))
        self.readData.setToolTip(_translate("MainWindow", "<html><head/><body><p>PYOTE reads Limovie, R-OTE, and Tangra files and includes up to four light curves from those file types.  For PyMovie files, PYOTE will read an unlimited number of light curves.</p><p>Normally (but not required) object1 is the occulted star; other (optional) objects are reference stars to be used for normalizing the occulted star light curve or flash curves from an LED timer.</p><p><span style=\" font-weight:600; text-decoration: underline; color:#0000ff;\">Mouse button functions within the light curve plot:</span></p><p><span style=\" font-weight:600; color:#ff0000;\">Left click</span>: selects/deselects points on the primary (dark blue) light curve that intersect with the vertical hairline (the mouse cursor is disabled).</p><p><span style=\" font-weight:600; color:#ff0000;\">Left click and drag</span>: rectangular zoom is available to more clearly see points for selection (but point selection can also be accomplished through clicks in the tabular data display at the lower left)</p><p><span style=\" font-weight:600;\">Note! The shift key will toggle the mouse cursor on/off in the light curve plot.</span> This enables the starting corner for the zoom to be seen. (But points cannot be selected/deselected while the mouse cursor is visible. A right click will always \'blank\' the mouse cursor.) </p><p><span style=\" font-weight:600; color:#ff0000;\">Right click</span>: undo zoom</p><p><span style=\" color:#996633;\">Timestamp errors are shown with vertical red hairlines when a file is first read. These will disappear after the first point is selected so that the working view is as clear as possible. The red hairlines will re-appear permanently after the error bars have been calculated and the final report written to the log.</span></p></body></html>"))
        self.readData.setText(_translate("MainWindow", "Read light curve"))
        self.helpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>\'Help\' is available for most GUI items by right-clicking on the item.</p><p>If an item already has a different action assigned to a right-click, there will be a nearby text line or button that can be clicked on instead.</p><p>There is no need to close the help panel before right-clicking on another GUI item. One can use this feature to get a quick survey of the \'help\' that is available by sequentially clicking on all GUI items.</p></body></html>"))
        self.helpButton.setText(_translate("MainWindow", "Help"))
        self.tutorialButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Tip:&nbsp;right-click on buttons and labels.&nbsp;An explanation (help screen) will usually appear.&nbsp;Use that technique to learn about features that are not covered in this basic tutorial/recipe.</p><p>1. Start by clicking the<span style=\" font-weight:600; color:#0000ff;\"> Read light curve</span> button.&nbsp;(Usually,&nbsp;the camera exposure value will be read from the csv file and automatically inserted in the <span style=\" font-weight:600; color:#0000ff;\">exp:</span> edit box in the <span style=\" font-weight:600; color:#0000ff;\">parameters</span> panel.&nbsp;If that did not happen,&nbsp;you will need to manually fill in that value in before trying to find an event fit.)</p><p>2. If timestamp errors have been detected during the loading of the csv file,&nbsp;the affected points will be bracketed by vertical redlines and the <span style=\" font-weight:600; color:#0000ff;\">Show time err</span> checkbox will have been set by the program.&nbsp;Those red lines will likely have served their purpose and can/should be turned off so that a clear view of the light-curve is presented.</p><p>3. If the csv file contained multiple light-curves (it usually will),&nbsp;you may need to click the <span style=\" font-weight:600; color:#0000ff;\">Light curve to analyze</span> spinner to advance to the light-curve that contains the event.</p><p>4. The next step is to give the \'event finder\' information that can speed up the search. </p><p>4a. If the event has a wide enough bottom,&nbsp;the quickest way to provide speed-up information is mark the D and R regions.&nbsp;Right-click on those buttons for a how-to.</p><p>4b. If the event is so small that it is hard or impossible to mark D and R regions,&nbsp;the speed-up information is then best supplied by placing the smallest event duration in the <span style=\" font-weight:600; color:#0000ff;\">min event duration</span> edit box and the maximum event duration in the <span style=\" font-weight:600; color:#0000ff;\">max event duration</span> edit box.&nbsp;The \'finder\' will then search for all events in the range of durations given,&nbsp;located anywhere in the light-curve.</p><p>5. Next,&nbsp;click the <span style=\" font-weight:600; color:#0000ff;\">Find event, then ...</span> button to initiate the search.</p><p>6. Assuming the search was successful,&nbsp;the final step is to click the <span style=\" font-weight:600; color:#0000ff;\">... write report</span> button.</p><p>Every step you took is recorded in a log file in the directory where the light-curve was read from.&nbsp;This is important information to provide to anyone that you might go to for assistance.&nbsp;Give them the csv file and the log file and they will be able to reproduce your session.</p></body></html>"))
        self.tutorialButton.setText(_translate("MainWindow", "Tutorial"))
        self.lightCurveNumberLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spinner to select which light curve to analyze for an occultation event or as a source for \'flash timing\' edges.</p></body></html>"))
        self.lightCurveNumberLabel.setText(_translate("MainWindow", "Light curve number to analyze (blue):"))
        self.curveToAnalyzeSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spinner to select which light curve to analyze for an occultation event or as a source for \'flash timing\' edges.</p></body></html>"))
        self.lineWidthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spinner sets the line width (in pixels) of the error bar lines, the geometric edge lines, and the lightcurve lines.  Adjust this to show these lines according to your taste and the resolution of your screen.</p></body></html>"))
        self.lineWidthLabel.setText(_translate("MainWindow", "line width"))
        self.showSecondaryCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>The display of the secondary star can be turned on and off with this checkbox. This is useful if the secondary star trace overlaps the main star. The secondary star data remains available for smoothing and normalization, even if it is not being displayed.</p></body></html>"))
        self.showSecondaryCheckBox.setText(_translate("MainWindow", "Use curve"))
        self.secondarySelector.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there are multiple reference stars in the file, this spinner will activate to allow the choice of which one to display/use.</p></body></html>"))
        self.normLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If there are multiple reference stars in the file, this spinner will activate to allow the choice of which one to display/use.</p></body></html>"))
        self.normLabel.setText(_translate("MainWindow", "for normalization (green)"))
        self.helpLabelForFalsePositive.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Advisory ===============================================</span></p><p>Assuming that you have been diligent in removing common lightcurve artifacts (dips caused by something other than an occultation, like clouds, or a contrail, or ...) using the normalization function, please be aware that:</p><p>A non-zero False Positive probabilty (red bar to left of black bar) is usually sufficient reason to report a \'miss\' (but see note below).</p><p><span style=\" font-weight:600; color:#fc0107;\">However</span>, a False Positive probabilty of zero should <span style=\" font-weight:600; color:#fc0107;\">NEVER</span> be accepted as a sole sufficient reason to report a \'positive\'.</p><p><br/>If you get a zero False Positive probability <span style=\" text-decoration: underline;\">and this is the only available chord</span>, look at the False Positive drop distribution plot and only consider reporting a \'positive\' if the measured drop is well to the right of the black bar that shows the biggest drop found during the simulation run. \'Well to the right\' is rather vague, so consult with your area coordination whenever you are uncertain.</p><p>Note: if your \'drop\' (red bar) is near the black bar (on either side!) AND there are nearby chords reporting \'positives\', there may be value in your observation in spite of the False Positive probability calculation; your observation may increase confidence in the event recorded by the nearby chords.</p><p><br/></p></body></html>"))
        self.plotHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#0000ff;\">Once data from an observation is being displayed in the panel to the right, the following functions are available:</span></p><p>&gt;&gt;&gt; moving the mouse cursor into the plot area causes a thin vertical line to appear to show the x position</p><p>&gt;&gt;&gt; a left-click will toggle the selection of the data point at the x position of the mouse (watch the thin vertical line)</p><p>&gt;&gt;&gt; the plot can be zoomed horizontally using the scroll wheel (or equivalent) on the mouse</p><p>&gt;&gt;&gt; holding down the shift key will cause the mouse cursor to appear, useful for the following operation...</p><p>&gt;&gt;&gt; a left-click/hold/drag will create a selection box --- on left-button release, a zoomed image will appear</p><p>&gt;&gt;&gt; a right-click undoes any scroll/zoom modifications that have been performed</p><p><span style=\" font-weight:600; color:#0000ff;\">Timestamp errors:</span></p><p>If the csv file included timestamps, there may be a few (or many) thin vertical red lines, each appearing between adjacent data points.  These indicate that the time step computed from the adjacent data points was not within 10% of the \'expected\' time step.  The expected value is computed from the median of all time steps.  There is a checkbox to the left that can be used to suppress this display if it is too intrusive.</p><p><span style=\" font-weight:600; color:#0000ff;\">When a \'solution\' has been found, there will be displayed:</span></p><p>+++ in brown: the underlying lightcurve (theoretical lightcurve with diffraction and finite star disk effects included)</p><p>+++ in blue: the camera response --- this is the underlying lightcurve integrated by the exposure time of the camera</p><p>+++ vertical dashed lines: these show the position of the occultation\'s geometrical edges (red: D green: R)</p><p><span style=\" font-weight:600; color:#0000ff;\">After a \'... write report\' has been performed:</span></p><p>=== the 95% confidence interval for the D and/or R edges are shown with shortened vertical dotted enclosing the central value</p></body></html>"))
        self.plotHelpButton.setText(_translate("MainWindow", "Help for plot -->"))
        self.showTimestampErrors.setToolTip(_translate("MainWindow", "<html><head/><body><p>Timestamp errors are indicated by red lines that show where a time step is not within +/- 10% of the expected value.</p><p>Sometimes there are so many red lines that is becomes hard to see the plot. In that case, uncheck this box to suppress the red line display.</p></body></html>"))
        self.showTimestampErrors.setText(_translate("MainWindow", "time err "))
        self.showUnderlyingLightcurveCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you want to see the underlying lightcurve (the instantaneous theoretical lightcurve that the camera \'sees\'), set this box to \'checked\'.</p><p>The solution plot gets a bit cluttered when the camera response curve, the \'solution\', and the underlying lightcurve are all being displayed at once.</p></body></html>"))
        self.showUnderlyingLightcurveCheckBox.setText(_translate("MainWindow", "raw light"))
        self.showErrBarsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you do not want to see the vertical dashed lines that show the 95% confidence interval error bars for D and/or R, uncheck this box.</p></body></html>"))
        self.showErrBarsCheckBox.setText(_translate("MainWindow", "err bars"))
        self.showEdgesCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you do not want to see the D and/or R edges marked with a vertical dashed line on the \'solution\', uncheck this box.</p></body></html>"))
        self.showEdgesCheckBox.setText(_translate("MainWindow", "edges"))
        self.showOCRcheckFramesCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Uncheck this box if you do not need to see the D and/or R frames from the video automatically displayed to verify that timestamp OCR was correct.</p><p><span style=\" font-weight:600; color:#0000ff;\">Background:</span> if the video that produced the csv being analyzed is still in its original location, PyOTE will access that video whenever an event has been found and the critical frames that determine the reported times will be displayed. The timing data used for the report is displayed in the title of each displayed frame, allowing a user to visually confirm that the OCR timestamp extraction was correct.</p><p>NOTE: timestamps are ALWAY treated as start-of-exposure times.</p></body></html>"))
        self.showOCRcheckFramesCheckBox.setText(_translate("MainWindow", "Do OCR check"))
        self.showTimestampsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you want frame numbers used on the x-xaxis,&nbsp;uncheck this box.&nbsp;Otherwise,&nbsp;if timestamps are available,&nbsp;they will be used to annotate the x-axis.</p></body></html>"))
        self.showTimestampsCheckBox.setText(_translate("MainWindow", "timestamps"))
        self.doBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Light curves from integrated videos must be block integrated before further processing is carried out.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">An automatic determination of the correct block size and starting point (offset) will be performed if no points have been selected. You will have the opportunity to accept or reject the result of this automatic process using the button to the right (</span><span style=\" font-family:\'arial,sans-serif\'; font-weight:600; color:#fc0107;\">Accept integration</span><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">).</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If a manual selection is necessary, then the procedure stated below can be performed:</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Zoom into a small portion of the light curve and locate a clearly identifiable group of data points that belong to an integration block, click on the first and last point of that data point group, then press this button to integrate all such groups in the light curve into a single data points.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">A block integration, either manual or automatic, can be performed only once per data file; it cannnot be undone by use of the </span><span style=\" font-family:\'arial,sans-serif\'; font-weight:600; color:#fc0107;\">Start over</span><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\"> button. Instead, you will need to re-read the file.</span></p></body></html>"))
        self.doBlockIntegration.setText(_translate("MainWindow", "Block integrate"))
        self.acceptBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button will be enabled only after pyote has proposed a block integration. If, after examining the proposed block size and offset shown on the light curve, you wish to apply the integration, press this button.</p></body></html>"))
        self.acceptBlockIntegration.setText(_translate("MainWindow", "Accept Integration"))
        self.setDataLimits.setToolTip(_translate("MainWindow", "<html><head/><body><p>If exactly two data points have been selected, this button will <span style=\" font-weight:600; text-decoration: underline;\">trim</span> off (exclude) data points to the left and right of the selected points. The excluded points will shown in light gray.</p><p>If no points have been selected, then all data points will be selected as the default.</p><p>Once a trim has been performed, its effects can be removed by clicking on the <span style=\" font-weight:600; color:#fc0107;\">Start over</span> button.</p></body></html>"))
        self.setDataLimits.setText(_translate("MainWindow", "Trim left/right"))
        self.smoothSecondaryButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Smooth the selected secondary (reference) star light curve using a Savitsky-Golay filter with a default window of 101 points (the edit box to the right allows for this value to be changed) and a degree 3 interpolating polynomial, applied twice.</p><p>The secondary star does not have to be visible for this smoothing to take place.</p><p>Smoothing of the secondary curve is a prerequisite to normalizing the occulted star light curve.</p></body></html>"))
        self.smoothSecondaryButton.setText(_translate("MainWindow", "Smooth secondary"))
        self.numSmoothPointsEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>This edit box allows you to change the number of points used in Savitsky-Golay filter during smoothing of the secondary star. The window size should be an odd number in the range of 5 up to the number of data points in the secondary curve.</p><p>If an even number is specified, the window size used will be one less than that number.</p><p>Pressing <span style=\" font-weight:600; color:#ff0000;\">tab</span> or <span style=\" font-weight:600; color:#ff0000;\">return</span> at completion of data entry will trigger the smoothing, or you can click on the Smooth secondary button</p></body></html>"))
        self.numSmoothPointsEdit.setText(_translate("MainWindow", "101"))
        self.normalizeButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>If a smoothed secondary (reference) curve is available, and a single point has been selected on the curve to be normalized, the selected light curve will be \'normalized\' against the reference star. This can be useful in removing light curve distortions caused by clouds or similat light changes.</p><p>This done by creating a \'gain curve\' from the smoothed reference curve. The \'gain\' is unity at the selected point and proportionally larger/smaller at all the other points.</p><p>This \'gain curve\' is then multiplied point by point against the curve being analyzed to produce the \'normalized\' version of that light curve.</p><p>Normalization is a one-time-only procedure in that its effects can <span style=\" font-weight:600;\">not</span> be removed by use of the <span style=\" font-weight:600; color:#fc0107;\">Start over</span> button.</p></body></html>"))
        self.normalizeButton.setText(_translate("MainWindow", "Normalize around selected point"))
        self.markDzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star disappears, then click this button to create a D search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If no points are selected, a search for a D transition will not be performed --- this becomes an \'R only\' event.</span></p></body></html>"))
        self.markDzone.setText(_translate("MainWindow", "Mark D region"))
        self.markRzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star reappears, then click this button to create an R search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If no points are selected, a search for an R transition will not be performed --- this becomes a \'D only\' event.</span></p></body></html>"))
        self.markRzone.setText(_translate("MainWindow", "Mark R region"))
        self.calcFlashEdge.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button calculates the fractional frame number at which the start of a timing flash occurred.</p><p>Click a point on either side of the R event (leading edge) of a timing flash, then click the <span style=\" font-weight:600; color:#fc0107;\">Calc flash edge</span> button (this one). Start with the earliest edge, then repeat the procedure on the second edge (if present --- it is highly recommended to use goal-post flashes that bracket the event).</p><p>Next, click the <span style=\" color:#fc0107;\">M</span><span style=\" font-weight:600; color:#fc0107;\">anual timestamp entry</span> button to bring up a dialog for entering manual timestamp data. The calculated frame values for the edges will be automatically pre-filled in the form. You only need enter the corresponding flash time values from the flash app log and click <span style=\" font-weight:600; color:#fc0107;\">Ok </span><span style=\" color:#000000;\">to trigger timestamp calculations for all points</span>.</p><p><br/></p></body></html>"))
        self.calcFlashEdge.setText(_translate("MainWindow", "Calc flash edge"))
        self.minEventLabel.setText(_translate("MainWindow", "min event:"))
        self.minEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter smallest event size (in number of readings) to search for.</p></body></html>"))
        self.maxEventLabel.setText(_translate("MainWindow", "max event:"))
        self.maxEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter largest event size (in number of readings) to search for.</p></body></html>"))
        self.DandR.setText(_translate("MainWindow", "D:R"))
        self.Donly.setText(_translate("MainWindow", "D"))
        self.Ronly.setText(_translate("MainWindow", "R"))
        self.penumbralFitCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If an occultation involves a star that is not point-like (has a detectable disk), the observation lightcurve will often have a gradual transition and take more than one or two readings for the disappearance and/or reappearance to occur. To extract timing data from such an observation, an underlying lightcurve model that incorporates star diameter (mas) and limb angles must be used.</p><p><span style=\" font-weight:600;\">This checkbox will be enabled whenever a star diameter is entered below AND the </span><span style=\" font-weight:600; color:#fc0107;\">Demo</span><span style=\" font-weight:600;\"> button has been clicked. You WILL forget this; it happens to me. No worries; nothing breaks. Just right-click and refresh your memory!</span></p><p><span style=\" font-weight:600; color:#0000ff;\">Please use the example-penumbra.csv file that is provided in the download for practice.</span> (This file may be hard to find as it is placed wherever your system stores the PyOTE application files. Best advice is to do a search of the entire drive for the exact file name, then copy it to a more convenient place.) The header lines in that file give you good values to use for asteroid distance, asteroid speed, and star diameter to start with. Find the supplied file with a file-search --- <span style=\" font-weight:600; color:#fc0107;\">move it somewhere else to play with - don\'t clutter up your software installation directory with the PyOTE files that are generated during normal processing - nothing bad will happen if you fail to heed this advice, but it\'s good practice to follow this advice.</span></p><p>Once this checkbox is checked (and you will forget to do this sometimes too!), the <span style=\" font-weight:600; color:#fc0107;\">Find event, then ...</span> button will invoke the \'penumbral fit\' methodology. When the \'penumbral fit\' methodology is active, the user is expected to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1.</span> Carefully locate the D and or R regions so that the penumbral transition regions are precisely enclosed. Use the <span style=\" font-weight:600; color:#fc0107;\">Mark D region</span> button and the <span style=\" font-weight:600; color:#fc0107;\">Mark R region</span> button in the usual way.</p><p>This allows PyOTE to identify/assume the points to the left and right of the D and/or R regions are baseline points so as to compute a correct baseline intensity and its associated noise. This also allows the points between the D and/or R regions to be used for the computation of the correct event intensity and its associated noise.</p><p><span style=\" font-weight:600; color:#fc0107;\">2.</span> Repeatedly click the <span style=\" font-weight:600; color:#fc0107;\">Find event, then ...</span> button, evalute the \'fit\' visually, and change the limb angles until satisfied (watch the \'metric\' to see how you are doing), then</p><p><span style=\" font-weight:600; color:#fc0107;\">3.</span> Click the <span style=\" font-weight:600; color:#fc0107;\">... write report</span> button, as usual.</p><p>The D and/or R edge times will not change significantly during the step 2 iterations; they are only performed to get an estimate of the D and/or R limb angles, so a good visual fit should be adequate.</p><p>It is a characteristic of penumbral curves that they are \'under-constrained\' in that there is NOT a unique set of values for star diameter and the two limb angles. It is <span style=\" text-decoration: underline;\">always</span> the case that, given a star diameter and limb angles of 90 degrees (head-on), there is a smaller star diameter with smaller limb angles that will result in exactly the same lightcurve. Usually, the star diameter will be reasonably well known, so that value is held fixed while one adjusts the D and R limb angles until a satisfactory fit is found.</p></body></html>"))
        self.penumbralFitCheckBox.setText(_translate("MainWindow", "Penumbral fit   "))
        self.locateEvent.setText(_translate("MainWindow", "Find event, then ..."))
        self.calcErrBars.setToolTip(_translate("MainWindow", "<html><head/><body><p>To get a \'Final Report\', error bars are required. Clicking this button will start the computation of those error bars and, when complete, trigger the preparation of a \'Final Report\'</p></body></html>"))
        self.calcErrBars.setText(_translate("MainWindow", "... write report"))
        self.fillExcelReportButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to copy your results to the Asteroid Occultation Report Form (.xlsx spreadsheet - note file type is .xlsx, not .xls). This button will be inactive (grayed out) until a succesful <span style=\" font-weight:600; color:#0000ff;\">... write report</span> has been accomplished.</p><p>The expected workflow is:</p><p>1) Given that PyOTE now has a solution that you wish to report (an occultation), leave PyOTE open ...</p><p>2) Run OccultWatcher to enter your event result report. Be sure to ask for a \'prefill\' of the .xls version of the report ...</p><p><span style=\" font-weight:600; color:#fc0107;\">3) Convert that .xls file to .xlsx using either Excel (Windows) or LibreOffice (Mac or Linux)</span></p><p>4) Go back to PyOTE and click this button ...</p><p>5) A file dialog will open; locate and select the prefilled and converted .xlsx report from steps 2 and 3.</p><p>6) If the file selected in step 5 was a valid Asteroid Occultation Report Form .xlsx file, the PyOTE results will be inserted.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: the excel format change from .xls to .xlsx will not affect the downstream processing adversely as the tool in use accepts either format equally well.</span></p><p><br/>The values that are inserted are:</p><p>--- all error bars</p><p>--- uncorrected D and/or R times</p><p>--- SNR</p><p>--- OTA used (PYOTE)</p><p>---A sentence summarizing magDrop information will be added in the Comments box</p></body></html>"))
        self.fillExcelReportButton.setText(_translate("MainWindow", "... fill Excel report"))
        self.cancelButton.setText(_translate("MainWindow", "Cancel"))
        self.viewFrameButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to view a frame from the video that was used by PyMovie or Limovie to prepare the csv file that is currently being analyzed. Currently .avi and .ser files are viewable in this manner as well as .fits files inside a FITS folder.</p><p>If this button is disabled, it is because the csv file did not come from PyMovie or Limovie or simply cannot be found/opened.</p><p>This feature can/should be used as a final quality control check for a video that contains timestamps extracted using OCR. It is possible for OCR to fail in manner that is <span style=\" font-weight:600; color:#fc0107;\">not detected</span> by PyOTE because the program only verifies that there is a consistent step (delata time) between frames. If a high order digit has been consistently misread, like reading an 8 as a 9 in the minutes field, the steps can be consistent but the reported time of the event will be wrong.</p><p>ALL time reporting is derived from the single timestamp(s) associated with D and/or R (the integer values, not the sub-frame values). If those timestamps are correct, the reported times will be correct even when there may be a few missing or duplicated frames and all other timestamps are wrong. So, best practice is to enter the D frame value in the spin box and visually confirm that the timestamp that you can see is the same as that extracted by the OCR procedure. Repeat for R.</p><p>Another use for this feature is to handle the case where there is a visual timestamp that can be seen in the video, but either OCR was not activated during the .csv preparation, or the timestamp overlay came from an unsupported VTI type. The workflow in this case is to let PyOTE find the D and R values, but before doing <span style=\" font-weight:600; color:#fc0107;\">... write report</span>, do a <span style=\" font-weight:600; color:#fc0107;\">Manual timestamp entry</span> for the D and R values found by viewing the relevant frames and entering the correct times in the Manual timestamp dialog.</p><p>Note that timestamps can be entered manually even if timestamps are already present in the file. The manual timestamps will be calculated and used to replace those already there.</p></body></html>"))
        self.viewFrameButton.setText(_translate("MainWindow", "View frame:"))
        self.frameNumSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spin box (which may be directly edited) to select the number of the frame/image you want to see.</p><p>The upper limit and lower limits for allowed numbers in this spin box are set when the csv is read, which sometimes only contains a subset of the frames available in the video.  If your \'edit\' is refused, it is because you are trying to enter a number outside the range allowed, which is always restricted to frame numbers that actually appear in the csv file.</p></body></html>"))
        self.fieldViewCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>For videos from a composite video camera, check this box to view the frame as two fields.</p></body></html>"))
        self.fieldViewCheckBox.setText(_translate("MainWindow", "field view"))
        self.flipYaxisCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Checking this box will rotate/flip the image around the horizontal axis. (Flips top to bottom.)</p></body></html>"))
        self.flipYaxisCheckBox.setText(_translate("MainWindow", "flip top/bottom"))
        self.flipXaxisCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Check this box if you need to rotate/flip the image around the vertical axis. (Flip left to right.)</p></body></html>"))
        self.flipXaxisCheckBox.setText(_translate("MainWindow", "flip left/right"))
        self.underlyingLightcurveLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This group of edit boxes allows the parameters for an observation-appropriate \'underlying lightcurve\' to be entered.</p><p>We define the \'underlying lightcurve\' thusly: it is the theoretical intensity of the light diffracted at the occulting edge (assumed straight) as a function of time, i.e. as the shadow of the occulting body passes the observation position, and includes the effect of a possibly finite star disk.  Click the <span style=\" font-weight:600; color:#fc0107;\">Demo</span> button to get a preview of this underlying lightcurve to make sure that the parameters are reasonable and, <span style=\" color:#fc0107;\">most importantly, have been entered without error</span> because these values will be used once a \'solution\' has been found.</p><p>Diffraction intensity has a wavelength dependence. In PyOTE, we compute a generic diffraction curve composed of light wavelengths in the 400nm to 600nm range (using 5 nm steps) with equal intensities at each included wavelength. The region of the diffraction curve that is of most interest to us is only about +/- 1 Fresnel unit on either side of the geometrical shadow point. Fortunately, in that region, there is very little difference between a narrow band of light wavelengths and a wide band of light wavelengths, so there is no practical need to specify a more realistic bandpass in terms of either shape (amplitudes) or extent (bandpass). The primary effect of a wide bandpass is to greatly reduce the oscillations seen in a single wavelength diffraction curve (i.e., the one that is most frequently used to show diffraction effects).</p><p>If the star has a finite disk, the effect on the underlying lightcurve is usually very significant and apparent, \'integrating\' away most of the characteristic diffraction curve shape and moving toward what is often referred to as a penumbral shape. It also moves the value of the intensity at the geometrical shadow point from 25% of full scale up to something close to 50% of full scale.</p><p>If you leave the exposure duration (exp dur: edit box) empty, the result of clicking the <span style=\" font-weight:600; color:#fc0107;\">Demo</span> button will be a display of the underlying light curve shape. To see the effect of the camera exposure time, which integrates the underlying light curve to produce what we refer to as the camera response, fill in the effective exposure time, taking into account the observation frame rate and number of frames being integrated. Note: this field will be updated/filled in automatically when an observation with timing data is loaded and, if necessary, integrated.</p><p>If a <span style=\" font-weight:600; color:#fc0107;\">Demo</span> is run before \'solution\' baseline and event intensities have been determined, generic values of 100.0 (baseline intensity) and 0.0 (event intensity) are used. If \'real\' baseline and event intensities are available, they are used instead.</p></body></html>"))
        self.underlyingLightcurveLabel.setText(_translate("MainWindow", "parameters to estimate diffraction, star disk, and centerline offset effects "))
        self.demoUnderlyingLighturvesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button demonstrates the computation of the lightcurve used in determining the time of the geometric shadow edge, given the observation parameters set in the edit boxes in this edit box group. It can be a useful tool in gaining an understanding of diffraction (and other) effects.</p><p>If values have been entered in the two boxes to the right (asteroid distance, and speed), the 400nm to 600nm bandpass integrated analytic diffraction lightcurve will be computed and displayed.</p><p>We refer to this as the \'underlying lightcurve\': it is the theoretical (instantaneous) intensity of the light diffracted at the occulting edge as a function of time, i.e. as the shadow of the occulting body passes an observation position that is <span style=\" text-decoration: underline;\">on the path centerline</span>.</p><p>The \'underlying lightcurve\' will be further modified by:</p><p>1. the camera exposure function (which acts as an integrator)</p><p>2. the position of observation with respect to the asteroid path centerline (because of the 2D nature of the diffracted asteroid image)</p><p>3. a target star that has a discernible disk</p><p>The instantaneous underlying lightcurve (with correction for an off-centerline observation) is modified by the camera exposure function and, if the star has a discernible disk, the star intensity function. The resulting composite lightcurve is mathematically the convolution of the underlying lightcurve with the camera exposure function and possibly the star intensity function.</p><p>(Technically a convolution is defined as the integral of the product of two functions after one is reversed and shifted - the integral is evaluated for all values of shift to produce the modified function.)</p><p><span style=\" font-family:\'Helvetica\';\">The camera exposure function is defined as equal to 1.0 while the shutter is open, and 0.0 at all other times. (A \'boxcar\' integration)</span></p><p><span style=\" font-family:\'Helvetica\';\">The star intensity function is the chord length across the diameter of the star.</span></p><p>These two functions are plotted on the demonstration graph (at half intensity to avoid overlap with the baseline) so that one can see the functions that are being convolved and to make it easy to see how much of an effect should be expected.</p><p>Diffraction intensity has a wavelength dependence. In PyOTE, we compute a generic diffraction curve composed of light wavelengths in the 400nm to 600nm range (using 5 nm steps) with equal intensities at each included wavelength. The region of the diffraction curve that is of most interest to us is only about +/- 1 Fresnel unit on either side of the geometrical shadow point. Fortunately, in that region, there is very little difference between a narrow band of light wavelengths and a wide band of light wavelengths, so there is no practical need to specify a more realistic bandpass in terms of either shape (amplitudes) or extent (bandpass). The primary effect of a wide bandpass is to greatly reduce the oscillations seen in a single wavelength diffraction curve (i.e., the one that is most frequently used to show diffraction effects).</p><p>If the star has a finite disk, the effect on the underlying lightcurve is usually very significant and apparent, \'integrating\' away most of the characteristic diffraction curve shape and moving toward what is often referred to as a penumbral shape. It also moves the value of the intensity at the geometrical shadow point from up to something close to 50% of full scale.</p><p>If you leave the exposure duration (exp dur: edit box) empty, the result of clicking this button will be a display of the underlying light curve shape. To see the effect of the camera exposure time, which integrates the underlying light curve to produce what we refer to as the camera response, fill in the effective exposure time, taking into account the observation frame rate and number of frames being integrated. Note: this field will be updated/filled in automatically when an observation with timing data is loaded and, if necessary, integrated.</p><p>If this demo is run before \'solution\' baseline and event intensities have been determined, generic values of 100.0 (baseline intensity) and 0.0 (event intensity) are used. If \'real\' baseline and event intensities are available, they are used instead.</p></body></html>"))
        self.demoUnderlyingLighturvesButton.setText(_translate("MainWindow", "Demo"))
        self.enableDiffractionCalculationBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This checkbox enables the application of diffraction effects to the underlying lightcurve. Usually, you will want to use diffraction effects for the underlying lightcurve, so this box is checked by default.</p><p>But sometimes you may want to use a pure penumbral curve when the star has a finite disk. In that case, uncheck this box.</p><p>This is also useful as learning/demonstration tool when exploring what effects the underlying lightcurve.</p></body></html>"))
        self.enableDiffractionCalculationBox.setText(_translate("MainWindow", "use diff  "))
        self.exposureTimeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the effective camera exposure time (shutter time) in seconds, taking into account camera integration of frames if that was employed in this observation.</p><p>This box will normally be filled automatically when a file is read that has timing information included.</p><p>The value in this box will also be updated whenever and integration operation changes the frame duration.</p></body></html>"))
        self.exposureTimeLabel.setText(_translate("MainWindow", "  exp:"))
        self.asteroidDistanceLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the distance to the asteroid/occulting body.</p><p>For distance units, use AU (Astronomical units)</p><p>Note: If parallax (in arc seconds) to the asteroid is available instead of distance in AU, the distance to the asteroid can be calculated with the equation:</p><p align=\"center\"><span style=\" font-size:18pt; font-weight:600;\">distance(AU) = 8.7882 / parallax(arc seconds)</span></p></body></html>"))
        self.asteroidDistanceLabel.setText(_translate("MainWindow", "  ast dist(AU):"))
        self.shadowSpeedLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the speed of the occulting body in kilometers per second.</p><p>This is used as the speed of the occultation shadow projected on the earth.</p><p>This value is used to convert the diffraction pattern, which is calculated as a function of Fresnel units, to a function of time.</p><p>If the asteroid speed is not given but its diameter and the maximum expected event duration is known, the asteroid speed can be calculated with this equation:</p><p align=\"center\"><span style=\" font-size:18pt; font-weight:600;\">asteroid speed (km/sec) = asteroid diameter(km) / max duration(seconds)</span></p></body></html>"))
        self.shadowSpeedLabel.setText(_translate("MainWindow", "  ast speed(km/sec):"))
        self.asteroidSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>In order to calculate the effect on the underlying diffraction lightcurve of an observation that is not on the centerline of the asteroid track (a \'graze\'), two pieces of information are required:</p><p>1) The asteroid diameter (expressed in km) (enter in this edit box)</p><p>2) The distance (in km) left or right of the asteroid track centerline of the observation position</p></body></html>"))
        self.asteroidSizeLabel.setText(_translate("MainWindow", " asteroid diameter(km):"))
        self.pathOffsetLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>In order to calculate the effect on the underlying diffraction lightcurve of an observation that is not on the centerline of the asteroid track (a \'graze\'), two pieces of information are required:</p><p>1) The asteroid diameter (expressed in km)</p><p>2) The distance (in km) left or right of the asteroid track centerline of the observation position (enter in this edit box)</p></body></html>"))
        self.pathOffsetLabel.setText(_translate("MainWindow", " observation centerline offset(km):"))
        self.starDiameterLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the star being occulted is not point-like but rather has a finite disk, enter its diameter in milli-arcseconds (mas) in this box.</p><p>This value is used, in conjunction with the values entered in the <span style=\" font-weight:600; color:#fc0107;\">dist(AU)</span> box and the <span style=\" font-weight:600; color:#fc0107;\">speed(km/sec)</span> box, to calculate the apparent size of the star at the asteroid distance as a function of time. This is convolved with the diffraction light curve to get the underlying light curve (instantaneous values).</p><p>The underlying lightcurve is what is seen and integrated during the camera exposure time to get the camera response.</p></body></html>"))
        self.starDiameterLabel.setText(_translate("MainWindow", "Star diam(mas):"))
        self.dLimbAngleLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>When the star has a perceptible disk, the angle of the asteroid limb with respect to the direction of motion changes the time duration during which the projected star image passes your observation position and therefore modifies the underlying light curve at that limb edge.</p><p>Angles are entered in degrees with 90 degrees used to reflect a head-on no-graze configuration.</p></body></html>"))
        self.dLimbAngleLabel.setText(_translate("MainWindow", "D limb angle:"))
        self.rLimbAngleLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>When the star has a perceptible disk, the angle of the asteroid limb with respect to the direction of motion changes the time duration during which the projected star image passes your observation position and therefore modifies the underlying light curve at that limb edge.</p><p>Angles are entered in degrees with 90 degrees used to reflect a head-on no-graze configuration.</p></body></html>"))
        self.rLimbAngleLabel.setText(_translate("MainWindow", "R limb angle:"))
        self.markBaselineRegionButton.setText(_translate("MainWindow", "Mark baseline region"))
        self.clearBaselineRegionsButton.setText(_translate("MainWindow", "Clear baseline regions"))
        self.calcStatsFromBaselineRegionsButton.setText(_translate("MainWindow", "Calc baseline mean/sigma/corr coeffs"))
        self.writePlot.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: At the conclusion of error bar calculations, PYOTE automatically writes the main plot to a png file using the name and directory of the just-processed csv file. </p><p>If you want/need to record other versions of that plot, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.<br/></p></body></html>"))
        self.writePlot.setText(_translate("MainWindow", "Write main plot"))
        self.writeBarPlots.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: At the conclusion of error bar calculations, PYOTE automatically writes the error bar plots to appropriately named png files using the name and directory of the just-processed csv file. </p><p>If you want/need to record other versions of those plots, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.</p></body></html>"))
        self.writeBarPlots.setText(_translate("MainWindow", "Write error bar plot"))
        self.writeCSVButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to write the contents of the data table below to a csv file.</p><p>The comment lines from the original input file are preserved.</p><p>The most common use for this function is to capture the result of a successful Manual Timestamp Entry for later use (without the need to again go through the manual timestamp entry procedure). It will also reflect any Block Integration that was applied.</p></body></html>"))
        self.writeCSVButton.setText(_translate("MainWindow", "Write csv file"))
        self.startOver.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button removes any trim that is in effect, clears a solution that may have been found, removes a smoothed reference curve, and removes any D or R region that is showing.</p><p>It does <span style=\" font-weight:600; font-style:italic; color:#fc0107;\">not</span> undo block integration or light curve normalization -- you must reload the light curve file to recover from those procedures.</p></body></html>"))
        self.startOver.setText(_translate("MainWindow", "Start over"))
        self.helpLabelForDataGrid.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking at the left-edge of a data line will cause the corresponding data point in the main display to be highlighted. Only one such point can be high-lighted at a time.</p><p>Clicking a point in the main data plot will cause this data grid to be positioned at that data point with the row shown in red. Clicking anywhere in this row will \'toggle\' the selection of that point, useful when the main data plot is very dense.</p></body></html>"))
        self.helpLabelForDataGrid.setText(_translate("MainWindow", "Right-click this label to get explanation of data grid below:"))
        self.table.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">The data displayed in this table is read from the input file. The Timestamp column in this table will be filled in in response to a successful Manual Timestamp Entry procedure. The results of smoothing and normalization are NOT reflected in this table. The results of a Block Integration ARE reflected in this table.  This policy allows this table to be used as the source when a user requests that a csv file be written, presumably to capture timestamps filled in by Manual Timestamp Entry and a possible Block Integration, thus speeding future re-analysis efforts.</span></p><p><span style=\" font-size:18pt;\">Clicking on a data row (at the extreme left) in this panel will cause the corresponding point to be highlighted in the light curve plot. The highlighted point is shown as a largish yellow dot with a red rim --- it may be hard to see/find, but look for it.</span></p><p><span style=\" font-size:18pt; font-weight:600;\">Clicking on a data cell in a row will select/deselect that point in the primary (dark blue) light curve plot. This is provided as an alternative method to clicking on points in the main light curve plot to select/deslect them.</span></p><p><span style=\" font-size:18pt;\">Note: Clicking on a point in the primary (dark blue) light curve will cause the data row for that point to be selected/positioned.</span></p></body></html>"))
from pyqtgraph import PlotWidget

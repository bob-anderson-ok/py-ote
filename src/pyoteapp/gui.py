# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'pyote.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1904, 1165)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.MinimumExpanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
        MainWindow.setSizePolicy(sizePolicy)
        MainWindow.setMinimumSize(QtCore.QSize(1900, 1000))
        MainWindow.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.centralwidget.sizePolicy().hasHeightForWidth())
        self.centralwidget.setSizePolicy(sizePolicy)
        self.centralwidget.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.centralwidget.setObjectName("centralwidget")
        self.gridLayout_9 = QtWidgets.QGridLayout(self.centralwidget)
        self.gridLayout_9.setObjectName("gridLayout_9")
        self.splitterThree = QtWidgets.QSplitter(self.centralwidget)
        self.splitterThree.setEnabled(True)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.splitterThree.sizePolicy().hasHeightForWidth())
        self.splitterThree.setSizePolicy(sizePolicy)
        self.splitterThree.setOrientation(QtCore.Qt.Vertical)
        self.splitterThree.setHandleWidth(10)
        self.splitterThree.setObjectName("splitterThree")
        self.splitterTwo = QtWidgets.QSplitter(self.splitterThree)
        self.splitterTwo.setOrientation(QtCore.Qt.Horizontal)
        self.splitterTwo.setHandleWidth(10)
        self.splitterTwo.setObjectName("splitterTwo")
        self.layoutWidget = QtWidgets.QWidget(self.splitterTwo)
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout_2.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.gridLayout = QtWidgets.QGridLayout()
        self.gridLayout.setObjectName("gridLayout")
        self.plotHelpButton = QtWidgets.QPushButton(self.layoutWidget)
        self.plotHelpButton.setMaximumSize(QtCore.QSize(150, 16777215))
        self.plotHelpButton.setObjectName("plotHelpButton")
        self.gridLayout.addWidget(self.plotHelpButton, 0, 4, 1, 1)
        self.infoButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.infoButton.sizePolicy().hasHeightForWidth())
        self.infoButton.setSizePolicy(sizePolicy)
        self.infoButton.setAutoDefault(False)
        self.infoButton.setObjectName("infoButton")
        self.gridLayout.addWidget(self.infoButton, 0, 0, 1, 1)
        self.readData = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Maximum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.readData.sizePolicy().hasHeightForWidth())
        self.readData.setSizePolicy(sizePolicy)
        self.readData.setToolTipDuration(-1)
        self.readData.setObjectName("readData")
        self.gridLayout.addWidget(self.readData, 0, 3, 1, 1)
        self.helpButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.helpButton.sizePolicy().hasHeightForWidth())
        self.helpButton.setSizePolicy(sizePolicy)
        self.helpButton.setObjectName("helpButton")
        self.gridLayout.addWidget(self.helpButton, 0, 1, 1, 1)
        self.tutorialButton = QtWidgets.QPushButton(self.layoutWidget)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.tutorialButton.sizePolicy().hasHeightForWidth())
        self.tutorialButton.setSizePolicy(sizePolicy)
        self.tutorialButton.setObjectName("tutorialButton")
        self.gridLayout.addWidget(self.tutorialButton, 0, 2, 1, 1)
        self.verticalLayout_2.addLayout(self.gridLayout)
        self.horizontalLayout_6 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_6.setObjectName("horizontalLayout_6")
        self.tabWidget = QtWidgets.QTabWidget(self.layoutWidget)
        self.tabWidget.setMovable(True)
        self.tabWidget.setObjectName("tabWidget")
        self.tab_2 = QtWidgets.QWidget()
        self.tab_2.setObjectName("tab_2")
        self.gridLayout_8 = QtWidgets.QGridLayout(self.tab_2)
        self.gridLayout_8.setObjectName("gridLayout_8")
        spacerItem = QtWidgets.QSpacerItem(378, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem, 0, 0, 1, 1)
        self.lightcurvesHelpButton = QtWidgets.QPushButton(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.lightcurvesHelpButton.sizePolicy().hasHeightForWidth())
        self.lightcurvesHelpButton.setSizePolicy(sizePolicy)
        self.lightcurvesHelpButton.setMinimumSize(QtCore.QSize(200, 60))
        self.lightcurvesHelpButton.setObjectName("lightcurvesHelpButton")
        self.gridLayout_8.addWidget(self.lightcurvesHelpButton, 0, 1, 1, 2)
        spacerItem1 = QtWidgets.QSpacerItem(296, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem1, 0, 3, 1, 1)
        spacerItem2 = QtWidgets.QSpacerItem(20, 25, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.gridLayout_8.addItem(spacerItem2, 1, 2, 1, 1)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.label_30 = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_30.sizePolicy().hasHeightForWidth())
        self.label_30.setSizePolicy(sizePolicy)
        self.label_30.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.label_30.setTextFormat(QtCore.Qt.PlainText)
        self.label_30.setObjectName("label_30")
        self.horizontalLayout.addWidget(self.label_30)
        spacerItem3 = QtWidgets.QSpacerItem(124, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem3)
        self.label_33 = QtWidgets.QLabel(self.tab_2)
        self.label_33.setMinimumSize(QtCore.QSize(200, 0))
        self.label_33.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.label_33.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_33.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_33.setObjectName("label_33")
        self.horizontalLayout.addWidget(self.label_33)
        self.yOffsetStep10radioButton = QtWidgets.QRadioButton(self.tab_2)
        self.yOffsetStep10radioButton.setChecked(True)
        self.yOffsetStep10radioButton.setObjectName("yOffsetStep10radioButton")
        self.horizontalLayout.addWidget(self.yOffsetStep10radioButton)
        self.yOffsetStep100radioButton = QtWidgets.QRadioButton(self.tab_2)
        self.yOffsetStep100radioButton.setObjectName("yOffsetStep100radioButton")
        self.horizontalLayout.addWidget(self.yOffsetStep100radioButton)
        self.yOffsetStep1000radioButton = QtWidgets.QRadioButton(self.tab_2)
        self.yOffsetStep1000radioButton.setObjectName("yOffsetStep1000radioButton")
        self.horizontalLayout.addWidget(self.yOffsetStep1000radioButton)
        spacerItem4 = QtWidgets.QSpacerItem(140, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem4)
        self.gridLayout_8.addLayout(self.horizontalLayout, 2, 0, 1, 4)
        self.verticalLayout_8 = QtWidgets.QVBoxLayout()
        self.verticalLayout_8.setObjectName("verticalLayout_8")
        self.horizontalLayout_28 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_28.setObjectName("horizontalLayout_28")
        self.label_36 = QtWidgets.QLabel(self.tab_2)
        self.label_36.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_36.setText("")
        self.label_36.setObjectName("label_36")
        self.horizontalLayout_28.addWidget(self.label_36)
        self.targetCheckBox_1 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_1.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_1.setText("")
        self.targetCheckBox_1.setObjectName("targetCheckBox_1")
        self.horizontalLayout_28.addWidget(self.targetCheckBox_1)
        spacerItem5 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_28.addItem(spacerItem5)
        self.referenceCheckBox_1 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_1.setText("")
        self.referenceCheckBox_1.setObjectName("referenceCheckBox_1")
        self.horizontalLayout_28.addWidget(self.referenceCheckBox_1)
        spacerItem6 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_28.addItem(spacerItem6)
        self.showCheckBox_1 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_1.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_1.setText("")
        self.showCheckBox_1.setObjectName("showCheckBox_1")
        self.horizontalLayout_28.addWidget(self.showCheckBox_1)
        self.label_56 = QtWidgets.QLabel(self.tab_2)
        self.label_56.setText("")
        self.label_56.setObjectName("label_56")
        self.horizontalLayout_28.addWidget(self.label_56)
        self.lightcurveTitle_1 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_1.setReadOnly(True)
        self.lightcurveTitle_1.setObjectName("lightcurveTitle_1")
        self.horizontalLayout_28.addWidget(self.lightcurveTitle_1)
        self.colorBlob0 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob0.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob0.setStyleSheet("color: rgb(255, 0, 0)")
        self.colorBlob0.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob0.setLineWidth(20)
        self.colorBlob0.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob0.setObjectName("colorBlob0")
        self.horizontalLayout_28.addWidget(self.colorBlob0)
        self.yOffsetLabel1 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel1.setObjectName("yOffsetLabel1")
        self.horizontalLayout_28.addWidget(self.yOffsetLabel1)
        self.yOffsetSpinBox_1 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_1.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_1.setMinimum(-9999999)
        self.yOffsetSpinBox_1.setMaximum(9999999)
        self.yOffsetSpinBox_1.setSingleStep(10)
        self.yOffsetSpinBox_1.setObjectName("yOffsetSpinBox_1")
        self.horizontalLayout_28.addWidget(self.yOffsetSpinBox_1)
        self.xOffsetLabel1 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel1.setObjectName("xOffsetLabel1")
        self.horizontalLayout_28.addWidget(self.xOffsetLabel1)
        self.xOffsetSpinBox_1 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_1.setEnabled(False)
        self.xOffsetSpinBox_1.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_1.setMinimum(-99999)
        self.xOffsetSpinBox_1.setMaximum(99999)
        self.xOffsetSpinBox_1.setSingleStep(1)
        self.xOffsetSpinBox_1.setObjectName("xOffsetSpinBox_1")
        self.horizontalLayout_28.addWidget(self.xOffsetSpinBox_1)
        self.verticalLayout_8.addLayout(self.horizontalLayout_28)
        self.horizontalLayout_29 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_29.setObjectName("horizontalLayout_29")
        self.label_37 = QtWidgets.QLabel(self.tab_2)
        self.label_37.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_37.setText("")
        self.label_37.setObjectName("label_37")
        self.horizontalLayout_29.addWidget(self.label_37)
        self.targetCheckBox_2 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_2.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_2.setText("")
        self.targetCheckBox_2.setObjectName("targetCheckBox_2")
        self.horizontalLayout_29.addWidget(self.targetCheckBox_2)
        spacerItem7 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_29.addItem(spacerItem7)
        self.referenceCheckBox_2 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_2.setText("")
        self.referenceCheckBox_2.setObjectName("referenceCheckBox_2")
        self.horizontalLayout_29.addWidget(self.referenceCheckBox_2)
        spacerItem8 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_29.addItem(spacerItem8)
        self.showCheckBox_2 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_2.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_2.setText("")
        self.showCheckBox_2.setObjectName("showCheckBox_2")
        self.horizontalLayout_29.addWidget(self.showCheckBox_2)
        self.label_57 = QtWidgets.QLabel(self.tab_2)
        self.label_57.setText("")
        self.label_57.setObjectName("label_57")
        self.horizontalLayout_29.addWidget(self.label_57)
        self.lightcurveTitle_2 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_2.setReadOnly(True)
        self.lightcurveTitle_2.setObjectName("lightcurveTitle_2")
        self.horizontalLayout_29.addWidget(self.lightcurveTitle_2)
        self.colorBlob1 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob1.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob1.setStyleSheet("color: rgb(160,32,255)")
        self.colorBlob1.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob1.setLineWidth(20)
        self.colorBlob1.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob1.setObjectName("colorBlob1")
        self.horizontalLayout_29.addWidget(self.colorBlob1)
        self.yOffsetLabel2 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel2.setObjectName("yOffsetLabel2")
        self.horizontalLayout_29.addWidget(self.yOffsetLabel2)
        self.yOffsetSpinBox_2 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_2.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_2.setMinimum(-9999999)
        self.yOffsetSpinBox_2.setMaximum(9999999)
        self.yOffsetSpinBox_2.setSingleStep(10)
        self.yOffsetSpinBox_2.setObjectName("yOffsetSpinBox_2")
        self.horizontalLayout_29.addWidget(self.yOffsetSpinBox_2)
        self.xOffsetLabel2 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel2.setObjectName("xOffsetLabel2")
        self.horizontalLayout_29.addWidget(self.xOffsetLabel2)
        self.xOffsetSpinBox_2 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_2.setEnabled(False)
        self.xOffsetSpinBox_2.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_2.setMinimum(-99999)
        self.xOffsetSpinBox_2.setMaximum(99999)
        self.xOffsetSpinBox_2.setSingleStep(1)
        self.xOffsetSpinBox_2.setObjectName("xOffsetSpinBox_2")
        self.horizontalLayout_29.addWidget(self.xOffsetSpinBox_2)
        self.verticalLayout_8.addLayout(self.horizontalLayout_29)
        self.horizontalLayout_30 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_30.setObjectName("horizontalLayout_30")
        self.label_40 = QtWidgets.QLabel(self.tab_2)
        self.label_40.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_40.setText("")
        self.label_40.setObjectName("label_40")
        self.horizontalLayout_30.addWidget(self.label_40)
        self.targetCheckBox_3 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_3.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_3.setText("")
        self.targetCheckBox_3.setObjectName("targetCheckBox_3")
        self.horizontalLayout_30.addWidget(self.targetCheckBox_3)
        spacerItem9 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_30.addItem(spacerItem9)
        self.referenceCheckBox_3 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_3.setText("")
        self.referenceCheckBox_3.setObjectName("referenceCheckBox_3")
        self.horizontalLayout_30.addWidget(self.referenceCheckBox_3)
        spacerItem10 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_30.addItem(spacerItem10)
        self.showCheckBox_3 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_3.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_3.setText("")
        self.showCheckBox_3.setObjectName("showCheckBox_3")
        self.horizontalLayout_30.addWidget(self.showCheckBox_3)
        self.label_58 = QtWidgets.QLabel(self.tab_2)
        self.label_58.setText("")
        self.label_58.setObjectName("label_58")
        self.horizontalLayout_30.addWidget(self.label_58)
        self.lightcurveTitle_3 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_3.setReadOnly(True)
        self.lightcurveTitle_3.setObjectName("lightcurveTitle_3")
        self.horizontalLayout_30.addWidget(self.lightcurveTitle_3)
        self.colorBlob2 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob2.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob2.setBaseSize(QtCore.QSize(20, 0))
        self.colorBlob2.setStyleSheet("color: rgb(80,208,255)")
        self.colorBlob2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob2.setLineWidth(20)
        self.colorBlob2.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob2.setObjectName("colorBlob2")
        self.horizontalLayout_30.addWidget(self.colorBlob2)
        self.yOffsetLabel3 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel3.setObjectName("yOffsetLabel3")
        self.horizontalLayout_30.addWidget(self.yOffsetLabel3)
        self.yOffsetSpinBox_3 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_3.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_3.setMinimum(-9999999)
        self.yOffsetSpinBox_3.setMaximum(9999999)
        self.yOffsetSpinBox_3.setSingleStep(10)
        self.yOffsetSpinBox_3.setObjectName("yOffsetSpinBox_3")
        self.horizontalLayout_30.addWidget(self.yOffsetSpinBox_3)
        self.xOffsetLabel3 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel3.setObjectName("xOffsetLabel3")
        self.horizontalLayout_30.addWidget(self.xOffsetLabel3)
        self.xOffsetSpinBox_3 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_3.setEnabled(False)
        self.xOffsetSpinBox_3.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_3.setMinimum(-99999)
        self.xOffsetSpinBox_3.setMaximum(99999)
        self.xOffsetSpinBox_3.setSingleStep(1)
        self.xOffsetSpinBox_3.setObjectName("xOffsetSpinBox_3")
        self.horizontalLayout_30.addWidget(self.xOffsetSpinBox_3)
        self.verticalLayout_8.addLayout(self.horizontalLayout_30)
        self.horizontalLayout_31 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_31.setObjectName("horizontalLayout_31")
        self.label_42 = QtWidgets.QLabel(self.tab_2)
        self.label_42.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_42.setText("")
        self.label_42.setObjectName("label_42")
        self.horizontalLayout_31.addWidget(self.label_42)
        self.targetCheckBox_4 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_4.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_4.setText("")
        self.targetCheckBox_4.setObjectName("targetCheckBox_4")
        self.horizontalLayout_31.addWidget(self.targetCheckBox_4)
        spacerItem11 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_31.addItem(spacerItem11)
        self.referenceCheckBox_4 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_4.setText("")
        self.referenceCheckBox_4.setObjectName("referenceCheckBox_4")
        self.horizontalLayout_31.addWidget(self.referenceCheckBox_4)
        spacerItem12 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_31.addItem(spacerItem12)
        self.showCheckBox_4 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_4.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_4.setText("")
        self.showCheckBox_4.setObjectName("showCheckBox_4")
        self.horizontalLayout_31.addWidget(self.showCheckBox_4)
        self.label_59 = QtWidgets.QLabel(self.tab_2)
        self.label_59.setText("")
        self.label_59.setObjectName("label_59")
        self.horizontalLayout_31.addWidget(self.label_59)
        self.lightcurveTitle_4 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_4.setReadOnly(True)
        self.lightcurveTitle_4.setObjectName("lightcurveTitle_4")
        self.horizontalLayout_31.addWidget(self.lightcurveTitle_4)
        self.colorBlob3 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob3.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob3.setStyleSheet("color: rgb(96,255,128)")
        self.colorBlob3.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob3.setLineWidth(20)
        self.colorBlob3.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob3.setObjectName("colorBlob3")
        self.horizontalLayout_31.addWidget(self.colorBlob3)
        self.yOffsetLabel4 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel4.setObjectName("yOffsetLabel4")
        self.horizontalLayout_31.addWidget(self.yOffsetLabel4)
        self.yOffsetSpinBox_4 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_4.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_4.setMinimum(-9999999)
        self.yOffsetSpinBox_4.setMaximum(9999999)
        self.yOffsetSpinBox_4.setSingleStep(10)
        self.yOffsetSpinBox_4.setObjectName("yOffsetSpinBox_4")
        self.horizontalLayout_31.addWidget(self.yOffsetSpinBox_4)
        self.xOffsetLabel4 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel4.setObjectName("xOffsetLabel4")
        self.horizontalLayout_31.addWidget(self.xOffsetLabel4)
        self.xOffsetSpinBox_4 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_4.setEnabled(False)
        self.xOffsetSpinBox_4.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_4.setMinimum(-99999)
        self.xOffsetSpinBox_4.setMaximum(99999)
        self.xOffsetSpinBox_4.setSingleStep(1)
        self.xOffsetSpinBox_4.setObjectName("xOffsetSpinBox_4")
        self.horizontalLayout_31.addWidget(self.xOffsetSpinBox_4)
        self.verticalLayout_8.addLayout(self.horizontalLayout_31)
        self.horizontalLayout_32 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_32.setObjectName("horizontalLayout_32")
        self.label_44 = QtWidgets.QLabel(self.tab_2)
        self.label_44.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_44.setText("")
        self.label_44.setObjectName("label_44")
        self.horizontalLayout_32.addWidget(self.label_44)
        self.targetCheckBox_5 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_5.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_5.setText("")
        self.targetCheckBox_5.setObjectName("targetCheckBox_5")
        self.horizontalLayout_32.addWidget(self.targetCheckBox_5)
        spacerItem13 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_32.addItem(spacerItem13)
        self.referenceCheckBox_5 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_5.setText("")
        self.referenceCheckBox_5.setObjectName("referenceCheckBox_5")
        self.horizontalLayout_32.addWidget(self.referenceCheckBox_5)
        spacerItem14 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_32.addItem(spacerItem14)
        self.showCheckBox_5 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_5.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_5.setText("")
        self.showCheckBox_5.setObjectName("showCheckBox_5")
        self.horizontalLayout_32.addWidget(self.showCheckBox_5)
        self.label_60 = QtWidgets.QLabel(self.tab_2)
        self.label_60.setText("")
        self.label_60.setObjectName("label_60")
        self.horizontalLayout_32.addWidget(self.label_60)
        self.lightcurveTitle_5 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_5.setReadOnly(True)
        self.lightcurveTitle_5.setObjectName("lightcurveTitle_5")
        self.horizontalLayout_32.addWidget(self.lightcurveTitle_5)
        self.colorBlob4 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob4.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob4.setStyleSheet("color: rgb(255,224,32)")
        self.colorBlob4.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob4.setLineWidth(20)
        self.colorBlob4.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob4.setObjectName("colorBlob4")
        self.horizontalLayout_32.addWidget(self.colorBlob4)
        self.yOffsetLabel5 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel5.setObjectName("yOffsetLabel5")
        self.horizontalLayout_32.addWidget(self.yOffsetLabel5)
        self.yOffsetSpinBox_5 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_5.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_5.setMinimum(-9999999)
        self.yOffsetSpinBox_5.setMaximum(9999999)
        self.yOffsetSpinBox_5.setSingleStep(10)
        self.yOffsetSpinBox_5.setObjectName("yOffsetSpinBox_5")
        self.horizontalLayout_32.addWidget(self.yOffsetSpinBox_5)
        self.xOffsetLabel5 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel5.setObjectName("xOffsetLabel5")
        self.horizontalLayout_32.addWidget(self.xOffsetLabel5)
        self.xOffsetSpinBox_5 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_5.setEnabled(False)
        self.xOffsetSpinBox_5.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_5.setMinimum(-99999)
        self.xOffsetSpinBox_5.setMaximum(99999)
        self.xOffsetSpinBox_5.setSingleStep(1)
        self.xOffsetSpinBox_5.setObjectName("xOffsetSpinBox_5")
        self.horizontalLayout_32.addWidget(self.xOffsetSpinBox_5)
        self.verticalLayout_8.addLayout(self.horizontalLayout_32)
        self.horizontalLayout_33 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_33.setObjectName("horizontalLayout_33")
        self.label_46 = QtWidgets.QLabel(self.tab_2)
        self.label_46.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_46.setText("")
        self.label_46.setObjectName("label_46")
        self.horizontalLayout_33.addWidget(self.label_46)
        self.targetCheckBox_6 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_6.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_6.setText("")
        self.targetCheckBox_6.setObjectName("targetCheckBox_6")
        self.horizontalLayout_33.addWidget(self.targetCheckBox_6)
        spacerItem15 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_33.addItem(spacerItem15)
        self.referenceCheckBox_6 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_6.setText("")
        self.referenceCheckBox_6.setObjectName("referenceCheckBox_6")
        self.horizontalLayout_33.addWidget(self.referenceCheckBox_6)
        spacerItem16 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_33.addItem(spacerItem16)
        self.showCheckBox_6 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_6.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_6.setText("")
        self.showCheckBox_6.setObjectName("showCheckBox_6")
        self.horizontalLayout_33.addWidget(self.showCheckBox_6)
        self.label_61 = QtWidgets.QLabel(self.tab_2)
        self.label_61.setText("")
        self.label_61.setObjectName("label_61")
        self.horizontalLayout_33.addWidget(self.label_61)
        self.lightcurveTitle_6 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_6.setReadOnly(True)
        self.lightcurveTitle_6.setObjectName("lightcurveTitle_6")
        self.horizontalLayout_33.addWidget(self.lightcurveTitle_6)
        self.colorBlob5 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob5.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob5.setStyleSheet("color: rgb(255,160,16)")
        self.colorBlob5.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob5.setLineWidth(29)
        self.colorBlob5.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob5.setObjectName("colorBlob5")
        self.horizontalLayout_33.addWidget(self.colorBlob5)
        self.yOffsetLabel6 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel6.setObjectName("yOffsetLabel6")
        self.horizontalLayout_33.addWidget(self.yOffsetLabel6)
        self.yOffsetSpinBox_6 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_6.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_6.setMinimum(-9999999)
        self.yOffsetSpinBox_6.setMaximum(9999999)
        self.yOffsetSpinBox_6.setSingleStep(10)
        self.yOffsetSpinBox_6.setObjectName("yOffsetSpinBox_6")
        self.horizontalLayout_33.addWidget(self.yOffsetSpinBox_6)
        self.xOffsetLabel6 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel6.setObjectName("xOffsetLabel6")
        self.horizontalLayout_33.addWidget(self.xOffsetLabel6)
        self.xOffsetSpinBox_6 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_6.setEnabled(False)
        self.xOffsetSpinBox_6.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_6.setMinimum(-99999)
        self.xOffsetSpinBox_6.setMaximum(99999)
        self.xOffsetSpinBox_6.setSingleStep(1)
        self.xOffsetSpinBox_6.setObjectName("xOffsetSpinBox_6")
        self.horizontalLayout_33.addWidget(self.xOffsetSpinBox_6)
        self.verticalLayout_8.addLayout(self.horizontalLayout_33)
        self.horizontalLayout_34 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_34.setObjectName("horizontalLayout_34")
        self.label_48 = QtWidgets.QLabel(self.tab_2)
        self.label_48.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_48.setText("")
        self.label_48.setObjectName("label_48")
        self.horizontalLayout_34.addWidget(self.label_48)
        self.targetCheckBox_7 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_7.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_7.setText("")
        self.targetCheckBox_7.setObjectName("targetCheckBox_7")
        self.horizontalLayout_34.addWidget(self.targetCheckBox_7)
        spacerItem17 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_34.addItem(spacerItem17)
        self.referenceCheckBox_7 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_7.setText("")
        self.referenceCheckBox_7.setObjectName("referenceCheckBox_7")
        self.horizontalLayout_34.addWidget(self.referenceCheckBox_7)
        spacerItem18 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_34.addItem(spacerItem18)
        self.showCheckBox_7 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_7.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_7.setText("")
        self.showCheckBox_7.setObjectName("showCheckBox_7")
        self.horizontalLayout_34.addWidget(self.showCheckBox_7)
        self.label_62 = QtWidgets.QLabel(self.tab_2)
        self.label_62.setText("")
        self.label_62.setObjectName("label_62")
        self.horizontalLayout_34.addWidget(self.label_62)
        self.lightcurveTitle_7 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_7.setReadOnly(True)
        self.lightcurveTitle_7.setObjectName("lightcurveTitle_7")
        self.horizontalLayout_34.addWidget(self.lightcurveTitle_7)
        self.colorBlob6 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob6.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob6.setStyleSheet("color: rgb(160,128,96)")
        self.colorBlob6.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob6.setLineWidth(20)
        self.colorBlob6.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob6.setObjectName("colorBlob6")
        self.horizontalLayout_34.addWidget(self.colorBlob6)
        self.yOffsetLabel7 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel7.setObjectName("yOffsetLabel7")
        self.horizontalLayout_34.addWidget(self.yOffsetLabel7)
        self.yOffsetSpinBox_7 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_7.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_7.setMinimum(-9999999)
        self.yOffsetSpinBox_7.setMaximum(9999999)
        self.yOffsetSpinBox_7.setSingleStep(10)
        self.yOffsetSpinBox_7.setObjectName("yOffsetSpinBox_7")
        self.horizontalLayout_34.addWidget(self.yOffsetSpinBox_7)
        self.xOffsetLabel7 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel7.setObjectName("xOffsetLabel7")
        self.horizontalLayout_34.addWidget(self.xOffsetLabel7)
        self.xOffsetSpinBox_7 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_7.setEnabled(False)
        self.xOffsetSpinBox_7.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_7.setMinimum(-99999)
        self.xOffsetSpinBox_7.setMaximum(99999)
        self.xOffsetSpinBox_7.setSingleStep(1)
        self.xOffsetSpinBox_7.setObjectName("xOffsetSpinBox_7")
        self.horizontalLayout_34.addWidget(self.xOffsetSpinBox_7)
        self.verticalLayout_8.addLayout(self.horizontalLayout_34)
        self.horizontalLayout_35 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_35.setObjectName("horizontalLayout_35")
        self.label_50 = QtWidgets.QLabel(self.tab_2)
        self.label_50.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_50.setText("")
        self.label_50.setObjectName("label_50")
        self.horizontalLayout_35.addWidget(self.label_50)
        self.targetCheckBox_8 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_8.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_8.setText("")
        self.targetCheckBox_8.setObjectName("targetCheckBox_8")
        self.horizontalLayout_35.addWidget(self.targetCheckBox_8)
        spacerItem19 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_35.addItem(spacerItem19)
        self.referenceCheckBox_8 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_8.setText("")
        self.referenceCheckBox_8.setObjectName("referenceCheckBox_8")
        self.horizontalLayout_35.addWidget(self.referenceCheckBox_8)
        spacerItem20 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_35.addItem(spacerItem20)
        self.showCheckBox_8 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_8.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_8.setText("")
        self.showCheckBox_8.setObjectName("showCheckBox_8")
        self.horizontalLayout_35.addWidget(self.showCheckBox_8)
        self.label_63 = QtWidgets.QLabel(self.tab_2)
        self.label_63.setText("")
        self.label_63.setObjectName("label_63")
        self.horizontalLayout_35.addWidget(self.label_63)
        self.lightcurveTitle_8 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_8.setReadOnly(True)
        self.lightcurveTitle_8.setObjectName("lightcurveTitle_8")
        self.horizontalLayout_35.addWidget(self.lightcurveTitle_8)
        self.colorBlob7 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob7.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob7.setStyleSheet("color: rgb(64,64,64)")
        self.colorBlob7.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob7.setLineWidth(20)
        self.colorBlob7.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob7.setObjectName("colorBlob7")
        self.horizontalLayout_35.addWidget(self.colorBlob7)
        self.yOffsetLabel8 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel8.setObjectName("yOffsetLabel8")
        self.horizontalLayout_35.addWidget(self.yOffsetLabel8)
        self.yOffsetSpinBox_8 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_8.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_8.setMinimum(-9999999)
        self.yOffsetSpinBox_8.setMaximum(9999999)
        self.yOffsetSpinBox_8.setSingleStep(10)
        self.yOffsetSpinBox_8.setObjectName("yOffsetSpinBox_8")
        self.horizontalLayout_35.addWidget(self.yOffsetSpinBox_8)
        self.xOffsetLabel8 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel8.setObjectName("xOffsetLabel8")
        self.horizontalLayout_35.addWidget(self.xOffsetLabel8)
        self.xOffsetSpinBox_8 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_8.setEnabled(False)
        self.xOffsetSpinBox_8.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_8.setMinimum(-99999)
        self.xOffsetSpinBox_8.setMaximum(99999)
        self.xOffsetSpinBox_8.setSingleStep(1)
        self.xOffsetSpinBox_8.setObjectName("xOffsetSpinBox_8")
        self.horizontalLayout_35.addWidget(self.xOffsetSpinBox_8)
        self.verticalLayout_8.addLayout(self.horizontalLayout_35)
        self.horizontalLayout_36 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_36.setObjectName("horizontalLayout_36")
        self.label_52 = QtWidgets.QLabel(self.tab_2)
        self.label_52.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_52.setText("")
        self.label_52.setObjectName("label_52")
        self.horizontalLayout_36.addWidget(self.label_52)
        self.targetCheckBox_9 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_9.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_9.setText("")
        self.targetCheckBox_9.setObjectName("targetCheckBox_9")
        self.horizontalLayout_36.addWidget(self.targetCheckBox_9)
        spacerItem21 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_36.addItem(spacerItem21)
        self.referenceCheckBox_9 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_9.setText("")
        self.referenceCheckBox_9.setObjectName("referenceCheckBox_9")
        self.horizontalLayout_36.addWidget(self.referenceCheckBox_9)
        spacerItem22 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_36.addItem(spacerItem22)
        self.showCheckBox_9 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_9.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_9.setText("")
        self.showCheckBox_9.setObjectName("showCheckBox_9")
        self.horizontalLayout_36.addWidget(self.showCheckBox_9)
        self.label_64 = QtWidgets.QLabel(self.tab_2)
        self.label_64.setText("")
        self.label_64.setObjectName("label_64")
        self.horizontalLayout_36.addWidget(self.label_64)
        self.lightcurveTitle_9 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_9.setReadOnly(True)
        self.lightcurveTitle_9.setObjectName("lightcurveTitle_9")
        self.horizontalLayout_36.addWidget(self.lightcurveTitle_9)
        self.colorBlob8 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob8.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob8.setStyleSheet("color: rgb(255,208,160)")
        self.colorBlob8.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob8.setLineWidth(20)
        self.colorBlob8.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob8.setObjectName("colorBlob8")
        self.horizontalLayout_36.addWidget(self.colorBlob8)
        self.yOffsetLabel9 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel9.setObjectName("yOffsetLabel9")
        self.horizontalLayout_36.addWidget(self.yOffsetLabel9)
        self.yOffsetSpinBox_9 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_9.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_9.setMinimum(-9999999)
        self.yOffsetSpinBox_9.setMaximum(9999999)
        self.yOffsetSpinBox_9.setSingleStep(10)
        self.yOffsetSpinBox_9.setObjectName("yOffsetSpinBox_9")
        self.horizontalLayout_36.addWidget(self.yOffsetSpinBox_9)
        self.xOffsetLabel9 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel9.setObjectName("xOffsetLabel9")
        self.horizontalLayout_36.addWidget(self.xOffsetLabel9)
        self.xOffsetSpinBox_9 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_9.setEnabled(False)
        self.xOffsetSpinBox_9.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_9.setMinimum(-99999)
        self.xOffsetSpinBox_9.setMaximum(99999)
        self.xOffsetSpinBox_9.setSingleStep(1)
        self.xOffsetSpinBox_9.setObjectName("xOffsetSpinBox_9")
        self.horizontalLayout_36.addWidget(self.xOffsetSpinBox_9)
        self.verticalLayout_8.addLayout(self.horizontalLayout_36)
        self.horizontalLayout_37 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_37.setObjectName("horizontalLayout_37")
        self.label_54 = QtWidgets.QLabel(self.tab_2)
        self.label_54.setMaximumSize(QtCore.QSize(8, 16777215))
        self.label_54.setText("")
        self.label_54.setObjectName("label_54")
        self.horizontalLayout_37.addWidget(self.label_54)
        self.targetCheckBox_10 = QtWidgets.QCheckBox(self.tab_2)
        self.targetCheckBox_10.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.targetCheckBox_10.setText("")
        self.targetCheckBox_10.setObjectName("targetCheckBox_10")
        self.horizontalLayout_37.addWidget(self.targetCheckBox_10)
        spacerItem23 = QtWidgets.QSpacerItem(20, 20, QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_37.addItem(spacerItem23)
        self.referenceCheckBox_10 = QtWidgets.QCheckBox(self.tab_2)
        self.referenceCheckBox_10.setText("")
        self.referenceCheckBox_10.setObjectName("referenceCheckBox_10")
        self.horizontalLayout_37.addWidget(self.referenceCheckBox_10)
        spacerItem24 = QtWidgets.QSpacerItem(30, 20, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_37.addItem(spacerItem24)
        self.showCheckBox_10 = QtWidgets.QCheckBox(self.tab_2)
        self.showCheckBox_10.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.showCheckBox_10.setText("")
        self.showCheckBox_10.setObjectName("showCheckBox_10")
        self.horizontalLayout_37.addWidget(self.showCheckBox_10)
        self.label_65 = QtWidgets.QLabel(self.tab_2)
        self.label_65.setText("")
        self.label_65.setObjectName("label_65")
        self.horizontalLayout_37.addWidget(self.label_65)
        self.lightcurveTitle_10 = QtWidgets.QLineEdit(self.tab_2)
        self.lightcurveTitle_10.setReadOnly(True)
        self.lightcurveTitle_10.setObjectName("lightcurveTitle_10")
        self.horizontalLayout_37.addWidget(self.lightcurveTitle_10)
        self.colorBlob9 = QtWidgets.QFrame(self.tab_2)
        self.colorBlob9.setMinimumSize(QtCore.QSize(20, 0))
        self.colorBlob9.setStyleSheet("color: rgb(0,128,0)")
        self.colorBlob9.setFrameShadow(QtWidgets.QFrame.Plain)
        self.colorBlob9.setLineWidth(20)
        self.colorBlob9.setFrameShape(QtWidgets.QFrame.VLine)
        self.colorBlob9.setObjectName("colorBlob9")
        self.horizontalLayout_37.addWidget(self.colorBlob9)
        self.yOffsetLabel10 = QtWidgets.QLabel(self.tab_2)
        self.yOffsetLabel10.setObjectName("yOffsetLabel10")
        self.horizontalLayout_37.addWidget(self.yOffsetLabel10)
        self.yOffsetSpinBox_10 = QtWidgets.QSpinBox(self.tab_2)
        self.yOffsetSpinBox_10.setMinimumSize(QtCore.QSize(80, 0))
        self.yOffsetSpinBox_10.setMinimum(-9999999)
        self.yOffsetSpinBox_10.setMaximum(9999999)
        self.yOffsetSpinBox_10.setSingleStep(10)
        self.yOffsetSpinBox_10.setObjectName("yOffsetSpinBox_10")
        self.horizontalLayout_37.addWidget(self.yOffsetSpinBox_10)
        self.xOffsetLabel10 = QtWidgets.QLabel(self.tab_2)
        self.xOffsetLabel10.setObjectName("xOffsetLabel10")
        self.horizontalLayout_37.addWidget(self.xOffsetLabel10)
        self.xOffsetSpinBox_10 = QtWidgets.QSpinBox(self.tab_2)
        self.xOffsetSpinBox_10.setEnabled(False)
        self.xOffsetSpinBox_10.setMinimumSize(QtCore.QSize(80, 0))
        self.xOffsetSpinBox_10.setMinimum(-99999)
        self.xOffsetSpinBox_10.setMaximum(99999)
        self.xOffsetSpinBox_10.setSingleStep(1)
        self.xOffsetSpinBox_10.setObjectName("xOffsetSpinBox_10")
        self.horizontalLayout_37.addWidget(self.xOffsetSpinBox_10)
        self.verticalLayout_8.addLayout(self.horizontalLayout_37)
        self.gridLayout_8.addLayout(self.verticalLayout_8, 3, 0, 1, 4)
        spacerItem25 = QtWidgets.QSpacerItem(143, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem25, 3, 4, 1, 1)
        spacerItem26 = QtWidgets.QSpacerItem(20, 13, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        self.gridLayout_8.addItem(spacerItem26, 4, 0, 1, 1)
        spacerItem27 = QtWidgets.QSpacerItem(133, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_8.addItem(spacerItem27, 5, 4, 1, 1)
        spacerItem28 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_8.addItem(spacerItem28, 6, 1, 1, 1)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.smoothingLabel = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.smoothingLabel.sizePolicy().hasHeightForWidth())
        self.smoothingLabel.setSizePolicy(sizePolicy)
        self.smoothingLabel.setMinimumSize(QtCore.QSize(0, 0))
        self.smoothingLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.smoothingLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.smoothingLabel.setObjectName("smoothingLabel")
        self.horizontalLayout_2.addWidget(self.smoothingLabel)
        self.smoothingIntervalSpinBox = QtWidgets.QSpinBox(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.smoothingIntervalSpinBox.sizePolicy().hasHeightForWidth())
        self.smoothingIntervalSpinBox.setSizePolicy(sizePolicy)
        self.smoothingIntervalSpinBox.setMinimumSize(QtCore.QSize(60, 0))
        self.smoothingIntervalSpinBox.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.smoothingIntervalSpinBox.setMaximum(9999)
        self.smoothingIntervalSpinBox.setSingleStep(2)
        self.smoothingIntervalSpinBox.setObjectName("smoothingIntervalSpinBox")
        self.horizontalLayout_2.addWidget(self.smoothingIntervalSpinBox)
        self.label_32 = QtWidgets.QLabel(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label_32.sizePolicy().hasHeightForWidth())
        self.label_32.setSizePolicy(sizePolicy)
        self.label_32.setMinimumSize(QtCore.QSize(100, 0))
        self.label_32.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.label_32.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.label_32.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.label_32.setObjectName("label_32")
        self.horizontalLayout_2.addWidget(self.label_32)
        self.stepBy2radioButton = QtWidgets.QRadioButton(self.tab_2)
        self.stepBy2radioButton.setChecked(True)
        self.stepBy2radioButton.setObjectName("stepBy2radioButton")
        self.horizontalLayout_2.addWidget(self.stepBy2radioButton)
        self.stepBy10radioButton = QtWidgets.QRadioButton(self.tab_2)
        self.stepBy10radioButton.setObjectName("stepBy10radioButton")
        self.horizontalLayout_2.addWidget(self.stepBy10radioButton)
        self.stepBy100radioButton = QtWidgets.QRadioButton(self.tab_2)
        self.stepBy100radioButton.setObjectName("stepBy100radioButton")
        self.horizontalLayout_2.addWidget(self.stepBy100radioButton)
        spacerItem29 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_2.addItem(spacerItem29)
        self.normMarkBaselineRegionButton = QtWidgets.QPushButton(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.normMarkBaselineRegionButton.sizePolicy().hasHeightForWidth())
        self.normMarkBaselineRegionButton.setSizePolicy(sizePolicy)
        self.normMarkBaselineRegionButton.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.normMarkBaselineRegionButton.setObjectName("normMarkBaselineRegionButton")
        self.horizontalLayout_2.addWidget(self.normMarkBaselineRegionButton)
        self.clearMetricPointsButton = QtWidgets.QPushButton(self.tab_2)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.clearMetricPointsButton.sizePolicy().hasHeightForWidth())
        self.clearMetricPointsButton.setSizePolicy(sizePolicy)
        self.clearMetricPointsButton.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.clearMetricPointsButton.setObjectName("clearMetricPointsButton")
        self.horizontalLayout_2.addWidget(self.clearMetricPointsButton)
        self.gridLayout_8.addLayout(self.horizontalLayout_2, 5, 0, 1, 4)
        self.tabWidget.addTab(self.tab_2, "")
        self.analysisTab = QtWidgets.QWidget()
        self.analysisTab.setObjectName("analysisTab")
        self.gridLayout_4 = QtWidgets.QGridLayout(self.analysisTab)
        self.gridLayout_4.setObjectName("gridLayout_4")
        self.line_3 = QtWidgets.QFrame(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.line_3.sizePolicy().hasHeightForWidth())
        self.line_3.setSizePolicy(sizePolicy)
        self.line_3.setMinimumSize(QtCore.QSize(0, 0))
        self.line_3.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_3.setLineWidth(5)
        self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_3.setObjectName("line_3")
        self.gridLayout_4.addWidget(self.line_3, 4, 1, 1, 3)
        self.horizontalLayout_12 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_12.setObjectName("horizontalLayout_12")
        self.horizontalLayout_10 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_10.setObjectName("horizontalLayout_10")
        spacerItem30 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_10.addItem(spacerItem30)
        self.minEventLabel = QtWidgets.QLabel(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventLabel.sizePolicy().hasHeightForWidth())
        self.minEventLabel.setSizePolicy(sizePolicy)
        self.minEventLabel.setMinimumSize(QtCore.QSize(50, 0))
        self.minEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.minEventLabel.setObjectName("minEventLabel")
        self.horizontalLayout_10.addWidget(self.minEventLabel)
        self.minEventEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.minEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.minEventEdit.sizePolicy().hasHeightForWidth())
        self.minEventEdit.setSizePolicy(sizePolicy)
        self.minEventEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.minEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.minEventEdit.setObjectName("minEventEdit")
        self.horizontalLayout_10.addWidget(self.minEventEdit)
        self.horizontalLayout_12.addLayout(self.horizontalLayout_10)
        spacerItem31 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_12.addItem(spacerItem31)
        self.horizontalLayout_11 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_11.setObjectName("horizontalLayout_11")
        self.maxEventLabel = QtWidgets.QLabel(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventLabel.sizePolicy().hasHeightForWidth())
        self.maxEventLabel.setSizePolicy(sizePolicy)
        self.maxEventLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.maxEventLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.maxEventLabel.setObjectName("maxEventLabel")
        self.horizontalLayout_11.addWidget(self.maxEventLabel)
        self.maxEventEdit = QtWidgets.QLineEdit(self.analysisTab)
        self.maxEventEdit.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.maxEventEdit.sizePolicy().hasHeightForWidth())
        self.maxEventEdit.setSizePolicy(sizePolicy)
        self.maxEventEdit.setMaximumSize(QtCore.QSize(70, 16777215))
        self.maxEventEdit.setObjectName("maxEventEdit")
        self.horizontalLayout_11.addWidget(self.maxEventEdit)
        spacerItem32 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_11.addItem(spacerItem32)
        self.horizontalLayout_12.addLayout(self.horizontalLayout_11)
        self.gridLayout_4.addLayout(self.horizontalLayout_12, 8, 1, 1, 2)
        self.horizontalLayout_3 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_3.setObjectName("horizontalLayout_3")
        self.markDzone = QtWidgets.QPushButton(self.analysisTab)
        self.markDzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markDzone.sizePolicy().hasHeightForWidth())
        self.markDzone.setSizePolicy(sizePolicy)
        self.markDzone.setObjectName("markDzone")
        self.horizontalLayout_3.addWidget(self.markDzone)
        self.markRzone = QtWidgets.QPushButton(self.analysisTab)
        self.markRzone.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.markRzone.sizePolicy().hasHeightForWidth())
        self.markRzone.setSizePolicy(sizePolicy)
        self.markRzone.setObjectName("markRzone")
        self.horizontalLayout_3.addWidget(self.markRzone)
        self.markEzone = QtWidgets.QPushButton(self.analysisTab)
        self.markEzone.setEnabled(False)
        self.markEzone.setObjectName("markEzone")
        self.horizontalLayout_3.addWidget(self.markEzone)
        self.gridLayout_4.addLayout(self.horizontalLayout_3, 6, 1, 1, 1)
        self.verticalLayout_6 = QtWidgets.QVBoxLayout()
        self.verticalLayout_6.setContentsMargins(0, -1, -1, -1)
        self.verticalLayout_6.setObjectName("verticalLayout_6")
        self.doBlockIntegration = QtWidgets.QPushButton(self.analysisTab)
        self.doBlockIntegration.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.doBlockIntegration.sizePolicy().hasHeightForWidth())
        self.doBlockIntegration.setSizePolicy(sizePolicy)
        self.doBlockIntegration.setObjectName("doBlockIntegration")
        self.verticalLayout_6.addWidget(self.doBlockIntegration)
        self.acceptBlockIntegration = QtWidgets.QPushButton(self.analysisTab)
        self.acceptBlockIntegration.setEnabled(False)
        self.acceptBlockIntegration.setObjectName("acceptBlockIntegration")
        self.verticalLayout_6.addWidget(self.acceptBlockIntegration)
        self.setDataLimits = QtWidgets.QPushButton(self.analysisTab)
        self.setDataLimits.setEnabled(False)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.setDataLimits.sizePolicy().hasHeightForWidth())
        self.setDataLimits.setSizePolicy(sizePolicy)
        self.setDataLimits.setToolTipDuration(-1)
        self.setDataLimits.setObjectName("setDataLimits")
        self.verticalLayout_6.addWidget(self.setDataLimits)
        self.gridLayout_4.addLayout(self.verticalLayout_6, 1, 1, 1, 1)
        self.line = QtWidgets.QFrame(self.analysisTab)
        self.line.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line.setLineWidth(4)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setObjectName("line")
        self.gridLayout_4.addWidget(self.line, 2, 1, 1, 3)
        spacerItem33 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem33, 15, 3, 1, 1)
        self.markRegionsLabel = QtWidgets.QLabel(self.analysisTab)
        self.markRegionsLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.markRegionsLabel.setObjectName("markRegionsLabel")
        self.gridLayout_4.addWidget(self.markRegionsLabel, 5, 1, 1, 1)
        self.minMaxLabel = QtWidgets.QLabel(self.analysisTab)
        self.minMaxLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.minMaxLabel.setObjectName("minMaxLabel")
        self.gridLayout_4.addWidget(self.minMaxLabel, 7, 1, 1, 1)
        spacerItem34 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem34, 8, 0, 1, 1)
        spacerItem35 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_4.addItem(spacerItem35, 8, 4, 1, 1)
        spacerItem36 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_4.addItem(spacerItem36, 0, 2, 1, 1)
        self.line_2 = QtWidgets.QFrame(self.analysisTab)
        self.line_2.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_2.setLineWidth(4)
        self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_2.setObjectName("line_2")
        self.gridLayout_4.addWidget(self.line_2, 9, 1, 1, 3)
        self.findEventLabel = QtWidgets.QLabel(self.analysisTab)
        self.findEventLabel.setAlignment(QtCore.Qt.AlignCenter)
        self.findEventLabel.setObjectName("findEventLabel")
        self.gridLayout_4.addWidget(self.findEventLabel, 10, 1, 1, 1)
        self.line_6 = QtWidgets.QFrame(self.analysisTab)
        self.line_6.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_6.setLineWidth(4)
        self.line_6.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_6.setObjectName("line_6")
        self.gridLayout_4.addWidget(self.line_6, 13, 1, 1, 3)
        self.horizontalLayout_4 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_4.setObjectName("horizontalLayout_4")
        self.locateEvent = QtWidgets.QPushButton(self.analysisTab)
        self.locateEvent.setEnabled(False)
        self.locateEvent.setObjectName("locateEvent")
        self.horizontalLayout_4.addWidget(self.locateEvent)
        self.calcErrBars = QtWidgets.QPushButton(self.analysisTab)
        self.calcErrBars.setEnabled(False)
        self.calcErrBars.setObjectName("calcErrBars")
        self.horizontalLayout_4.addWidget(self.calcErrBars)
        self.helpLabelForFalsePositive = QtWidgets.QLabel(self.analysisTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.helpLabelForFalsePositive.sizePolicy().hasHeightForWidth())
        self.helpLabelForFalsePositive.setSizePolicy(sizePolicy)
        self.helpLabelForFalsePositive.setMinimumSize(QtCore.QSize(10, 0))
        self.helpLabelForFalsePositive.setText("")
        self.helpLabelForFalsePositive.setObjectName("helpLabelForFalsePositive")
        self.horizontalLayout_4.addWidget(self.helpLabelForFalsePositive)
        self.fillExcelReportButton = QtWidgets.QPushButton(self.analysisTab)
        self.fillExcelReportButton.setEnabled(False)
        self.fillExcelReportButton.setObjectName("fillExcelReportButton")
        self.horizontalLayout_4.addWidget(self.fillExcelReportButton)
        self.gridLayout_4.addLayout(self.horizontalLayout_4, 11, 1, 1, 2)
        self.horizontalLayout_7 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_7.setObjectName("horizontalLayout_7")
        self.progressBar = QtWidgets.QProgressBar(self.analysisTab)
        self.progressBar.setProperty("value", 0)
        self.progressBar.setObjectName("progressBar")
        self.horizontalLayout_7.addWidget(self.progressBar)
        self.cancelButton = QtWidgets.QPushButton(self.analysisTab)
        self.cancelButton.setObjectName("cancelButton")
        self.horizontalLayout_7.addWidget(self.cancelButton)
        self.gridLayout_4.addLayout(self.horizontalLayout_7, 12, 1, 1, 1)
        self.verticalLayout_5 = QtWidgets.QVBoxLayout()
        self.verticalLayout_5.setObjectName("verticalLayout_5")
        self.horizontalLayout_5 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_5.setObjectName("horizontalLayout_5")
        self.writePlot = QtWidgets.QPushButton(self.analysisTab)
        self.writePlot.setEnabled(False)
        self.writePlot.setObjectName("writePlot")
        self.horizontalLayout_5.addWidget(self.writePlot)
        self.writeBarPlots = QtWidgets.QPushButton(self.analysisTab)
        self.writeBarPlots.setEnabled(False)
        self.writeBarPlots.setObjectName("writeBarPlots")
        self.horizontalLayout_5.addWidget(self.writeBarPlots)
        self.writeCSVButton = QtWidgets.QPushButton(self.analysisTab)
        self.writeCSVButton.setEnabled(False)
        self.writeCSVButton.setObjectName("writeCSVButton")
        self.horizontalLayout_5.addWidget(self.writeCSVButton)
        self.verticalLayout_5.addLayout(self.horizontalLayout_5)
        self.startOver = QtWidgets.QPushButton(self.analysisTab)
        self.startOver.setEnabled(False)
        self.startOver.setObjectName("startOver")
        self.verticalLayout_5.addWidget(self.startOver)
        self.gridLayout_4.addLayout(self.verticalLayout_5, 14, 1, 1, 3)
        self.singlePointDropButton = QtWidgets.QPushButton(self.analysisTab)
        self.singlePointDropButton.setEnabled(False)
        self.singlePointDropButton.setObjectName("singlePointDropButton")
        self.gridLayout_4.addWidget(self.singlePointDropButton, 3, 1, 1, 1)
        self.tabWidget.addTab(self.analysisTab, "")
        self.diffractionTab = QtWidgets.QWidget()
        self.diffractionTab.setObjectName("diffractionTab")
        self.gridLayout_7 = QtWidgets.QGridLayout(self.diffractionTab)
        self.gridLayout_7.setObjectName("gridLayout_7")
        spacerItem37 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_7.addItem(spacerItem37, 0, 1, 1, 1)
        self.underlyingLightcurveLabel = QtWidgets.QLabel(self.diffractionTab)
        self.underlyingLightcurveLabel.setAlignment(QtCore.Qt.AlignLeading|QtCore.Qt.AlignLeft|QtCore.Qt.AlignVCenter)
        self.underlyingLightcurveLabel.setObjectName("underlyingLightcurveLabel")
        self.gridLayout_7.addWidget(self.underlyingLightcurveLabel, 1, 1, 1, 2)
        self.line_7 = QtWidgets.QFrame(self.diffractionTab)
        self.line_7.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_7.setLineWidth(4)
        self.line_7.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_7.setObjectName("line_7")
        self.gridLayout_7.addWidget(self.line_7, 2, 1, 1, 2)
        spacerItem38 = QtWidgets.QSpacerItem(51, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem38, 3, 0, 1, 1)
        self.horizontalLayout_13 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_13.setObjectName("horizontalLayout_13")
        self.exposureTimeLabel = QtWidgets.QLabel(self.diffractionTab)
        self.exposureTimeLabel.setObjectName("exposureTimeLabel")
        self.horizontalLayout_13.addWidget(self.exposureTimeLabel)
        self.expDurEdit = QtWidgets.QLineEdit(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.expDurEdit.sizePolicy().hasHeightForWidth())
        self.expDurEdit.setSizePolicy(sizePolicy)
        self.expDurEdit.setMaximumSize(QtCore.QSize(90, 16777215))
        self.expDurEdit.setObjectName("expDurEdit")
        self.horizontalLayout_13.addWidget(self.expDurEdit)
        self.asteroidDistanceLabel = QtWidgets.QLabel(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.asteroidDistanceLabel.sizePolicy().hasHeightForWidth())
        self.asteroidDistanceLabel.setSizePolicy(sizePolicy)
        self.asteroidDistanceLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.asteroidDistanceLabel.setObjectName("asteroidDistanceLabel")
        self.horizontalLayout_13.addWidget(self.asteroidDistanceLabel)
        self.asteroidDistanceEdit = QtWidgets.QLineEdit(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.asteroidDistanceEdit.sizePolicy().hasHeightForWidth())
        self.asteroidDistanceEdit.setSizePolicy(sizePolicy)
        self.asteroidDistanceEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.asteroidDistanceEdit.setObjectName("asteroidDistanceEdit")
        self.horizontalLayout_13.addWidget(self.asteroidDistanceEdit)
        self.shadowSpeedLabel = QtWidgets.QLabel(self.diffractionTab)
        self.shadowSpeedLabel.setObjectName("shadowSpeedLabel")
        self.horizontalLayout_13.addWidget(self.shadowSpeedLabel)
        self.shadowSpeedEdit = QtWidgets.QLineEdit(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.shadowSpeedEdit.sizePolicy().hasHeightForWidth())
        self.shadowSpeedEdit.setSizePolicy(sizePolicy)
        self.shadowSpeedEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.shadowSpeedEdit.setObjectName("shadowSpeedEdit")
        self.horizontalLayout_13.addWidget(self.shadowSpeedEdit)
        spacerItem39 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_13.addItem(spacerItem39)
        self.gridLayout_7.addLayout(self.horizontalLayout_13, 3, 1, 1, 2)
        spacerItem40 = QtWidgets.QSpacerItem(51, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_7.addItem(spacerItem40, 3, 3, 1, 1)
        self.horizontalLayout_15 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_15.setObjectName("horizontalLayout_15")
        self.asteroidSizeLabel = QtWidgets.QLabel(self.diffractionTab)
        self.asteroidSizeLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.asteroidSizeLabel.setObjectName("asteroidSizeLabel")
        self.horizontalLayout_15.addWidget(self.asteroidSizeLabel)
        self.astSizeEdit = QtWidgets.QLineEdit(self.diffractionTab)
        self.astSizeEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.astSizeEdit.setObjectName("astSizeEdit")
        self.horizontalLayout_15.addWidget(self.astSizeEdit)
        self.pathOffsetLabel = QtWidgets.QLabel(self.diffractionTab)
        self.pathOffsetLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.pathOffsetLabel.setObjectName("pathOffsetLabel")
        self.horizontalLayout_15.addWidget(self.pathOffsetLabel)
        self.pathOffsetEdit = QtWidgets.QLineEdit(self.diffractionTab)
        self.pathOffsetEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.pathOffsetEdit.setObjectName("pathOffsetEdit")
        self.horizontalLayout_15.addWidget(self.pathOffsetEdit)
        spacerItem41 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_15.addItem(spacerItem41)
        self.gridLayout_7.addLayout(self.horizontalLayout_15, 4, 1, 1, 2)
        self.horizontalLayout_14 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_14.setSpacing(0)
        self.horizontalLayout_14.setObjectName("horizontalLayout_14")
        self.starDiameterLabel = QtWidgets.QLabel(self.diffractionTab)
        self.starDiameterLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.starDiameterLabel.setObjectName("starDiameterLabel")
        self.horizontalLayout_14.addWidget(self.starDiameterLabel)
        self.starDiameterEdit = QtWidgets.QLineEdit(self.diffractionTab)
        self.starDiameterEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.starDiameterEdit.setObjectName("starDiameterEdit")
        self.horizontalLayout_14.addWidget(self.starDiameterEdit)
        self.dLimbAngleLabel = QtWidgets.QLabel(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.dLimbAngleLabel.sizePolicy().hasHeightForWidth())
        self.dLimbAngleLabel.setSizePolicy(sizePolicy)
        self.dLimbAngleLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.dLimbAngleLabel.setObjectName("dLimbAngleLabel")
        self.horizontalLayout_14.addWidget(self.dLimbAngleLabel)
        self.dLimbAngle = QtWidgets.QDoubleSpinBox(self.diffractionTab)
        self.dLimbAngle.setMaximumSize(QtCore.QSize(80, 16777215))
        self.dLimbAngle.setDecimals(1)
        self.dLimbAngle.setMaximum(90.0)
        self.dLimbAngle.setProperty("value", 90.0)
        self.dLimbAngle.setObjectName("dLimbAngle")
        self.horizontalLayout_14.addWidget(self.dLimbAngle)
        self.rLimbAngleLabel = QtWidgets.QLabel(self.diffractionTab)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.rLimbAngleLabel.sizePolicy().hasHeightForWidth())
        self.rLimbAngleLabel.setSizePolicy(sizePolicy)
        self.rLimbAngleLabel.setAlignment(QtCore.Qt.AlignRight|QtCore.Qt.AlignTrailing|QtCore.Qt.AlignVCenter)
        self.rLimbAngleLabel.setObjectName("rLimbAngleLabel")
        self.horizontalLayout_14.addWidget(self.rLimbAngleLabel)
        self.rLimbAngle = QtWidgets.QDoubleSpinBox(self.diffractionTab)
        self.rLimbAngle.setMaximumSize(QtCore.QSize(80, 16777215))
        self.rLimbAngle.setDecimals(1)
        self.rLimbAngle.setMaximum(90.0)
        self.rLimbAngle.setProperty("value", 90.0)
        self.rLimbAngle.setObjectName("rLimbAngle")
        self.horizontalLayout_14.addWidget(self.rLimbAngle)
        spacerItem42 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_14.addItem(spacerItem42)
        self.gridLayout_7.addLayout(self.horizontalLayout_14, 5, 1, 1, 2)
        self.line_8 = QtWidgets.QFrame(self.diffractionTab)
        self.line_8.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_8.setLineWidth(4)
        self.line_8.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_8.setObjectName("line_8")
        self.gridLayout_7.addWidget(self.line_8, 6, 1, 1, 2)
        self.horizontalLayout_16 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_16.setObjectName("horizontalLayout_16")
        self.demoUnderlyingLighturvesButton = QtWidgets.QPushButton(self.diffractionTab)
        self.demoUnderlyingLighturvesButton.setObjectName("demoUnderlyingLighturvesButton")
        self.horizontalLayout_16.addWidget(self.demoUnderlyingLighturvesButton)
        self.enableDiffractionCalculationBox = QtWidgets.QCheckBox(self.diffractionTab)
        self.enableDiffractionCalculationBox.setLayoutDirection(QtCore.Qt.LeftToRight)
        self.enableDiffractionCalculationBox.setChecked(True)
        self.enableDiffractionCalculationBox.setObjectName("enableDiffractionCalculationBox")
        self.horizontalLayout_16.addWidget(self.enableDiffractionCalculationBox)
        self.penumbralFitCheckBox = QtWidgets.QCheckBox(self.diffractionTab)
        self.penumbralFitCheckBox.setEnabled(False)
        self.penumbralFitCheckBox.setMaximumSize(QtCore.QSize(120, 16777215))
        self.penumbralFitCheckBox.setObjectName("penumbralFitCheckBox")
        self.horizontalLayout_16.addWidget(self.penumbralFitCheckBox)
        self.gridLayout_7.addLayout(self.horizontalLayout_16, 7, 1, 1, 2)
        spacerItem43 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_7.addItem(spacerItem43, 8, 2, 1, 1)
        self.tabWidget.addTab(self.diffractionTab, "")
        self.tab_9 = QtWidgets.QWidget()
        self.tab_9.setObjectName("tab_9")
        self.gridLayout_3 = QtWidgets.QGridLayout(self.tab_9)
        self.gridLayout_3.setObjectName("gridLayout_3")
        spacerItem44 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_3.addItem(spacerItem44, 0, 1, 1, 1)
        spacerItem45 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem45, 1, 0, 1, 1)
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        self.calcFlashEdge = QtWidgets.QPushButton(self.tab_9)
        self.calcFlashEdge.setEnabled(False)
        self.calcFlashEdge.setObjectName("calcFlashEdge")
        self.verticalLayout_4.addWidget(self.calcFlashEdge)
        self.horizontalLayout_22 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_22.setObjectName("horizontalLayout_22")
        self.manualTimestampCheckBox = QtWidgets.QCheckBox(self.tab_9)
        self.manualTimestampCheckBox.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.manualTimestampCheckBox.setObjectName("manualTimestampCheckBox")
        self.horizontalLayout_22.addWidget(self.manualTimestampCheckBox)
        self.manualEntryPushButton = QtWidgets.QPushButton(self.tab_9)
        self.manualEntryPushButton.setEnabled(False)
        self.manualEntryPushButton.setObjectName("manualEntryPushButton")
        self.horizontalLayout_22.addWidget(self.manualEntryPushButton)
        self.verticalLayout_4.addLayout(self.horizontalLayout_22)
        self.gridLayout_3.addLayout(self.verticalLayout_4, 1, 1, 1, 1)
        spacerItem46 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_3.addItem(spacerItem46, 1, 2, 1, 1)
        spacerItem47 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_3.addItem(spacerItem47, 2, 1, 1, 1)
        self.tabWidget.addTab(self.tab_9, "")
        self.settingsTab = QtWidgets.QWidget()
        self.settingsTab.setObjectName("settingsTab")
        self.gridLayout_5 = QtWidgets.QGridLayout(self.settingsTab)
        self.gridLayout_5.setObjectName("gridLayout_5")
        spacerItem48 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem48, 0, 2, 1, 1)
        self.allowNewVersionPopupCheckbox = QtWidgets.QCheckBox(self.settingsTab)
        self.allowNewVersionPopupCheckbox.setChecked(True)
        self.allowNewVersionPopupCheckbox.setObjectName("allowNewVersionPopupCheckbox")
        self.gridLayout_5.addWidget(self.allowNewVersionPopupCheckbox, 1, 1, 1, 1)
        self.line_16 = QtWidgets.QFrame(self.settingsTab)
        self.line_16.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_16.setLineWidth(4)
        self.line_16.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_16.setObjectName("line_16")
        self.gridLayout_5.addWidget(self.line_16, 2, 1, 1, 3)
        self.label = QtWidgets.QLabel(self.settingsTab)
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")
        self.gridLayout_5.addWidget(self.label, 3, 1, 1, 2)
        self.horizontalLayout_17 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_17.setObjectName("horizontalLayout_17")
        self.showTimestampErrors = QtWidgets.QCheckBox(self.settingsTab)
        self.showTimestampErrors.setEnabled(False)
        self.showTimestampErrors.setObjectName("showTimestampErrors")
        self.horizontalLayout_17.addWidget(self.showTimestampErrors)
        self.showCameraResponseCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showCameraResponseCheckBox.setObjectName("showCameraResponseCheckBox")
        self.horizontalLayout_17.addWidget(self.showCameraResponseCheckBox)
        self.showUnderlyingLightcurveCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showUnderlyingLightcurveCheckBox.setChecked(True)
        self.showUnderlyingLightcurveCheckBox.setObjectName("showUnderlyingLightcurveCheckBox")
        self.horizontalLayout_17.addWidget(self.showUnderlyingLightcurveCheckBox)
        self.showErrBarsCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showErrBarsCheckBox.setChecked(True)
        self.showErrBarsCheckBox.setObjectName("showErrBarsCheckBox")
        self.horizontalLayout_17.addWidget(self.showErrBarsCheckBox)
        self.showEdgesCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showEdgesCheckBox.setChecked(True)
        self.showEdgesCheckBox.setObjectName("showEdgesCheckBox")
        self.horizontalLayout_17.addWidget(self.showEdgesCheckBox)
        self.showOCRcheckFramesCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showOCRcheckFramesCheckBox.setChecked(True)
        self.showOCRcheckFramesCheckBox.setObjectName("showOCRcheckFramesCheckBox")
        self.horizontalLayout_17.addWidget(self.showOCRcheckFramesCheckBox)
        self.showTimestampsCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.showTimestampsCheckBox.setObjectName("showTimestampsCheckBox")
        self.horizontalLayout_17.addWidget(self.showTimestampsCheckBox)
        self.gridLayout_5.addLayout(self.horizontalLayout_17, 4, 1, 1, 2)
        self.line_5 = QtWidgets.QFrame(self.settingsTab)
        self.line_5.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_5.setLineWidth(4)
        self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_5.setObjectName("line_5")
        self.gridLayout_5.addWidget(self.line_5, 5, 1, 1, 3)
        spacerItem49 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem49, 5, 4, 2, 1)
        self.label_2 = QtWidgets.QLabel(self.settingsTab)
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.gridLayout_5.addWidget(self.label_2, 6, 1, 1, 2)
        self.horizontalLayout_18 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_18.setObjectName("horizontalLayout_18")
        self.viewFrameButton = QtWidgets.QPushButton(self.settingsTab)
        self.viewFrameButton.setEnabled(False)
        self.viewFrameButton.setObjectName("viewFrameButton")
        self.horizontalLayout_18.addWidget(self.viewFrameButton)
        self.frameNumSpinBox = QtWidgets.QSpinBox(self.settingsTab)
        self.frameNumSpinBox.setEnabled(False)
        self.frameNumSpinBox.setMaximumSize(QtCore.QSize(100, 16777215))
        self.frameNumSpinBox.setSizeIncrement(QtCore.QSize(0, 0))
        self.frameNumSpinBox.setMaximum(99999)
        self.frameNumSpinBox.setObjectName("frameNumSpinBox")
        self.horizontalLayout_18.addWidget(self.frameNumSpinBox)
        self.gridLayout_5.addLayout(self.horizontalLayout_18, 7, 1, 1, 1)
        self.line_11 = QtWidgets.QFrame(self.settingsTab)
        self.line_11.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_11.setLineWidth(4)
        self.line_11.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_11.setObjectName("line_11")
        self.gridLayout_5.addWidget(self.line_11, 8, 1, 1, 3)
        self.label_3 = QtWidgets.QLabel(self.settingsTab)
        self.label_3.setAlignment(QtCore.Qt.AlignCenter)
        self.label_3.setObjectName("label_3")
        self.gridLayout_5.addWidget(self.label_3, 9, 1, 1, 2)
        self.horizontalLayout_19 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_19.setObjectName("horizontalLayout_19")
        self.fieldViewCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.fieldViewCheckBox.setEnabled(False)
        self.fieldViewCheckBox.setObjectName("fieldViewCheckBox")
        self.horizontalLayout_19.addWidget(self.fieldViewCheckBox)
        self.flipYaxisCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.flipYaxisCheckBox.setEnabled(False)
        self.flipYaxisCheckBox.setObjectName("flipYaxisCheckBox")
        self.horizontalLayout_19.addWidget(self.flipYaxisCheckBox)
        self.flipXaxisCheckBox = QtWidgets.QCheckBox(self.settingsTab)
        self.flipXaxisCheckBox.setEnabled(False)
        self.flipXaxisCheckBox.setObjectName("flipXaxisCheckBox")
        self.horizontalLayout_19.addWidget(self.flipXaxisCheckBox)
        self.gridLayout_5.addLayout(self.horizontalLayout_19, 10, 1, 1, 1)
        spacerItem50 = QtWidgets.QSpacerItem(155, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_5.addItem(spacerItem50, 11, 0, 2, 1)
        self.line_9 = QtWidgets.QFrame(self.settingsTab)
        self.line_9.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_9.setLineWidth(4)
        self.line_9.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_9.setObjectName("line_9")
        self.gridLayout_5.addWidget(self.line_9, 11, 1, 1, 3)
        self.label_4 = QtWidgets.QLabel(self.settingsTab)
        self.label_4.setObjectName("label_4")
        self.gridLayout_5.addWidget(self.label_4, 12, 1, 1, 2)
        self.horizontalLayout_20 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_20.setObjectName("horizontalLayout_20")
        self.lineWidthLabel = QtWidgets.QLabel(self.settingsTab)
        self.lineWidthLabel.setObjectName("lineWidthLabel")
        self.horizontalLayout_20.addWidget(self.lineWidthLabel)
        self.lineWidthSpinner = QtWidgets.QSpinBox(self.settingsTab)
        self.lineWidthSpinner.setMinimum(1)
        self.lineWidthSpinner.setMaximum(9)
        self.lineWidthSpinner.setProperty("value", 5)
        self.lineWidthSpinner.setObjectName("lineWidthSpinner")
        self.horizontalLayout_20.addWidget(self.lineWidthSpinner)
        spacerItem51 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_20.addItem(spacerItem51)
        self.gridLayout_5.addLayout(self.horizontalLayout_20, 13, 1, 1, 1)
        self.line_13 = QtWidgets.QFrame(self.settingsTab)
        self.line_13.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_13.setLineWidth(4)
        self.line_13.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_13.setObjectName("line_13")
        self.gridLayout_5.addWidget(self.line_13, 14, 1, 1, 3)
        self.label_31 = QtWidgets.QLabel(self.settingsTab)
        self.label_31.setObjectName("label_31")
        self.gridLayout_5.addWidget(self.label_31, 15, 1, 1, 1)
        self.horizontalLayout_39 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_39.setObjectName("horizontalLayout_39")
        self.lineWidthLabel_2 = QtWidgets.QLabel(self.settingsTab)
        self.lineWidthLabel_2.setObjectName("lineWidthLabel_2")
        self.horizontalLayout_39.addWidget(self.lineWidthLabel_2)
        self.dotSizeSpinner = QtWidgets.QSpinBox(self.settingsTab)
        self.dotSizeSpinner.setMinimum(1)
        self.dotSizeSpinner.setMaximum(12)
        self.dotSizeSpinner.setProperty("value", 8)
        self.dotSizeSpinner.setObjectName("dotSizeSpinner")
        self.horizontalLayout_39.addWidget(self.dotSizeSpinner)
        spacerItem52 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_39.addItem(spacerItem52)
        self.gridLayout_5.addLayout(self.horizontalLayout_39, 16, 1, 1, 1)
        self.line_26 = QtWidgets.QFrame(self.settingsTab)
        self.line_26.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_26.setLineWidth(4)
        self.line_26.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_26.setObjectName("line_26")
        self.gridLayout_5.addWidget(self.line_26, 17, 1, 1, 3)
        self.label_6 = QtWidgets.QLabel(self.settingsTab)
        self.label_6.setObjectName("label_6")
        self.gridLayout_5.addWidget(self.label_6, 18, 1, 1, 2)
        self.label_7 = QtWidgets.QLabel(self.settingsTab)
        self.label_7.setObjectName("label_7")
        self.gridLayout_5.addWidget(self.label_7, 19, 1, 1, 2)
        self.label_8 = QtWidgets.QLabel(self.settingsTab)
        self.label_8.setObjectName("label_8")
        self.gridLayout_5.addWidget(self.label_8, 20, 1, 1, 3)
        self.horizontalLayout_9 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_9.setObjectName("horizontalLayout_9")
        self.pymovieDataColumnPrefixComboBox = QtWidgets.QComboBox(self.settingsTab)
        self.pymovieDataColumnPrefixComboBox.setCurrentText("")
        self.pymovieDataColumnPrefixComboBox.setObjectName("pymovieDataColumnPrefixComboBox")
        self.horizontalLayout_9.addWidget(self.pymovieDataColumnPrefixComboBox)
        self.label_5 = QtWidgets.QLabel(self.settingsTab)
        self.label_5.setObjectName("label_5")
        self.horizontalLayout_9.addWidget(self.label_5)
        spacerItem53 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_9.addItem(spacerItem53)
        self.gridLayout_5.addLayout(self.horizontalLayout_9, 21, 1, 1, 1)
        spacerItem54 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_5.addItem(spacerItem54, 22, 3, 1, 1)
        self.tabWidget.addTab(self.settingsTab, "")
        self.tab_8 = QtWidgets.QWidget()
        self.tab_8.setObjectName("tab_8")
        self.gridLayout_6 = QtWidgets.QGridLayout(self.tab_8)
        self.gridLayout_6.setObjectName("gridLayout_6")
        spacerItem55 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_6.addItem(spacerItem55, 0, 1, 1, 1)
        self.verticalLayout_3 = QtWidgets.QVBoxLayout()
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.detectabilityHelpButton = QtWidgets.QPushButton(self.tab_8)
        self.detectabilityHelpButton.setObjectName("detectabilityHelpButton")
        self.verticalLayout_3.addWidget(self.detectabilityHelpButton)
        self.line_12 = QtWidgets.QFrame(self.tab_8)
        self.line_12.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_12.setLineWidth(4)
        self.line_12.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_12.setObjectName("line_12")
        self.verticalLayout_3.addWidget(self.line_12)
        self.markBaselineRegionButton = QtWidgets.QPushButton(self.tab_8)
        self.markBaselineRegionButton.setObjectName("markBaselineRegionButton")
        self.verticalLayout_3.addWidget(self.markBaselineRegionButton)
        self.clearBaselineRegionsButton = QtWidgets.QPushButton(self.tab_8)
        self.clearBaselineRegionsButton.setObjectName("clearBaselineRegionsButton")
        self.verticalLayout_3.addWidget(self.clearBaselineRegionsButton)
        self.calcStatsFromBaselineRegionsButton = QtWidgets.QPushButton(self.tab_8)
        self.calcStatsFromBaselineRegionsButton.setObjectName("calcStatsFromBaselineRegionsButton")
        self.verticalLayout_3.addWidget(self.calcStatsFromBaselineRegionsButton)
        self.line_10 = QtWidgets.QFrame(self.tab_8)
        self.line_10.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_10.setLineWidth(4)
        self.line_10.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_10.setObjectName("line_10")
        self.verticalLayout_3.addWidget(self.line_10)
        self.gridLayout_6.addLayout(self.verticalLayout_3, 1, 1, 1, 1)
        spacerItem56 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem56, 2, 0, 1, 1)
        self.horizontalLayout_21 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_21.setObjectName("horizontalLayout_21")
        self.obsDurLabel = QtWidgets.QLabel(self.tab_8)
        self.obsDurLabel.setObjectName("obsDurLabel")
        self.horizontalLayout_21.addWidget(self.obsDurLabel)
        self.observationDurEdit = QtWidgets.QLineEdit(self.tab_8)
        self.observationDurEdit.setMinimumSize(QtCore.QSize(0, 0))
        self.observationDurEdit.setMaximumSize(QtCore.QSize(80, 16777215))
        self.observationDurEdit.setObjectName("observationDurEdit")
        self.horizontalLayout_21.addWidget(self.observationDurEdit)
        self.eventDurLabel = QtWidgets.QLabel(self.tab_8)
        self.eventDurLabel.setObjectName("eventDurLabel")
        self.horizontalLayout_21.addWidget(self.eventDurLabel)
        self.eventDurationEdit = QtWidgets.QLineEdit(self.tab_8)
        self.eventDurationEdit.setMaximumSize(QtCore.QSize(80, 16777215))
        self.eventDurationEdit.setObjectName("eventDurationEdit")
        self.horizontalLayout_21.addWidget(self.eventDurationEdit)
        self.durStepLabel = QtWidgets.QLabel(self.tab_8)
        self.durStepLabel.setMaximumSize(QtCore.QSize(16777215, 16777215))
        self.durStepLabel.setObjectName("durStepLabel")
        self.horizontalLayout_21.addWidget(self.durStepLabel)
        self.durStepEdit = QtWidgets.QLineEdit(self.tab_8)
        self.durStepEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.durStepEdit.setObjectName("durStepEdit")
        self.horizontalLayout_21.addWidget(self.durStepEdit)
        spacerItem57 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_21.addItem(spacerItem57)
        self.detectMagDropLabel = QtWidgets.QLabel(self.tab_8)
        self.detectMagDropLabel.setObjectName("detectMagDropLabel")
        self.horizontalLayout_21.addWidget(self.detectMagDropLabel)
        self.detectabilityMagDropEdit = QtWidgets.QLineEdit(self.tab_8)
        self.detectabilityMagDropEdit.setMaximumSize(QtCore.QSize(60, 16777215))
        self.detectabilityMagDropEdit.setObjectName("detectabilityMagDropEdit")
        self.horizontalLayout_21.addWidget(self.detectabilityMagDropEdit)
        self.gridLayout_6.addLayout(self.horizontalLayout_21, 2, 1, 1, 1)
        spacerItem58 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_6.addItem(spacerItem58, 2, 2, 1, 1)
        self.horizontalLayout_27 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_27.setObjectName("horizontalLayout_27")
        self.calcDetectabilityButton = QtWidgets.QPushButton(self.tab_8)
        self.calcDetectabilityButton.setMinimumSize(QtCore.QSize(500, 0))
        self.calcDetectabilityButton.setObjectName("calcDetectabilityButton")
        self.horizontalLayout_27.addWidget(self.calcDetectabilityButton)
        spacerItem59 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_27.addItem(spacerItem59)
        self.writeExampleLightcurveCheckBox = QtWidgets.QCheckBox(self.tab_8)
        self.writeExampleLightcurveCheckBox.setObjectName("writeExampleLightcurveCheckBox")
        self.horizontalLayout_27.addWidget(self.writeExampleLightcurveCheckBox)
        self.gridLayout_6.addLayout(self.horizontalLayout_27, 3, 1, 1, 1)
        spacerItem60 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_6.addItem(spacerItem60, 4, 1, 1, 1)
        self.tabWidget.addTab(self.tab_8, "")
        self.tab = QtWidgets.QWidget()
        self.tab.setObjectName("tab")
        self.gridLayout_2 = QtWidgets.QGridLayout(self.tab)
        self.gridLayout_2.setObjectName("gridLayout_2")
        spacerItem61 = QtWidgets.QSpacerItem(20, 247, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem61, 0, 1, 1, 1)
        self.verticalLayout_7 = QtWidgets.QVBoxLayout()
        self.verticalLayout_7.setObjectName("verticalLayout_7")
        self.ne3ExplanationButton = QtWidgets.QPushButton(self.tab)
        self.ne3ExplanationButton.setObjectName("ne3ExplanationButton")
        self.verticalLayout_7.addWidget(self.ne3ExplanationButton)
        self.ne3NotInUseRadioButton = QtWidgets.QRadioButton(self.tab)
        self.ne3NotInUseRadioButton.setChecked(True)
        self.ne3NotInUseRadioButton.setObjectName("ne3NotInUseRadioButton")
        self.verticalLayout_7.addWidget(self.ne3NotInUseRadioButton)
        self.line_14 = QtWidgets.QFrame(self.tab)
        self.line_14.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_14.setLineWidth(5)
        self.line_14.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_14.setObjectName("line_14")
        self.verticalLayout_7.addWidget(self.line_14)
        self.dnrOffRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrOffRadioButton.setChecked(False)
        self.dnrOffRadioButton.setObjectName("dnrOffRadioButton")
        self.verticalLayout_7.addWidget(self.dnrOffRadioButton)
        self.gridLayout_2.addLayout(self.verticalLayout_7, 1, 1, 1, 1)
        self.horizontalLayout_23 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_23.setObjectName("horizontalLayout_23")
        self.dnrLowRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrLowRadioButton.setObjectName("dnrLowRadioButton")
        self.horizontalLayout_23.addWidget(self.dnrLowRadioButton)
        spacerItem62 = QtWidgets.QSpacerItem(113, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_23.addItem(spacerItem62)
        self.dnrLowDtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrLowDtcLabel.setObjectName("dnrLowDtcLabel")
        self.horizontalLayout_23.addWidget(self.dnrLowDtcLabel)
        self.dnrLowDspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrLowDspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrLowDspinBox.setMinimum(0.1)
        self.dnrLowDspinBox.setMaximum(1.0)
        self.dnrLowDspinBox.setSingleStep(0.1)
        self.dnrLowDspinBox.setProperty("value", 0.5)
        self.dnrLowDspinBox.setObjectName("dnrLowDspinBox")
        self.horizontalLayout_23.addWidget(self.dnrLowDspinBox)
        self.dnrLowRtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrLowRtcLabel.setObjectName("dnrLowRtcLabel")
        self.horizontalLayout_23.addWidget(self.dnrLowRtcLabel)
        self.dnrLowRspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrLowRspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrLowRspinBox.setMaximum(1.0)
        self.dnrLowRspinBox.setSingleStep(0.1)
        self.dnrLowRspinBox.setProperty("value", 0.5)
        self.dnrLowRspinBox.setObjectName("dnrLowRspinBox")
        self.horizontalLayout_23.addWidget(self.dnrLowRspinBox)
        self.gridLayout_2.addLayout(self.horizontalLayout_23, 2, 1, 1, 1)
        spacerItem63 = QtWidgets.QSpacerItem(190, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem63, 3, 0, 1, 1)
        self.horizontalLayout_24 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_24.setObjectName("horizontalLayout_24")
        self.dnrMiddleRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrMiddleRadioButton.setObjectName("dnrMiddleRadioButton")
        self.horizontalLayout_24.addWidget(self.dnrMiddleRadioButton)
        spacerItem64 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_24.addItem(spacerItem64)
        self.dnrMiddleDtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrMiddleDtcLabel.setObjectName("dnrMiddleDtcLabel")
        self.horizontalLayout_24.addWidget(self.dnrMiddleDtcLabel)
        self.dnrMiddleDspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrMiddleDspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrMiddleDspinBox.setMinimum(0.5)
        self.dnrMiddleDspinBox.setMaximum(5.0)
        self.dnrMiddleDspinBox.setSingleStep(0.1)
        self.dnrMiddleDspinBox.setProperty("value", 1.0)
        self.dnrMiddleDspinBox.setObjectName("dnrMiddleDspinBox")
        self.horizontalLayout_24.addWidget(self.dnrMiddleDspinBox)
        self.dnrMiddleRtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrMiddleRtcLabel.setObjectName("dnrMiddleRtcLabel")
        self.horizontalLayout_24.addWidget(self.dnrMiddleRtcLabel)
        self.dnrMiddleRspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrMiddleRspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrMiddleRspinBox.setMinimum(0.5)
        self.dnrMiddleRspinBox.setMaximum(5.0)
        self.dnrMiddleRspinBox.setSingleStep(0.1)
        self.dnrMiddleRspinBox.setProperty("value", 1.0)
        self.dnrMiddleRspinBox.setObjectName("dnrMiddleRspinBox")
        self.horizontalLayout_24.addWidget(self.dnrMiddleRspinBox)
        self.gridLayout_2.addLayout(self.horizontalLayout_24, 3, 1, 1, 1)
        spacerItem65 = QtWidgets.QSpacerItem(113, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.gridLayout_2.addItem(spacerItem65, 3, 2, 1, 1)
        self.horizontalLayout_25 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_25.setObjectName("horizontalLayout_25")
        self.dnrHighRadioButton = QtWidgets.QRadioButton(self.tab)
        self.dnrHighRadioButton.setObjectName("dnrHighRadioButton")
        self.horizontalLayout_25.addWidget(self.dnrHighRadioButton)
        spacerItem66 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_25.addItem(spacerItem66)
        self.dnrHighDtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrHighDtcLabel.setObjectName("dnrHighDtcLabel")
        self.horizontalLayout_25.addWidget(self.dnrHighDtcLabel)
        self.dnrHighDspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrHighDspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrHighDspinBox.setMinimum(1.0)
        self.dnrHighDspinBox.setMaximum(10.0)
        self.dnrHighDspinBox.setSingleStep(0.1)
        self.dnrHighDspinBox.setProperty("value", 4.5)
        self.dnrHighDspinBox.setObjectName("dnrHighDspinBox")
        self.horizontalLayout_25.addWidget(self.dnrHighDspinBox)
        self.dnrHighRtcLabel = QtWidgets.QLabel(self.tab)
        self.dnrHighRtcLabel.setObjectName("dnrHighRtcLabel")
        self.horizontalLayout_25.addWidget(self.dnrHighRtcLabel)
        self.dnrHighRspinBox = QtWidgets.QDoubleSpinBox(self.tab)
        self.dnrHighRspinBox.setMinimumSize(QtCore.QSize(70, 0))
        self.dnrHighRspinBox.setMinimum(1.0)
        self.dnrHighRspinBox.setMaximum(10.0)
        self.dnrHighRspinBox.setSingleStep(0.1)
        self.dnrHighRspinBox.setProperty("value", 2.0)
        self.dnrHighRspinBox.setObjectName("dnrHighRspinBox")
        self.horizontalLayout_25.addWidget(self.dnrHighRspinBox)
        self.gridLayout_2.addLayout(self.horizontalLayout_25, 4, 1, 1, 1)
        self.line_15 = QtWidgets.QFrame(self.tab)
        self.line_15.setFrameShadow(QtWidgets.QFrame.Plain)
        self.line_15.setLineWidth(5)
        self.line_15.setFrameShape(QtWidgets.QFrame.HLine)
        self.line_15.setObjectName("line_15")
        self.gridLayout_2.addWidget(self.line_15, 5, 1, 1, 1)
        self.horizontalLayout_26 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_26.setObjectName("horizontalLayout_26")
        spacerItem67 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_26.addItem(spacerItem67)
        self.yPositionLabel = QtWidgets.QLabel(self.tab)
        self.yPositionLabel.setObjectName("yPositionLabel")
        self.horizontalLayout_26.addWidget(self.yPositionLabel)
        self.targetStarYpositionSpinBox = QtWidgets.QSpinBox(self.tab)
        self.targetStarYpositionSpinBox.setMinimumSize(QtCore.QSize(80, 0))
        self.targetStarYpositionSpinBox.setMaximum(479)
        self.targetStarYpositionSpinBox.setObjectName("targetStarYpositionSpinBox")
        self.horizontalLayout_26.addWidget(self.targetStarYpositionSpinBox)
        spacerItem68 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout_26.addItem(spacerItem68)
        self.gridLayout_2.addLayout(self.horizontalLayout_26, 6, 1, 1, 1)
        spacerItem69 = QtWidgets.QSpacerItem(20, 259, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.gridLayout_2.addItem(spacerItem69, 7, 1, 1, 1)
        self.tabWidget.addTab(self.tab, "")
        self.horizontalLayout_6.addWidget(self.tabWidget)
        self.verticalLayout_2.addLayout(self.horizontalLayout_6)
        self.helpLabelForDataGrid = QtWidgets.QLabel(self.layoutWidget)
        self.helpLabelForDataGrid.setObjectName("helpLabelForDataGrid")
        self.verticalLayout_2.addWidget(self.helpLabelForDataGrid)
        self.mainPlot = PlotWidget(self.splitterTwo)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(1)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.mainPlot.sizePolicy().hasHeightForWidth())
        self.mainPlot.setSizePolicy(sizePolicy)
        self.mainPlot.setMinimumSize(QtCore.QSize(0, 0))
        self.mainPlot.viewport().setProperty("cursor", QtGui.QCursor(QtCore.Qt.IBeamCursor))
        self.mainPlot.setObjectName("mainPlot")
        self.splitterOne = QtWidgets.QSplitter(self.splitterThree)
        self.splitterOne.setOrientation(QtCore.Qt.Horizontal)
        self.splitterOne.setHandleWidth(10)
        self.splitterOne.setObjectName("splitterOne")
        self.table = QtWidgets.QTableWidget(self.splitterOne)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.table.sizePolicy().hasHeightForWidth())
        self.table.setSizePolicy(sizePolicy)
        self.table.setMinimumSize(QtCore.QSize(0, 0))
        self.table.setToolTipDuration(4000)
        self.table.setRowCount(11)
        self.table.setColumnCount(4)
        self.table.setObjectName("table")
        self.textOut = QtWidgets.QTextEdit(self.splitterOne)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.textOut.sizePolicy().hasHeightForWidth())
        self.textOut.setSizePolicy(sizePolicy)
        font = QtGui.QFont()
        font.setFamily("Courier New")
        self.textOut.setFont(font)
        self.textOut.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
        self.textOut.setUndoRedoEnabled(False)
        self.textOut.setLineWrapMode(QtWidgets.QTextEdit.NoWrap)
        self.textOut.setReadOnly(True)
        self.textOut.setObjectName("textOut")
        self.gridLayout_9.addWidget(self.splitterThree, 0, 0, 1, 1)
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        self.tabWidget.setCurrentIndex(1)
        self.pymovieDataColumnPrefixComboBox.setCurrentIndex(-1)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "PY-OTE"))
        self.plotHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#0000ff;\">Once data from an observation is being displayed in the panel to the right, the following functions are available:</span></p><p>&gt;&gt;&gt; moving the mouse cursor into the plot area causes a thin vertical line to appear to show the x position</p><p>&gt;&gt;&gt; a left-click will toggle the selection of the data point at the x position of the mouse (watch the thin vertical line)</p><p>&gt;&gt;&gt; the plot can be zoomed horizontally using the scroll wheel (or equivalent) on the mouse</p><p>&gt;&gt;&gt; holding down the shift key will cause the mouse cursor to appear, useful for the following operation...</p><p>&gt;&gt;&gt; a left-click/hold/drag will create a selection box --- on left-button release, a zoomed image will appear</p><p>&gt;&gt;&gt; a right-click undoes any scroll/zoom modifications that have been performed</p><p><span style=\" font-weight:600; color:#0000ff;\">Timestamp errors:</span></p><p>If the csv file included timestamps, there may be a few (or many) thin vertical red lines, each appearing between adjacent data points.  These indicate that the time step computed from the adjacent data points was not within 10% of the \'expected\' time step.  The expected value is computed from the median of all time steps.  There is a checkbox to the left that can be used to suppress this display if it is too intrusive.</p><p><span style=\" font-weight:600; color:#0000ff;\">When a \'solution\' has been found, there will be displayed:</span></p><p>+++ in brown: the underlying lightcurve (theoretical lightcurve with diffraction and finite star disk effects included)</p><p>+++ in blue: the camera response --- this is the underlying lightcurve integrated by the exposure time of the camera</p><p>+++ vertical dashed lines: these show the position of the occultation\'s geometrical edges (red: D green: R)</p><p><span style=\" font-weight:600; color:#0000ff;\">After a \'... write report\' has been performed:</span></p><p>=== the 95% containment interval for the D and/or R edges are shown with shortened vertical dotted enclosing the central value</p></body></html>"))
        self.plotHelpButton.setText(_translate("MainWindow", "Help for plot -->"))
        self.infoButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to to open the <span style=\" color:#ff0000;\">help.pdf</span> file that is included in the installation. The file will open in whatever PDF viewer you have assigned as the default viewer for pdf files.</p><p>The first part of this file is version info that should be examined every time a new version of PyOTE is installed.</p><p>At the bottom of this version info is a brief introduction to PyOTE that should be read by new users.</p></body></html>"))
        self.infoButton.setWhatsThis(_translate("MainWindow", "How does this show up?"))
        self.infoButton.setText(_translate("MainWindow", "Info"))
        self.readData.setToolTip(_translate("MainWindow", "<html><head/><body><p>PYOTE reads Limovie, R-OTE, and Tangra files and includes up to four light curves from those file types.  For PyMovie files, PYOTE will read an unlimited number of light curves.</p><p>Normally (but not required) object1 is the occulted star; other (optional) objects are reference stars to be used for normalizing the occulted star light curve or flash curves from an LED timer.</p><p><span style=\" font-weight:600; text-decoration: underline; color:#0000ff;\">Mouse button functions within the light curve plot:</span></p><p><span style=\" font-weight:600; color:#ff0000;\">Left click</span>: selects/deselects points on the primary (dark blue) light curve that intersect with the vertical hairline (the mouse cursor is disabled).</p><p><span style=\" font-weight:600; color:#ff0000;\">Left click and drag</span>: rectangular zoom is available to more clearly see points for selection (but point selection can also be accomplished through clicks in the tabular data display at the lower left)</p><p><span style=\" font-weight:600;\">Note! The shift key will toggle the mouse cursor on/off in the light curve plot.</span> This enables the starting corner for the zoom to be seen. (But points cannot be selected/deselected while the mouse cursor is visible. A right click will always \'blank\' the mouse cursor.) </p><p><span style=\" font-weight:600; color:#ff0000;\">Right click</span>: undo zoom</p><p><span style=\" color:#996633;\">Timestamp errors are shown with vertical red hairlines when a file is first read. These will disappear after the first point is selected so that the working view is as clear as possible. The red hairlines will re-appear permanently after the error bars have been calculated and the final report written to the log.</span></p></body></html>"))
        self.readData.setText(_translate("MainWindow", "Read light curve"))
        self.helpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>\'Help\' is available for most GUI items by right-clicking on the item.</p><p>If an item already has a different action assigned to a right-click, there will be a nearby text line or button that can be clicked on instead.</p><p>There is no need to close the help panel before right-clicking on another GUI item. One can use this feature to get a quick survey of the \'help\' that is available by sequentially clicking on all GUI items.</p></body></html>"))
        self.helpButton.setText(_translate("MainWindow", "Help"))
        self.tutorialButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Tip: right-click on buttons and labels. An explanation (help screen) will usually appear. Use that technique to learn about features that are not covered in this basic tutorial/recipe.</p><p>1. Start by clicking the<span style=\" font-weight:600; color:#0000ff;\"> Read light curve</span> button. (Usually, the camera exposure value will be read from the csv file and automatically inserted in the <span style=\" font-weight:600; color:#0000ff;\">exp:</span> edit box in the <span style=\" font-weight:600; color:#0000ff;\">parameters</span> panel. If that did not happen, you will need to manually fill in that value in before trying to find an event fit.)</p><p>2. If timestamp errors have been detected during the loading of the csv file, the affected points will be bracketed by vertical redlines and the <span style=\" font-weight:600; color:#0000ff;\">Show time err</span> checkbox will have been set by the program. Those red lines will likely have served their purpose and can/should be turned off so that a clear view of the light-curve is presented.</p><p>3. If the csv file contained multiple light-curves (it usually will), use the <span style=\" font-weight:600; color:#0000ff;\">Lightcurves</span> tab/panel to select the target lightcurve (the lightcurve containing the occultation)</p><p>4. The next step is to give the \'event finder\' information that can speed up the search. </p><p>4a. If the event has a wide enough bottom, the quickest way to provide speed-up information is mark the D and R regions. Right-click on those buttons for a how-to.</p><p>4b. If the event is so small that it is hard or impossible to mark D and R regions, the speed-up information is then best supplied by placing the smallest event duration in the <span style=\" font-weight:600; color:#0000ff;\">min event duration</span> edit box and the maximum event duration in the <span style=\" font-weight:600; color:#0000ff;\">max event duration</span> edit box. The \'finder\' will then search for all events in the range of durations given, located anywhere in the light-curve.</p><p>5. Next, click the <span style=\" font-weight:600; color:#0000ff;\">Find event, then ...</span> button to initiate the search.</p><p>6. Assuming the search was successful, the final step is to click the <span style=\" font-weight:600; color:#0000ff;\">... write report</span> button.</p><p>Every step you took is recorded in a log file in the directory where the light-curve was read from. This is important information to provide to anyone that you might go to for assistance. Give them the csv file and the log file and they will be able to reproduce your session.</p></body></html>"))
        self.tutorialButton.setText(_translate("MainWindow", "Tutorial"))
        self.lightcurvesHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This panel allows up to 10 lightcurves to be displayed at the same time. If the csv file has more than 10 lightcurves, the first 10 are displayed.</p><p>The<span style=\" font-weight:600; color:#0000ff;\"> targe</span>t lightcurve is always drawn with bright blue dots.</p><p>If a lightcurve is selected as a <span style=\" font-weight:600; color:#0000ff;\">reference</span> to be used for normalization, it is always drawn with bright green dots. If a non-zero value is present in the <span style=\" font-weight:600; color:#0000ff;\">smoothing readings</span> spinbox, a smoothed version of the <span style=\" font-weight:600; color:#0000ff;\">reference</span> curve will be displayed as well (color is brown). This smoothed curve is produced by a double application of a first order Savitzky-Golay filter (a straight line) to the points - extrapolation is enabled to deal with the points at either end. <span style=\" font-weight:600; color:#fc0107;\">Note:</span> The Savitzky-Golay algorithm requires an odd number of smoothing points. PyOTE makes your entry odd by adding 1 when necessary.</p><p>Unless a lightcurve is designated as a <span style=\" font-weight:600; color:#0000ff;\">target</span> (which is always the curve to be analyzed for an event) or is designated as a <span style=\" font-weight:600; color:#0000ff;\">reference</span> lightcurve, its dot color depends on the row it is in - every row has a unique color other than blue or green - there is a sample color shown at the right of the lightcurve title.</p><p><span style=\" font-weight:600; color:#fc0107;\">Tip:</span> it is easier to compare the color sample with the dots in the curve plot if the dots are larger - dot size can be changed by a spinbox that is on the <span style=\" font-weight:600; color:#0000ff;\">Settings/Misc.</span> tab.</p><p>Lightcurves can be displaced up or down using the<span style=\" font-weight:600; color:#0000ff;\"> Y offset</span> spinner to control the displacement. This affects the display position only; the underlying values are not affected. This facility was added to allow the separation of lightcurves that would otherwise overlap in a confusing manner.</p><p>There can only be one lightcurve selected as <span style=\" font-weight:600; color:#0000ff;\">target</span>. That curve always has its <span style=\" font-weight:600; color:#0000ff;\">Y offset</span> spinner disabled with a value of zero. If there is some lightcurve that overlaps with the <span style=\" font-weight:600; color:#0000ff;\">target</span>, move that one out of the way.</p><p>There can be either 0 or 1 lightcurve selected as a <span style=\" font-weight:600; color:#0000ff;\">reference</span> for normalization.</p><p>Normalization is applied whenever the<span style=\" font-weight:600; color:#0000ff;\"> smoothing readings</span> spinbox is changed from 0. Whenever this number is changed, a new normalization will result. If this number is returned to zero, all normalization is removed and the original values restored.</p><p>If the <span style=\" font-weight:600; color:#0000ff;\">reference</span> curve is changed, any previously applied normalization is removed and the <span style=\" font-weight:600; color:#0000ff;\">smoothing readings</span> spinbox is set to 0.</p><p>The <span style=\" font-weight:600; color:#0000ff;\">X offset</span> spinbox is used to shift the <span style=\" font-weight:600; color:#0000ff;\">reference</span> curve left or right (a time shift) for those cases where a drifting cloud affects the <span style=\" font-weight:600; color:#0000ff;\">target</span> lightcurves at a slightly different time.</p></body></html>"))
        self.lightcurvesHelpButton.setText(_translate("MainWindow", "Help"))
        self.label_30.setText(_translate("MainWindow", " target     ref      show"))
        self.label_33.setText(_translate("MainWindow", "Y offset step size:"))
        self.yOffsetStep10radioButton.setText(_translate("MainWindow", "10"))
        self.yOffsetStep100radioButton.setText(_translate("MainWindow", "100"))
        self.yOffsetStep1000radioButton.setText(_translate("MainWindow", "1000"))
        self.yOffsetLabel1.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel1.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel1.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel1.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel2.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel2.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel2.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel2.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel3.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel3.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel3.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel3.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel4.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel4.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel4.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel4.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel5.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel5.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel5.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel5.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel6.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel6.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel6.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel6.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel7.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel7.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel7.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel7.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel8.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel8.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel8.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel8.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel9.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel9.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel9.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel9.setText(_translate("MainWindow", "    X offset:"))
        self.yOffsetLabel10.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.yOffsetLabel10.setText(_translate("MainWindow", "Y offset:"))
        self.xOffsetLabel10.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.xOffsetLabel10.setText(_translate("MainWindow", "    X offset:"))
        self.smoothingLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>The value entered in this box does not take effect until either the <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> key is pressed or this box loses focus when you click on some other widget.</p><p><span style=\" font-weight:600; color:#fc0107;\">Best practice:</span> Click inside the box, then use the <span style=\" font-weight:600; color:#0000ff;\">up/down arrow</span> keys to set the desired value, then press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span>. Repeating is easy because the cursor does not leave the box.</p><p>Of course, you can always edit the value directly using the keyboard - just remember to press <span style=\" font-weight:600; color:#0000ff;\">return/enter</span> to complete the operation.</p></body></html>"))
        self.smoothingLabel.setText(_translate("MainWindow", "smoothing readings"))
        self.label_32.setText(_translate("MainWindow", "Set step:"))
        self.stepBy2radioButton.setText(_translate("MainWindow", "2"))
        self.stepBy10radioButton.setText(_translate("MainWindow", "10"))
        self.stepBy100radioButton.setText(_translate("MainWindow", "100"))
        self.normMarkBaselineRegionButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is used to select the points in the normalized target lightcurve to be used in calculating the metic that, when minimized, results in the flattest and most level target lightcurve.</p><p>It is sometimes useful to only include some regions of the target lightcurve. To do this, click on two points that enclose the points to be included, then click this button. The included points will change color.</p><p>Multiple regions can be selected. Just repeat the above procedure.</p><p>The selected regions can be cleared by clicking on the button (<span style=\" font-weight:600; color:#0000ff;\">Clear metric points</span>) to the right of this button.</p></body></html>"))
        self.normMarkBaselineRegionButton.setText(_translate("MainWindow", "Mark metric points"))
        self.clearMetricPointsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click this button to erase any previously selected regions of metric points.</p></body></html>"))
        self.clearMetricPointsButton.setText(_translate("MainWindow", "Clear metric points"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_2), _translate("MainWindow", "Lightcurves"))
        self.minEventLabel.setText(_translate("MainWindow", "min event:"))
        self.minEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter smallest event size (in number of readings) to search for.</p></body></html>"))
        self.maxEventLabel.setText(_translate("MainWindow", "max event:"))
        self.maxEventEdit.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter largest event size (in number of readings) to search for.</p></body></html>"))
        self.markDzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star disappears, then click this button to create a D search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If no points are selected, a search for a D transition will not be performed --- this becomes an \'R only\' event.</span></p></body></html>"))
        self.markDzone.setText(_translate("MainWindow", "Mark D region"))
        self.markRzone.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Select two points in the primary (dark blue) light curve, one on each side of where the star reappears, then click this button to create an R search area.</span><br/></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If no points are selected, a search for an R transition will not be performed --- this becomes a \'D only\' event.</span></p></body></html>"))
        self.markRzone.setText(_translate("MainWindow", "Mark R region"))
        self.markEzone.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button is only active when a Night Eagle 3 analysis is being performed.</p><p>The Night Eagle 3 has an effective noise reduction system that has the side effect of producing an exponential decay of intensity toward the ultimate event intensity level during a D transition. As a result, only a portion of the points in the event bottom are reliable indicators of the correct event intensity. This effect is visually obvious for the DNR:HIGH setting, much less so for the DNR:MIDDLE setting, and hard to detect at the DNR:LOW setting.</p><p>Usage is simple: click on two points that enclose the desired points to use for event parameter estimation (mean and noise), then click this button.</p><p>Clicking this button with no points selected will clear any previous selections.</p></body></html>"))
        self.markEzone.setText(_translate("MainWindow", "mark Event points to use"))
        self.doBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Light curves from integrated videos must be block integrated before further processing is carried out.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">An automatic determination of the correct block size and starting point (offset) will be performed if no points have been selected.&nbsp;You will have the opportunity to accept or reject the result of this automatic process using the button to the right (</span><span style=\" font-family:\'arial,sans-serif\'; font-weight:600; color:#fc0107;\">Accept auto integration</span><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">).</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">If a manual selection is necessary,&nbsp;then the procedure stated below can be performed:</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">Zoom into a small portion of the light curve and locate a clearly identifiable group of data points that belong to an integration block,&nbsp;click on the first and last point of that data point group,&nbsp;then press this button to integrate all such groups in the light curve into a single data points.</span></p><p><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\">&nbsp;A block integration,&nbsp;either manual or automatic,&nbsp;can be performed only once per data file;&nbsp;it cannnot be undone by use of the </span><span style=\" font-family:\'arial,sans-serif\'; font-weight:600; color:#fc0107;\">Start over</span><span style=\" font-family:\'arial,sans-serif\'; color:#222222;\"> button.&nbsp;Instead,&nbsp;you will need to re-read the file.</span></p></body></html>"))
        self.doBlockIntegration.setText(_translate("MainWindow", "Manual/automatic block integrate"))
        self.acceptBlockIntegration.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button will be enabled only after pyote has proposed a block integration. If, after examining the proposed block size and offset shown on the light curve, you wish to apply the integration, press this button.</p></body></html>"))
        self.acceptBlockIntegration.setText(_translate("MainWindow", "Accept auto block integration"))
        self.setDataLimits.setToolTip(_translate("MainWindow", "<html><head/><body><p>If exactly two data points have been selected, this button will <span style=\" font-weight:600; text-decoration: underline;\">trim</span> off (exclude) data points to the left and right of the selected points. The excluded points will shown in light gray.</p><p>If no points have been selected, then all data points will be selected as the default.</p><p>Once a trim has been performed, its effects can be removed by clicking on the <span style=\" font-weight:600; color:#fc0107;\">Start over</span> button.</p></body></html>"))
        self.setDataLimits.setText(_translate("MainWindow", "Trim left/right"))
        self.markRegionsLabel.setText(_translate("MainWindow", "<html><head/><body><p>When edges are clearly visible, mark points to specify region and click ...</p></body></html>"))
        self.minMaxLabel.setText(_translate("MainWindow", "... otherwise use the entries below to place bounds on the event size."))
        self.findEventLabel.setText(_translate("MainWindow", "Finally, click on \'Find event\' and, if event found, click \'... write report\'"))
        self.locateEvent.setText(_translate("MainWindow", "Find event, then ..."))
        self.calcErrBars.setToolTip(_translate("MainWindow", "<html><head/><body><p>To get a \'Final Report\', error bars are required. Clicking this button will start the computation of those error bars and, when complete, trigger the preparation of a \'Final Report\'</p></body></html>"))
        self.calcErrBars.setText(_translate("MainWindow", "... write report"))
        self.helpLabelForFalsePositive.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#fc0107;\">Advisory =============================================</span></p><p>Assuming that you have been diligent in removing common lightcurve artifacts (dips caused by something other than an occultation, &nbsp;like clouds,&nbsp;or a contrail,&nbsp;or ...) using the normalization function,&nbsp;please be aware that ...</p><p>... a non-zero False Positive probability (red bar to the left of the black bar) is usually sufficient reason to report a \'miss\' (but see note below).<span style=\" font-weight:600; color:#fc0107;\"> But</span>,&nbsp;before reporting a \'miss\',&nbsp;you should use the Event Detectability calculator to determine if the event was \'detectable\'.&nbsp;If the event was \'detectable\' and yet a \'miss\',&nbsp;the observation has value in constraining one edge of the asteroid.&nbsp;If the \'miss\' was of an \'undetectable\' event,&nbsp;its value as a constraint on the asteroid edge is greatly diminished.</p><p><span style=\" font-weight:600; color:#fc0107;\">However</span>,&nbsp; a False Positive probability of zero (red bar to the right of the black bar) should <span style=\" font-weight:600; color:#fc0107;\">NEVER</span> be the sole reason to report a \'positive\'.</p><p>If you get a zero False Positive probability <span style=\" font-weight:600; text-decoration: underline;\">and this is the only available chord</span>,&nbsp;look at the False Positive distribution plot and only consider reporting a \'positive\' if the measured drop is well to the right of the black bar (which shows the biggest drop found during the simulation run). \'Well to the right\' is rather vague,&nbsp;so consult with your area coordinator whenever you are uncertain.</p><p><span style=\" font-weight:600; color:#fc0107;\">Note:</span> if your observed \'drop\' (red bar) is near the black bar (on either side!) AND there are nearby chords reporting \'positives\',&nbsp;there may be value in your observation in spite of the False Positive probability calculation result;&nbsp;your observation may increase confidence in the event recorded by the nearby chords.<br/></p></body></html>"))
        self.fillExcelReportButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to copy your results to the Asteroid Occultation Report Form (.xlsx spreadsheet - note file type is .xlsx, not .xls). This button will be inactive (grayed out) until a succesful <span style=\" font-weight:600; color:#0000ff;\">... write report</span> has been accomplished.</p><p>The expected workflow is:</p><p>1) Given that PyOTE now has a solution that you wish to report (an occultation), leave PyOTE open ...</p><p>2) Run OccultWatcher to enter your event result report. Be sure to ask for a \'prefill\' of the .xls version of the report ...</p><p><span style=\" font-weight:600; color:#fc0107;\">3) Convert that .xls file to .xlsx using either Excel (Windows) or LibreOffice (Mac or Linux)</span></p><p>4) Go back to PyOTE and click this button ...</p><p>5) A file dialog will open; locate and select the prefilled and converted .xlsx report from steps 2 and 3.</p><p>6) If the file selected in step 5 was a valid Asteroid Occultation Report Form .xlsx file, the PyOTE results will be inserted.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: the excel format change from .xls to .xlsx will not affect the downstream processing adversely as the tool in use accepts either format equally well.</span></p><p><br/>The values that are inserted are:</p><p>--- all error bars</p><p>--- uncorrected D and/or R times</p><p>--- SNR</p><p>--- OTA used (PYOTE)</p><p>---A sentence summarizing magDrop information will be added in the Comments box</p></body></html>"))
        self.fillExcelReportButton.setText(_translate("MainWindow", "... fill Excel report"))
        self.cancelButton.setText(_translate("MainWindow", "Cancel"))
        self.writePlot.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: At the conclusion of error bar calculations, PYOTE automatically writes the main plot to a png file using the name and directory of the just-processed csv file. </p><p>If you want/need to record other versions of that plot, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.<br/></p></body></html>"))
        self.writePlot.setText(_translate("MainWindow", "Write current plot"))
        self.writeBarPlots.setToolTip(_translate("MainWindow", "<html><head/><body><p>Note: At the conclusion of error bar calculations, PYOTE automatically writes the error bar plots to appropriately named png files using the name and directory of the just-processed csv file. </p><p>If you want/need to record other versions of those plots, click here to open a dialog that will let you specify a different name and/or location for the storage of the new graphics.</p></body></html>"))
        self.writeBarPlots.setText(_translate("MainWindow", "Write error bar plot"))
        self.writeCSVButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to write the contents of the data table below to a csv file.</p><p>The comment lines from the original input file are preserved.</p><p>The most common use for this function is to capture the result of a successful Manual Timestamp Entry for later use (without the need to again go through the manual timestamp entry procedure). It will also reflect any Block Integration that was applied.</p></body></html>"))
        self.writeCSVButton.setText(_translate("MainWindow", "Save current light curve to .csv"))
        self.startOver.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button removes any trim that is in effect, clears a solution that may have been found,  and removes any D or R region showing.</p><p>It does <span style=\" font-weight:600; font-style:italic; color:#fc0107;\">not</span> undo block integration -- you must reload the light curve file to recover from a block integration.</p><p>Normalization can be undone by simply returning the smoothing inteval number to 0 (This is in the <span style=\" font-weight:600; color:#0000ff;\">lightcurves</span> panel.)</p></body></html>"))
        self.startOver.setText(_translate("MainWindow", "Start over"))
        self.singlePointDropButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Sometimes an occultation event may be so short that there will be only a single point recorded. In this case, because it is not possible to determine the duration of the event (only an upper bound can be stated) and the noise level during the event is also not measurable, the usual light-curve fitting procedure cannot (should not) be carried out.</p><p>But, it is possible to use the mechanism of the False-Positive report to determine whether the observed drop is just an artifact of baseline noise or is a deep enough drop that it is statistically unlikely that the drop is due to noise alone and so a positive can be reported with an appropriately chosen duration and error bar to reflect the timing ambiguity inherent in such a single point event.</p><p>To use this tool, first go to the Noise Analysis/Detectability tab and use the baseline points selection tool to identify the points that are considered valid baseline points (by multiple applications of the <span style=\" font-weight:600; color:#0000ff;\">Mark baseline region </span><span style=\" color:#000000;\">button</span>) excluding the point to be tested, then click the <span style=\" font-weight:600; color:#0000ff;\">Calc baseline mean/sigma/corr coeff</span> button.</p><p>Then, click on the single point to be tested (the point will change to a red dot), and click this button.</p></body></html>"))
        self.singlePointDropButton.setText(_translate("MainWindow", "Validate a potential single point event"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.analysisTab), _translate("MainWindow", "Analysis"))
        self.underlyingLightcurveLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This group of edit boxes allows the parameters for an observation-appropriate \'underlying lightcurve\' to be entered.</p><p>We define the \'underlying lightcurve\' thusly: it is the theoretical intensity of the light diffracted at the occulting edge (assumed straight) as a function of time, i.e. as the shadow of the occulting body passes the observation position, and includes the effect of a possibly finite star disk.  Click the <span style=\" font-weight:600; color:#fc0107;\">Demo</span> button to get a preview of this underlying lightcurve to make sure that the parameters are reasonable and, <span style=\" color:#fc0107;\">most importantly, have been entered without error</span> because these values will be used once a \'solution\' has been found.</p><p>Diffraction intensity has a wavelength dependence. In PyOTE, we compute a generic diffraction curve composed of light wavelengths in the 400nm to 600nm range (using 5 nm steps) with equal intensities at each included wavelength. The region of the diffraction curve that is of most interest to us is only about +/- 1 Fresnel unit on either side of the geometrical shadow point. Fortunately, in that region, there is very little difference between a narrow band of light wavelengths and a wide band of light wavelengths, so there is no practical need to specify a more realistic bandpass in terms of either shape (amplitudes) or extent (bandpass). The primary effect of a wide bandpass is to greatly reduce the oscillations seen in a single wavelength diffraction curve (i.e., the one that is most frequently used to show diffraction effects).</p><p>If the star has a finite disk, the effect on the underlying lightcurve is usually very significant and apparent, \'integrating\' away most of the characteristic diffraction curve shape and moving toward what is often referred to as a penumbral shape. It also moves the value of the intensity at the geometrical shadow point from 25% of full scale up to something close to 50% of full scale.</p><p>If you leave the exposure duration (exp dur: edit box) empty, the result of clicking the <span style=\" font-weight:600; color:#fc0107;\">Demo</span> button will be a display of the underlying light curve shape. To see the effect of the camera exposure time, which integrates the underlying light curve to produce what we refer to as the camera response, fill in the effective exposure time, taking into account the observation frame rate and number of frames being integrated. Note: this field will be updated/filled in automatically when an observation with timing data is loaded and, if necessary, integrated.</p><p>If a <span style=\" font-weight:600; color:#fc0107;\">Demo</span> is run before \'solution\' baseline and event intensities have been determined, generic values of 100.0 (baseline intensity) and 0.0 (event intensity) are used. If \'real\' baseline and event intensities are available, they are used instead.</p></body></html>"))
        self.underlyingLightcurveLabel.setText(_translate("MainWindow", "Set these parameters to calculate diffraction, star disk, and centerline offset effects for the observation."))
        self.exposureTimeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the effective camera exposure time (shutter time) in seconds, taking into account camera integration of frames if that was employed in this observation.</p><p>This box will normally be filled automatically when a file is read that has timing information included.</p><p>The value in this box will also be updated whenever and integration operation changes the frame duration.</p></body></html>"))
        self.exposureTimeLabel.setText(_translate("MainWindow", "  exposure:"))
        self.asteroidDistanceLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the distance to the asteroid/occulting body.</p><p>For distance units, use AU (Astronomical units)</p><p>Note: If parallax (in arc seconds) to the asteroid is available instead of distance in AU, the distance to the asteroid can be calculated with the equation:</p><p align=\"center\"><span style=\" font-size:18pt; font-weight:600;\">distance(AU) = 8.7882 / parallax(arc seconds)</span></p></body></html>"))
        self.asteroidDistanceLabel.setText(_translate("MainWindow", "  asteroid dist(AU):"))
        self.shadowSpeedLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the speed of the occulting body in kilometers per second.</p><p>This is used as the speed of the occultation shadow projected on the earth.</p><p>This value is used to convert the diffraction pattern, which is calculated as a function of Fresnel units, to a function of time.</p><p>If the asteroid speed is not given but its diameter and the maximum expected event duration is known, the asteroid speed can be calculated with this equation:</p><p align=\"center\"><span style=\" font-size:18pt; font-weight:600;\">asteroid speed (km/sec) = asteroid diameter(km) / max duration(seconds)</span></p></body></html>"))
        self.shadowSpeedLabel.setText(_translate("MainWindow", "  asteroid speed(km/sec):"))
        self.asteroidSizeLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>In order to calculate the effect on the underlying diffraction lightcurve of an observation that is not on the centerline of the asteroid track (a \'graze\'), two pieces of information are required:</p><p>1) The asteroid diameter (expressed in km) (enter in this edit box)</p><p>2) The distance (in km) left or right of the asteroid track centerline of the observation position</p></body></html>"))
        self.asteroidSizeLabel.setText(_translate("MainWindow", " asteroid diameter(km):"))
        self.pathOffsetLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>In order to calculate the effect on the underlying diffraction lightcurve of an observation that is not on the centerline of the asteroid track (a \'graze\'), two pieces of information are required:</p><p>1) The asteroid diameter (expressed in km)</p><p>2) The distance (in km) left or right of the asteroid track centerline of the observation position (enter in this edit box)</p></body></html>"))
        self.pathOffsetLabel.setText(_translate("MainWindow", " observation centerline offset(km):"))
        self.starDiameterLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If the star being occulted is not point-like but rather has a finite disk, enter its diameter in milli-arcseconds (mas) in this box.</p><p>This value is used, in conjunction with the values entered in the <span style=\" font-weight:600; color:#fc0107;\">dist(AU)</span> box and the <span style=\" font-weight:600; color:#fc0107;\">speed(km/sec)</span> box, to calculate the apparent size of the star at the asteroid distance as a function of time. This is convolved with the diffraction light curve to get the underlying light curve (instantaneous values).</p><p>The underlying lightcurve is what is seen and integrated during the camera exposure time to get the camera response.</p></body></html>"))
        self.starDiameterLabel.setText(_translate("MainWindow", "Star diam(mas):"))
        self.dLimbAngleLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>When the star has a perceptible disk, the angle of the asteroid limb with respect to the direction of motion changes the time duration during which the projected star image passes your observation position and therefore modifies the underlying light curve at that limb edge.</p><p>Angles are entered in degrees with 90 degrees used to reflect a head-on no-graze configuration.</p></body></html>"))
        self.dLimbAngleLabel.setText(_translate("MainWindow", "      D limb angle:"))
        self.rLimbAngleLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>When the star has a perceptible disk, the angle of the asteroid limb with respect to the direction of motion changes the time duration during which the projected star image passes your observation position and therefore modifies the underlying light curve at that limb edge.</p><p>Angles are entered in degrees with 90 degrees used to reflect a head-on no-graze configuration.</p></body></html>"))
        self.rLimbAngleLabel.setText(_translate("MainWindow", "      R limb angle:"))
        self.demoUnderlyingLighturvesButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button demonstrates the computation of the lightcurve used in determining the time of the geometric shadow edge, given the observation parameters set in the edit boxes in this edit box group. It can be a useful tool in gaining an understanding of diffraction (and other) effects.</p><p>If values have been entered in the two boxes to the right (asteroid distance, and speed), the 400nm to 600nm bandpass integrated analytic diffraction lightcurve will be computed and displayed.</p><p>We refer to this as the \'underlying lightcurve\': it is the theoretical (instantaneous) intensity of the light diffracted at the occulting edge as a function of time, i.e. as the shadow of the occulting body passes an observation position that is <span style=\" text-decoration: underline;\">on the path centerline</span>.</p><p>The \'underlying lightcurve\' will be further modified by:</p><p>1. the camera exposure function (which acts as an integrator)</p><p>2. the position of observation with respect to the asteroid path centerline (because of the 2D nature of the diffracted asteroid image)</p><p>3. a target star that has a discernible disk</p><p>The instantaneous underlying lightcurve (with correction for an off-centerline observation) is modified by the camera exposure function and, if the star has a discernible disk, the star intensity function. The resulting composite lightcurve is mathematically the convolution of the underlying lightcurve with the camera exposure function and possibly the star intensity function.</p><p>(Technically a convolution is defined as the integral of the product of two functions after one is reversed and shifted - the integral is evaluated for all values of shift to produce the modified function.)</p><p><span style=\" font-family:\'Helvetica\';\">The camera exposure function is defined as equal to 1.0 while the shutter is open, and 0.0 at all other times. (A \'boxcar\' integration)</span></p><p><span style=\" font-family:\'Helvetica\';\">The star intensity function is the chord length across the diameter of the star.</span></p><p>These two functions are plotted on the demonstration graph (at half intensity to avoid overlap with the baseline) so that one can see the functions that are being convolved and to make it easy to see how much of an effect should be expected.</p><p>Diffraction intensity has a wavelength dependence. In PyOTE, we compute a generic diffraction curve composed of light wavelengths in the 400nm to 600nm range (using 5 nm steps) with equal intensities at each included wavelength. The region of the diffraction curve that is of most interest to us is only about +/- 1 Fresnel unit on either side of the geometrical shadow point. Fortunately, in that region, there is very little difference between a narrow band of light wavelengths and a wide band of light wavelengths, so there is no practical need to specify a more realistic bandpass in terms of either shape (amplitudes) or extent (bandpass). The primary effect of a wide bandpass is to greatly reduce the oscillations seen in a single wavelength diffraction curve (i.e., the one that is most frequently used to show diffraction effects).</p><p>If the star has a finite disk, the effect on the underlying lightcurve is usually very significant and apparent, \'integrating\' away most of the characteristic diffraction curve shape and moving toward what is often referred to as a penumbral shape. It also moves the value of the intensity at the geometrical shadow point from up to something close to 50% of full scale.</p><p>If you leave the exposure duration (exp dur: edit box) empty, the result of clicking this button will be a display of the underlying light curve shape. To see the effect of the camera exposure time, which integrates the underlying light curve to produce what we refer to as the camera response, fill in the effective exposure time, taking into account the observation frame rate and number of frames being integrated. Note: this field will be updated/filled in automatically when an observation with timing data is loaded and, if necessary, integrated.</p><p>If this demo is run before \'solution\' baseline and event intensities have been determined, generic values of 100.0 (baseline intensity) and 0.0 (event intensity) are used. If \'real\' baseline and event intensities are available, they are used instead.</p></body></html>"))
        self.demoUnderlyingLighturvesButton.setText(_translate("MainWindow", "Demo (show theoretical light curve)"))
        self.enableDiffractionCalculationBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This checkbox enables the application of diffraction effects to the underlying lightcurve. Usually, you will want to use diffraction effects for the underlying lightcurve, so this box is checked by default.</p><p>But sometimes you may want to use a pure penumbral curve when the star has a finite disk. In that case, uncheck this box.</p><p>This is also useful as learning/demonstration tool when exploring what effects the underlying lightcurve.</p></body></html>"))
        self.enableDiffractionCalculationBox.setText(_translate("MainWindow", "use diffraction in solution "))
        self.penumbralFitCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If an occultation involves a star that is not point-like (has a detectable disk), the observation lightcurve will often have a gradual transition and take more than one or two readings for the disappearance and/or reappearance to occur. To extract timing data from such an observation, an underlying lightcurve model that incorporates star diameter (mas) and limb angles must be used.</p><p><span style=\" font-weight:600;\">This checkbox will be enabled whenever a star diameter is entered below AND the </span><span style=\" font-weight:600; color:#fc0107;\">Demo</span><span style=\" font-weight:600;\"> button has been clicked. You WILL forget this; it happens to me. No worries; nothing breaks. Just right-click and refresh your memory!</span></p><p><span style=\" font-weight:600; color:#0000ff;\">Please use the example-penumbra.csv file that is provided in the download for practice.</span> (This file may be hard to find as it is placed wherever your system stores the PyOTE application files. Best advice is to do a search of the entire drive for the exact file name, then copy it to a more convenient place.) The header lines in that file give you good values to use for asteroid distance, asteroid speed, and star diameter to start with. Find the supplied file with a file-search --- <span style=\" font-weight:600; color:#fc0107;\">move it somewhere else to play with - don\'t clutter up your software installation directory with the PyOTE files that are generated during normal processing - nothing bad will happen if you fail to heed this advice, but it\'s good practice to follow this advice.</span></p><p>Once this checkbox is checked (and you will forget to do this sometimes too!), the <span style=\" font-weight:600; color:#fc0107;\">Find event, then ...</span> button will invoke the \'penumbral fit\' methodology. When the \'penumbral fit\' methodology is active, the user is expected to:</p><p><span style=\" font-weight:600; color:#fc0107;\">1.</span> Carefully locate the D and or R regions so that the penumbral transition regions are precisely enclosed. Use the <span style=\" font-weight:600; color:#fc0107;\">Mark D region</span> button and the <span style=\" font-weight:600; color:#fc0107;\">Mark R region</span> button in the usual way.</p><p>This allows PyOTE to identify/assume the points to the left and right of the D and/or R regions are baseline points so as to compute a correct baseline intensity and its associated noise. This also allows the points between the D and/or R regions to be used for the computation of the correct event intensity and its associated noise.</p><p><span style=\" font-weight:600; color:#fc0107;\">2.</span> Repeatedly click the <span style=\" font-weight:600; color:#fc0107;\">Find event, then ...</span> button, evalute the \'fit\' visually, and change the limb angles until satisfied (watch the \'metric\' to see how you are doing), then</p><p><span style=\" font-weight:600; color:#fc0107;\">3.</span> Click the <span style=\" font-weight:600; color:#fc0107;\">... write report</span> button, as usual.</p><p>The D and/or R edge times will not change significantly during the step 2 iterations; they are only performed to get an estimate of the D and/or R limb angles, so a good visual fit should be adequate.</p><p>It is a characteristic of penumbral curves that they are \'under-constrained\' in that there is NOT a unique set of values for star diameter and the two limb angles. It is <span style=\" text-decoration: underline;\">always</span> the case that, given a star diameter and limb angles of 90 degrees (head-on), there is a smaller star diameter with smaller limb angles that will result in exactly the same lightcurve. Usually, the star diameter will be reasonably well known, so that value is held fixed while one adjusts the D and R limb angles until a satisfactory fit is found.</p></body></html>"))
        self.penumbralFitCheckBox.setText(_translate("MainWindow", "Penumbral fit   "))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.diffractionTab), _translate("MainWindow", "Diffraction"))
        self.calcFlashEdge.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button calculates the fractional frame number at which the start of a timing flash occurred.</p><p>Click a point on either side of the R event (leading edge) of a timing flash, then click the <span style=\" font-weight:600; color:#fc0107;\">Calc flash edge</span> button (this one). Start with the earliest edge, then repeat the procedure on the second edge (if present --- it is highly recommended to use goal-post flashes that bracket the event).</p><p>Next, click the <span style=\" color:#fc0107;\">M</span><span style=\" font-weight:600; color:#fc0107;\">anual timestamp entry</span> button to bring up a dialog for entering manual timestamp data. The calculated frame values for the edges will be automatically pre-filled in the form. You only need enter the corresponding flash time values from the flash app log and click <span style=\" font-weight:600; color:#fc0107;\">Ok </span><span style=\" color:#000000;\">to trigger timestamp calculations for all points</span>.</p><p><br/></p></body></html>"))
        self.calcFlashEdge.setText(_translate("MainWindow", "Calc flash edge"))
        self.manualTimestampCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">This checkbox makes the </span><span style=\" font-size:18pt; font-weight:600; color:#fc0107;\">Manual timestamp entry</span><span style=\" font-size:18pt;\"> button active. You will need/use that button when processing a light curve that employs \'flash timing\' instead of a VTI.</span></p><p><span style=\" font-size:18pt;\">Manual entry of timestamp information is also useful if there </span><span style=\" font-size:18pt; font-weight:600; text-decoration: underline;\">are</span><span style=\" font-size:18pt;\"> timestamps, but manual entry of timing information is required because of major errors in those timestamps.</span></p><p><span style=\" font-size:18pt;\">NOTE: timestamps are ALWAYS treated as start-of-exposure times.</span></p></body></html>"))
        self.manualTimestampCheckBox.setText(_translate("MainWindow", "Enable manual timestamp entry"))
        self.manualEntryPushButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This button causes a dialog to appear in which timestamp information may be entered. This is needed if \'flash timing\' is being utilized.</p><p>It is also useful when OCR of a VTI overlay has a high error rate, but enough entries have been properly read that \'goal post\' timing (use of two times that bracket the event to provide the timing information by interpolation) can be used.</p><p>NOTE: timestamps are ALWAYS treated as start-of-exposure times.</p></body></html>"))
        self.manualEntryPushButton.setText(_translate("MainWindow", "Manual timestamp entry"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_9), _translate("MainWindow", "Manual timestamps"))
        self.allowNewVersionPopupCheckbox.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-weight:600; color:#0000ff;\">What\'s new:</span></p><p><span style=\" color:#000000;\">An option has been added to the Analysis tab that allows a possible single point drop to be evaluated as a potential event.</span></p><p><span style=\" color:#000000;\">A single point event cannot be evaluated by the usual methods because the duration of the event is ambiguous (it only has an upper limit of a reading time, but insufficient information to compute a lower limit) and the noise level of a single point is zero or meaningless (your choice) so error bar calculations are disrupted as well. But it is still possible to ask the question \'is that drop just due to noise or is it more likely caused by a short duration occultation?\'. The tool to answer that question is the False-Positive test which addresses that exact question. The new option makes it possible to subject a single point to a False-Positive examination.</span></p><p><span style=\" font-weight:600; color:#fc0107;\">This version also contains new GUI and analysis features. Be sure and read all the applicable help by clicking on applicable HELP buttons and by right-clicking on text labels of new features.</span></p><p>This popup can be disabled in the Settings/Misc tab. There is a checkbox provided there for this function. Note: right click on that checkbox at any time to see the new version description.</p></body></html>"))
        self.allowNewVersionPopupCheckbox.setText(_translate("MainWindow", "allow \'new version\' information pop-up"))
        self.label.setText(_translate("MainWindow", "Check any of the following plot options you wish to be active during the analysis."))
        self.showTimestampErrors.setToolTip(_translate("MainWindow", "<html><head/><body><p>Timestamp errors are indicated by red lines that show where a time step is not within +/- 10% of the expected value.</p><p>Sometimes there are so many red lines that is becomes hard to see the plot. In that case, uncheck this box to suppress the red line display.</p></body></html>"))
        self.showTimestampErrors.setText(_translate("MainWindow", "time err "))
        self.showCameraResponseCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>The \'camera response curve\' shows what the camera output would be given the underlying light curve (shown in brown) position.</p><p>It assumes the camera linearly accumulates light during the exposure interval. The model is: the camera integrates/accumulates light during the exposure time, then emits tha result immediately (which may not be true for many cameras, but the camera delay tables used during final reports will make the needed correction).</p></body></html>"))
        self.showCameraResponseCheckBox.setText(_translate("MainWindow", "camera response"))
        self.showUnderlyingLightcurveCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Check this box if you want a plot of the \'light\' the camera sees.</p></body></html>"))
        self.showUnderlyingLightcurveCheckBox.setText(_translate("MainWindow", "raw light"))
        self.showErrBarsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you do not want to see the vertical dashed lines that show the 95% containment interval error bars for D and/or R, uncheck this box.</p></body></html>"))
        self.showErrBarsCheckBox.setText(_translate("MainWindow", "err bars"))
        self.showEdgesCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you do not want to see the D and/or R edges marked with a vertical dashed line on the \'solution\', uncheck this box.</p></body></html>"))
        self.showEdgesCheckBox.setText(_translate("MainWindow", "edges"))
        self.showOCRcheckFramesCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Uncheck this box if you do not need to see the D and/or R frames from the video automatically displayed to verify that timestamp OCR was correct.</p><p><span style=\" font-weight:600; color:#0000ff;\">Background:</span> if the video that produced the csv being analyzed is still in its original location, PyOTE will access that video whenever an event has been found and the critical frames that determine the reported times will be displayed. The timing data used for the report is displayed in the title of each displayed frame, allowing a user to visually confirm that the OCR timestamp extraction was correct.</p><p>NOTE: timestamps are ALWAY treated as start-of-exposure times.</p></body></html>"))
        self.showOCRcheckFramesCheckBox.setText(_translate("MainWindow", "Do OCR check"))
        self.showTimestampsCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>If you want frame numbers used on the x-xaxis,&nbsp;uncheck this box.&nbsp;Otherwise,&nbsp;if timestamps are available,&nbsp;they will be used to annotate the x-axis.</p></body></html>"))
        self.showTimestampsCheckBox.setText(_translate("MainWindow", "timestamps"))
        self.label_2.setText(_translate("MainWindow", "Use View Frame to import a video image of a specific frame number."))
        self.viewFrameButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this button to view a frame from the video that was used by PyMovie or Limovie to prepare the csv file that is currently being analyzed. Currently .avi and .ser files are viewable in this manner as well as .fits files inside a FITS folder.</p><p>If this button is disabled, it is because the csv file did not come from PyMovie or Limovie or simply cannot be found/opened.</p><p>This feature can/should be used as a final quality control check for a video that contains timestamps extracted using OCR. It is possible for OCR to fail in manner that is <span style=\" font-weight:600; color:#fc0107;\">not detected</span> by PyOTE because the program only verifies that there is a consistent step (delata time) between frames. If a high order digit has been consistently misread, like reading an 8 as a 9 in the minutes field, the steps can be consistent but the reported time of the event will be wrong.</p><p>ALL time reporting is derived from the single timestamp(s) associated with D and/or R (the integer values, not the sub-frame values). If those timestamps are correct, the reported times will be correct even when there may be a few missing or duplicated frames and all other timestamps are wrong. So, best practice is to enter the D frame value in the spin box and visually confirm that the timestamp that you can see is the same as that extracted by the OCR procedure. Repeat for R.</p><p>Another use for this feature is to handle the case where there is a visual timestamp that can be seen in the video, but either OCR was not activated during the .csv preparation, or the timestamp overlay came from an unsupported VTI type. The workflow in this case is to let PyOTE find the D and R values, but before doing <span style=\" font-weight:600; color:#fc0107;\">... write report</span>, do a <span style=\" font-weight:600; color:#fc0107;\">Manual timestamp entry</span> for the D and R values found by viewing the relevant frames and entering the correct times in the Manual timestamp dialog.</p><p>Note that timestamps can be entered manually even if timestamps are already present in the file. The manual timestamps will be calculated and used to replace those already there.</p></body></html>"))
        self.viewFrameButton.setText(_translate("MainWindow", "View frame from associated video"))
        self.frameNumSpinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spin box (which may be directly edited) to select the number of the frame/image you want to see.</p><p>The upper limit and lower limits for allowed numbers in this spin box are set when the csv is read, which sometimes only contains a subset of the frames available in the video.  If your \'edit\' is refused, it is because you are trying to enter a number outside the range allowed, which is always restricted to frame numbers that actually appear in the csv file.</p></body></html>"))
        self.label_3.setText(_translate("MainWindow", "Use the check boxes to change the view of the imported video image."))
        self.fieldViewCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>For videos from a composite video camera, check this box to view the frame as two fields.</p></body></html>"))
        self.fieldViewCheckBox.setText(_translate("MainWindow", "field view"))
        self.flipYaxisCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Checking this box will rotate/flip the image around the horizontal axis. (Flips top to bottom.)</p></body></html>"))
        self.flipYaxisCheckBox.setText(_translate("MainWindow", "flip top/bottom"))
        self.flipXaxisCheckBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>Check this box if you need to rotate/flip the image around the vertical axis. (Flip left to right.)</p></body></html>"))
        self.flipXaxisCheckBox.setText(_translate("MainWindow", "flip left/right"))
        self.label_4.setText(_translate("MainWindow", "Set the width of the error bars and light curve lines in the light curve plot."))
        self.lineWidthLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spinner sets the line width (in pixels) of the error bar lines, the geometric edge lines, and the lightcurve lines.  Adjust this to show these lines according to your taste and the resolution of your screen.</p></body></html>"))
        self.lineWidthLabel.setText(_translate("MainWindow", "line width"))
        self.label_31.setText(_translate("MainWindow", "<html><head/><body><p>Set the size of the dots used in lightcurve plots.</p></body></html>"))
        self.lineWidthLabel_2.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spinner sets the line width (in pixels) of the error bar lines, the geometric edge lines, and the lightcurve lines.  Adjust this to show these lines according to your taste and the resolution of your screen.</p></body></html>"))
        self.lineWidthLabel_2.setText(_translate("MainWindow", "dot size"))
        self.label_6.setText(_translate("MainWindow", "If the file is from PyMovie, you can select the kind of data to analyze ..."))
        self.label_7.setText(_translate("MainWindow", "... signal (background subtracted)  appsum (no background subtraction) ..."))
        self.label_8.setText(_translate("MainWindow", "... avgbkg (background value)  stdbkg (noise in background)  nmaskpx (pixel count in mask)"))
        self.label_5.setText(_translate("MainWindow", "PyMovie data column prefix"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.settingsTab), _translate("MainWindow", "Settings/Misc."))
        self.detectabilityHelpButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The primary use of this tool is to perform a \'detectability\' estimate. That estimate can be used to decide whether to attempt a future occultation observation or, to analyze an actual occultation observation to decide whether to report a <span style=\" color:#fc0107;\">\'miss\'</span><span style=\" color:#000000;\">,</span><span style=\" color:#fc0107;\"> \'qualified miss\'</span><span style=\" color:#000000;\">,</span><span style=\" color:#fc0107;\"/>or <span style=\" color:#fc0107;\">\'no observation\'</span>. Do this as follows:</p><p>1) If PyOTE could not find an event in an actual occultation observation and this tool says the event was detectable at a duration as short as one data frame, report a <span style=\" color:#fc0107;\">\'miss\'</span><span style=\" color:#000000;\">.</span></p><p><span style=\" color:#000000;\">2) If PyOTE could not find an event in an actual occultation observation and this tool says the event was detectable at more than one data frame duration, then report a</span><span style=\" color:#fc0107;\"> \'qualified miss for a duration greater than the detectable limit\'</span><span style=\" color:#000000;\"> and a </span><span style=\" color:#fc0107;\">\'no observation\'</span><span style=\" color:#000000;\"> for a duration shorter than the detectable limit.</span></p><p><span style=\" color:#000000;\">3) If PyOTE could not find an event in actual occultation observation and the tool says the event was not detectable at a duration of more than 1.5 X the predicted duration, then report a </span><span style=\" color:#fc0107;\">\'no observation\'</span><span style=\" color:#000000;\">.</span></p><p>This tool is also useful with observations that have employed a \'GPS Flasher\' to provide timing for the video observation.A side effect of having an LED light up at the entrance of your telescope is that it will affect the baseline values of the target star (and others) and so make it more difficult to extract the best possible baseline statistics (mean and noise-sigma and noise-correlation-coefficients) which benefit from having more points involved in the calculation.This tool allows the user to tell PyOTE where the baseline values are reliable enough(unaffected by flashes,or wind gusts,or telescope jostling,etc) to be used during baseline statistics calculation.</p><p>By repeatedly selecting pairs of points on the light curve being analyzed and clicking the <span style=\" font-weight:600; color:#0000ff;\">Mark baseline region</span> button,the regions of \'reliable baseline/event data\' can be designated.They will be shown as orangish points instead of the normal blue color.</p><p><span style=\" font-weight:600; color:#0000ff;\">NOTE:</span> Regions marked on one curve are automatically applied to all curves. </p><p>In general,normalization against a reference star should be performed first,then this operation.That will remove any \'trends\' that would affect the mean and noise-sigma.</p><p><span style=\" font-weight:600; color:#0000ff;\">FYI:</span> One can also use this feature to calculate statistics on some set of points of interest (like a statistics in the event bottom) or for reference stars or ...</p></body></html>"))
        self.detectabilityHelpButton.setText(_translate("MainWindow", "Help"))
        self.markBaselineRegionButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Click on pairs of points that enclose points that are valid to use for noise (and mean value) calculations. This can be repeated to select disjoint sets of valid points.</p></body></html>"))
        self.markBaselineRegionButton.setText(_translate("MainWindow", "Mark baseline region"))
        self.clearBaselineRegionsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clear all marked regions and any statistics that may have been extracted by clicking on this button: <span style=\" font-weight:600; color:#0000ff;\">Calc baseline mean/sigma/corr coeffs</span></p></body></html>"))
        self.clearBaselineRegionsButton.setText(_translate("MainWindow", "Clear baseline regions"))
        self.calcStatsFromBaselineRegionsButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>When this button is clicked,all the points included in the marked regions will be collected and used to calculate the baseline/event mean,noise-sigma,and the noise-correlation coefficients.Unless a \'trim\' is performed,these values will be used during error bar estimations and \'false-positive\' estimation.</p><p><span style=\" font-weight:600; color:#0000ff;\">NOTE:</span> If a \'trim\' is performed,<span style=\" font-weight:600;\">the baseline mean will be determined from the \'fit\' to the trimmed data,</span>but the noise-sigma and noise-correlation coefficients extracted from the marked \'background\' regions will continue to override those obtained from the trimmed light-curve.</p><p>This is done so that if the mean baseline level on either side of the event appears to be a little different than the overall baseline,one can get improved baseline noise stats by using points from the entire light-curve,yet trim the light-curve around the event and allow the \'finder/fitter\' to calculate a baseline mean from the immediately adjacent points.</p></body></html>"))
        self.calcStatsFromBaselineRegionsButton.setText(_translate("MainWindow", "Calc baseline mean/sigma/corr coeffs"))
        self.obsDurLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the length of the observation (in seconds). This allow the User to see how the detectability limit event looks in the context of a typical observation duration. Typically, 120 seconds is used (2 minutes).</p><p>A simulated observation light curve will be plotted. If you want to save this lightcurve as a csv file, put a check mark in the <span style=\" font-weight:600; color:#0000ff;\">Write example to csv file</span> checkbox.</p></body></html>"))
        self.obsDurLabel.setText(_translate("MainWindow", "ObservationDur(secs):"))
        self.eventDurLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the expected duration of the event in seconds (a duration of 1.5 times the predicted duration is recommended). </p></body></html>"))
        self.eventDurLabel.setText(_translate("MainWindow", "EventDur(secs):"))
        self.durStepLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>If this box contains 0 or is empty, a single detectability calculation and plot will be made for the <span style=\" font-weight:600; color:#0000ff;\">EventDur(secs)</span> entered.</p><p>If a non-zero entry is made in this edit box, a series of detectability calculations and plots will be made at ever shorter durations, decremented by the <span style=\" font-weight:600; color:#0000ff;\">duration step</span> entered, until the false-positive probability of the event becomes non-zero (greater than 0.0000).</p><p>The units here are seconds.</p></body></html>"))
        self.durStepLabel.setText(_translate("MainWindow", "  duration step:"))
        self.detectMagDropLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Enter the expected (predicted) magDrop as a positive number.</p></body></html>"))
        self.detectMagDropLabel.setText(_translate("MainWindow", "magDrop:"))
        self.calcDetectabilityButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The use of this tool is to perform a \'detectability\' estimate. That estimate can be used to decide whether to attempt a future occultation observation or, to analyze an actual occultation observation to decide whether to report a <span style=\" color:#fc0107;\">\'miss\'</span><span style=\" color:#000000;\">,</span><span style=\" color:#fc0107;\"> \'qualified miss\'</span><span style=\" color:#000000;\">,</span>or <span style=\" color:#fc0107;\">\'no observation\'</span>. Do this as follows:</p><p>1) If PyOTE could not find an event in an actual occultation observation and this tool says the event was <span style=\" text-decoration: underline;\">detectable</span> at a duration as short as one data frame, report a <span style=\" color:#fc0107;\">\'miss\'</span><span style=\" color:#000000;\">.</span></p><p><span style=\" color:#000000;\">2) If PyOTE could not find an event in an actual occultation observation and this tool says the event was </span><span style=\" text-decoration: underline; color:#000000;\">detectable</span><span style=\" color:#000000;\"> at more than one data frame duration, then report a</span><span style=\" color:#fc0107;\"> \'qualified miss for a duration greater than the detectable limit\'</span><span style=\" color:#000000;\"> and a </span><span style=\" color:#fc0107;\">\'no observation\'</span><span style=\" color:#000000;\"> for a duration shorter than the detectable limit.</span></p><p><span style=\" color:#000000;\">3) If PyOTE could not find an event in actual occultation observation and the tool says the event was not detectable at a duration of more than 1.5 X the predicted duration, then report a </span><span style=\" color:#fc0107;\">\'no observation\'</span><span style=\" color:#000000;\">.</span></p><p><span style=\" color:#fc0107;\">Please keep in mind that this is a simulation using random numbers, so repeated calculations with the same duration and magDrop will naturally give slightly different answers.</span></p><p>The workflow for determining the detectability of a future event is as follows:</p><p>1. Make a video of the target star with at least a few hundred frames. The video needs to be long enough and under the anticipated observation conditions and camera settings to be used during the actual event so that a valid estimate of the expected intensity of the target star, the noise level, and the correlation coefficients of that noise during the actual event can be obtained.</p><p>2. Use PyMovie (or Tangra or LiMovie) to extract a light-curve from the video.</p><p>3. Read the light-curve into PyOTE, then click on pairs of points in the light-curve plot to designate those points that should be used for the needed intensity and noise calculations. Click the <span style=\" font-weight:600; color:#0000ff;\">Mark Baseline Region</span> button to record your selection. This step can be repeated multiple times to select disjoint sets of points.</p><p>4. Now click the <span style=\" font-weight:600; color:#0000ff;\">Calc baseline mean/sigma/corr coefs</span> button - this is what triggers the extraction of the needed intensity and noise data, a pre-requisite to performing the next step:<span style=\" font-weight:600; color:#0000ff;\"> Calc detectability</span>.</p><p>5. Before clicking the <span style=\" font-weight:600; color:#0000ff;\">Calc detectability</span> button, you must fill in the observation duration (<span style=\" font-weight:600; color:#0000ff;\">ObservationDur</span>) in seconds and the expected duration of the event (<span style=\" font-weight:600; color:#0000ff;\">EventDur</span>) in seconds.</p><p>6. If you want the calculator to iteratively find the smallest duration of a detectable event for you, set <span style=\" font-weight:600; color:#0000ff;\">duration step</span> to a non-zero value (in seconds).</p><p>6. Next, fill in the expected <span style=\" font-weight:600; color:#0000ff;\">magDrop</span> (a positive number).</p><p>7. Click the<span style=\" font-weight:600; color:#0000ff;\"> Calc detectability</span> button and, after a pause while 50,000 trial observations are computed, a False-Positive plot will appear. The position of the red vertical line relative to the black line tells the detectability story: if the red line is to right of the black line, the event has a high probabilty of being detected - if the red line is to the left of the black line it has a lower probability of detection, with that probablity decreasing as the black line moves more and more to the right (red) line. <span style=\" font-weight:600; color:#fc0107;\">Note:</span> the red line may not be visible on some computer displays due to resolution differences and so will appear off screen to the right. Resize the plot to make the red line visible in this case. </p><p>If the event (possibly a minimum event duration discovered during a search) was found to be detectable, a sample light-curve is displayed that shows an example observation with such an event included.</p><p>If the result was no detectable event, a False-Positive plot will be shown instead of the first duration that failed (red bar to left of black bar). The sequnce of detectability tests and the event duration where an event is determined to be undectable will be recorded in a separate .detectability.PYOTE.log file written in the occultation event folder.</p><p><br/></p></body></html>"))
        self.calcDetectabilityButton.setText(_translate("MainWindow", "Calc detectability"))
        self.writeExampleLightcurveCheckBox.setText(_translate("MainWindow", "Write example lightcurve to csv file"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab_8), _translate("MainWindow", "Noise analysis/Detectability"))
        self.ne3ExplanationButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>This tab is provided for users of the RunCam Night Eagle 3 camera</p><p>The Night Eagle 3 is a <span style=\" color:#fc0107;\">rolling shutter CMOS camera</span>. As a result, with this camera, the timing of an occultation depends on which row the occulted star is at when the occultation occurs. PyOTE will automatically calculate the needed time correction from the y (row) position that you enter in the spin/entry box at the bottom of this tab.</p><p>For the Night Eagle 3, times extracted by PyOTE require only a VTI correction (if you use an IOTA VTI, there is no correction at all needed).</p><p>Note: if the recording was <span style=\" font-weight:600;\">not</span> made with a tracking telescope (so the target star is moving across the image), you will need to watch the video and record the row of the occultation for use in this program. Normally, with a tracking telescope, you will be able to use the y position of the \'target\' aperture directly. PyMovie includes this information in the comment lines of the csv file.</p><p>The Night Eagle 3 has a very effective noise reduction system called DNR (Dynamic Noise Reduction). There are 4 levels of noise reduction and you will need to indicate on this tab page what DNR setting your recording was made with.</p><p>The noise reduction is not without a small cost, however - the edges of an occultation light-curve will no longer be a step change. Instead, the edges will follow an exponential curve, approaching maximum and minimum intensities asymptotically. PyOTE has the ability to fit such an exponential curve to the D and R transitions, so the time resolution will be restored during the least squares fit of a \'theoretical\' exponential transition curve and you should feel free to use whatever level of noise reduction you may need. It is recommended that you run your NE3 at a gamma of 0.75 (1.0 gamma is not available) AND that you use PyMovie to linearize the recording (i.e., invert the 0.75 gamma curve of the camera).</p><p>The D and R exponential curves each have their own time constant, measured in frames, that control the frame rate of exponential curve growth. The default values provided are usually enough to allow a good fit to be found. <span style=\" color:#fc0107;\">PyOTE uses those values as the starting point for a least-squares search for better values. This usually works well, but it is possible that a starting value is too far from the correct value and the least-squares refinement process will find a local minimum that is visually wrong. In that case, you should change the starting value to something closer to \'correct\' and let the \'solver\' try again.</span></p><p>When the exponential curve fit algorithm is in use, the light-curve plot PyOTE displays will be changed. Gone is the blue \'camera response\' curve, replaced by brown dotted \'theoretical\' exponential edge curves that you can use to judge for yourself the goodness of a \'fit\'.</p><p><span style=\" color:#0000ff;\">When recording an an event video with the Night Eagle 3 camera, you can use any of the DNR settings, but make sure that your expected event duration is long enough that the D transition exponential curve has time to settle to the bottom plus some time to allow a good determination of the event bottom intensity. At </span><span style=\" font-weight:600; color:#fc0107;\">DNR:HIGH</span><span style=\" color:#0000ff;\">, your expected time should be greater than 30 frames (1 second) to use this setting. I suggest the following rules-of-thumb: use </span><span style=\" font-weight:600; color:#fc0107;\">DNR:LOW</span><span style=\" color:#0000ff;\"> for all recordings except when stars are at the limit of the camera are being observed, then use incrementally stronger levels of DNR to the point where the star is visible on-screen.</span></p></body></html>"))
        self.ne3ExplanationButton.setText(_translate("MainWindow", "Night Eagle 3  (explanation and help)"))
        self.ne3NotInUseRadioButton.setText(_translate("MainWindow", "Night Eagle 3 not in use"))
        self.dnrOffRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3, operating with a DNR setting of OFF does no noise reduction and there is no exponential transition zone for step changes of light. So, unlike the other DNR settings, there is no need for \'edge\' time constant values.</p></body></html>"))
        self.dnrOffRadioButton.setText(_translate("MainWindow", "DNR: Off"))
        self.dnrLowRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3 operating with an active DNR setting (i.e., other than OFF) reduces noise but also creates a light-curve that has exponential transitions (i.e., an asymptotic approach to the ultimate event or baseline intensity) at D and R edges in response to a step change in light. PyOTE will fit a \'theoretical\' exponential curve to the light-curve using a least-squares fit of the \'theoretical\' edge. This procedure utilizes the timing information that has been \'smeared\' across the transition region in such a way that timing resolution is restored.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: TC stands for time constant. It is measured in frames.</span></p><p><span style=\" color:#000000;\">The shape of the \'theoretical\' transition is governed by the time constant used at each edge. The TC values in the spin/entry boxes to the right give PyOTE starting values to use in a least-squares driven search for better TC values that will produce transition curves that better fit the observed values.</span></p><p><span style=\" color:#000000;\">It is possible that the starting TC value is too far from the \'correct\' values and the least-squares search routine, as a consequence, finds a local minimum that produces a visibly incorrect fit. In this case, change the starting value to something closer to \'correct\' and try again.</span></p></body></html>"))
        self.dnrLowRadioButton.setText(_translate("MainWindow", "DNR: Low"))
        self.dnrLowDtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrLowDtcLabel.setText(_translate("MainWindow", "TC:D edge"))
        self.dnrLowDspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrLowRtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrLowRtcLabel.setText(_translate("MainWindow", "TC:R edge"))
        self.dnrLowRspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3 operating with an active DNR setting (i.e., other than OFF) reduces noise but also creates a light-curve that has exponential transitions (i.e., an asymptotic approach to the ultimate event or baseline intensity) at D and R edges in response to a step change in light. PyOTE will fit a \'theoretical\' exponential curve to the light-curve using a least-squares fit of the \'theoretical\' edge. This procedure utilizes the timing information that has been \'smeared\' across the transition region in such a way that timing resolution is restored.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: TC stands for time constant. It is measured in frames.</span></p><p><span style=\" color:#000000;\">The shape of the \'theoretical\' transition is governed by the time constant used at each edge. The TC values in the spin/entry boxes to the right give PyOTE starting values to use in a least-squares driven search for better TC values that will produce transition curves that better fit the observed values.</span></p><p><span style=\" color:#000000;\">It is possible that the starting TC value is too far from the \'correct\' values and the least-squares search routine, as a consequence, finds a local minimum that produces a visibly incorrect fit. In this case, change the starting value to something closer to \'correct\' and try again.</span></p></body></html>"))
        self.dnrMiddleRadioButton.setText(_translate("MainWindow", "DNR: Middle"))
        self.dnrMiddleDtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleDtcLabel.setText(_translate("MainWindow", "TC:D edge"))
        self.dnrMiddleDspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleRtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrMiddleRtcLabel.setText(_translate("MainWindow", "TC:R edge"))
        self.dnrMiddleRspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighRadioButton.setToolTip(_translate("MainWindow", "<html><head/><body><p>The NE3 operating with an active DNR setting (i.e., other than OFF) reduces noise but also creates a light-curve that has exponential transitions (i.e., an asymptotic approach to the ultimate event or baseline intensity) at D and R edges in response to a step change in light. PyOTE will fit a \'theoretical\' exponential curve to the light-curve using a least-squares fit of the \'theoretical\' edge. This procedure utilizes the timing information that has been \'smeared\' across the transition region in such a way that timing resolution is restored.</p><p><span style=\" font-weight:600; color:#0000ff;\">Note: TC stands for time constant. It is measured in frames.</span></p><p><span style=\" color:#000000;\">The shape of the \'theoretical\' transition is governed by the time constant used at each edge. The TC values in the spin/entry boxes to the right give PyOTE starting values to use in a least-squares driven search for better TC values that will produce transition curves that better fit the observed values.</span></p><p><span style=\" color:#000000;\">It is possible that the starting TC value is too far from the \'correct\' values and the least-squares search routine, as a consequence, finds a local minimum that produces a visibly incorrect fit. In this case, change the starting value to something closer to \'correct\' and try again.</span></p></body></html>"))
        self.dnrHighRadioButton.setText(_translate("MainWindow", "DNR: High"))
        self.dnrHighDtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighDtcLabel.setText(_translate("MainWindow", "TC:D edge"))
        self.dnrHighDspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighRtcLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.dnrHighRtcLabel.setText(_translate("MainWindow", "TC:R edge"))
        self.dnrHighRspinBox.setToolTip(_translate("MainWindow", "<html><head/><body><p>This spin box provides the starting time constant value (TC) - it is given to PyOTE to be used during a least-squares search for a better value.</p><p>It sometimes happens that this initial value is too far from the \'correct\' value and the least-squares improvement algorithm will settle on a local minimum that is visually obviously wrong. In this case, change this starting value to something closer to \'correct\' and try again.</p></body></html>"))
        self.yPositionLabel.setToolTip(_translate("MainWindow", "<html><head/><body><p>Use this spin/entry box to enter the image row the target star was on when the occultation occured.</p><p>The Night Eagle 3 is a rolling shutter CMOS camera. As a result, with this camera, the timing of an occultation depends on which row the occulted star is at when the occultation occurs. PyOTE will automatically calculate the needed time correction from the y (row) position that you enter in this box.</p><p>For the Night Eagle 3, times extracted by PyOTE require only a VTI correction (if you use an IOTA VTI, there is no correction at all needed).</p><p>Note: if the recording was <span style=\" font-weight:600;\">not</span> made with a tracking telescope (so the targer star is moving across the image), you will need to watch the video and record the row of the occultation for use in this program. Normally, with a tracking telescope, you will be able to use the y position of the \'target\' aperture directly. PyMovie includes this information in the comment lines of the csv file.</p></body></html>"))
        self.yPositionLabel.setText(_translate("MainWindow", "y position of target star"))
        self.tabWidget.setTabText(self.tabWidget.indexOf(self.tab), _translate("MainWindow", "Night Eagle 3"))
        self.helpLabelForDataGrid.setToolTip(_translate("MainWindow", "<html><head/><body><p>Clicking at the left-edge of a data line will cause the corresponding data point in the main display to be highlighted. Only one such point can be high-lighted at a time.</p><p>Clicking a point in the main data plot will cause this data grid to be positioned at that data point with the row shown in red. Clicking anywhere in this row will \'toggle\' the selection of that point, useful when the main data plot is very dense.</p></body></html>"))
        self.helpLabelForDataGrid.setText(_translate("MainWindow", "Right-click this label to get explanation of data grid below:"))
        self.table.setToolTip(_translate("MainWindow", "<html><head/><body><p><span style=\" font-size:18pt;\">The data displayed in this table is read from the input file. The Timestamp column in this table will be filled in in response to a successful Manual Timestamp Entry procedure. The results of smoothing and normalization are NOT reflected in this table. The results of a Block Integration ARE reflected in this table.  This policy allows this table to be used as the source when a user requests that a csv file be written, presumably to capture timestamps filled in by Manual Timestamp Entry and a possible Block Integration, thus speeding future re-analysis efforts.</span></p><p><span style=\" font-size:18pt;\">Clicking on a data row (at the extreme left) in this panel will cause the corresponding point to be highlighted in the light curve plot. The highlighted point is shown as a largish yellow dot with a red rim --- it may be hard to see/find, but look for it.</span></p><p><span style=\" font-size:18pt; font-weight:600;\">Clicking on a data cell in a row will select/deselect that point in the primary (dark blue) light curve plot. This is provided as an alternative method to clicking on points in the main light curve plot to select/deslect them.</span></p><p><span style=\" font-size:18pt;\">Note: Clicking on a point in the primary (dark blue) light curve will cause the data row for that point to be selected/positioned.</span></p></body></html>"))
from pyqtgraph import PlotWidget
